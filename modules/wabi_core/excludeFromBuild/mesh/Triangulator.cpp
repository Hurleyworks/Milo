// This source file was auto-generated by ClassMate++
// Created: 1 Aug 2010 2:09:52 pm
// Copyright (c) 2010, HurleyWorks

// ctor
template <typename T>
Triangulator<T>::Triangulator (long numVerts,
                               const Matrix<T,3,1> * verts, 
                               const Matrix<T,3,1> & normal, 
                               Tri * trisOut)
	: vertexCount(numVerts),
	  vertex(verts),
	  normal(normal),
	  triangle(trisOut),
	  active( new bool[vertexCount] ),
	  numTris(0),
	  start(0),
	  p1(0),
	  p2(1),
	  m1( vertexCount -1 ),
	  m2( vertexCount - 2 ),
	  lastPositive(false)
	  
{	
	for (long a = 0; a < vertexCount; a++)
			active[a] = true;

	triple();
}

// dtor
template <typename T>
Triangulator<T>::~Triangulator ()
{	
	delete[] active;
}

// getNextActive
template <typename T>
long Triangulator<T>::getNextActive (long x, long vertexCount, const bool * active)
{	
	for (;;)
	{
		if (++x == vertexCount) x = 0;
		if (active[x]) return (x);
	}
}

// getPrevActive
template <typename T>
long Triangulator<T>::getPrevActive (long x, long vertexCount, const bool * active)
{	
	for (;;)
	{
		if (--x == -1) x = vertexCount - 1;
		if (active[x]) return (x);
	}
}

// triCount
template <typename T>
int Triangulator<T>::triCount ()
{	
	return numTris;
}

// triple
template <typename T>
long Triangulator<T>::triple ()
{	
	for (;;)
	{
		if (p2 == m2)
		{	
			// Only three vertices remain
			triangle->index[0] = m1;
			triangle->index[1] = p1;
			triangle->index[2] = p2;
			numTris++;
			break;
		}
		const Matrix<T,3,1>& vp1 = vertex[p1];
		const Matrix<T,3,1>& vp2 = vertex[p2];
		const Matrix<T,3,1>& vm1 = vertex[m1];
		const Matrix<T,3,1>& vm2 = vertex[m2];
	
		bool positive = false;
		bool negative = false;
		
		// Determine whether vp1, vp2, and vm1 form
		// a valid triangle
		Matrix<T,3,1> v = vm1 - vp2;
		v.normalize();
	
		Matrix<T,3,1> n1 = normal.cross(v);
		
		if( n1.dot(vp1 - vp2) > limits<T>::epsilon() )
		{
			positive = true;
			v  = vp1 - vm1;
			v.normalize();
			Matrix<T,3,1> n2 = normal.cross(v);
			
			v  = vp2 - vp1;
			v.normalize();
			Matrix<T,3,1> n3 = normal.cross(v);
			
			for (long a = 0; a < vertexCount; a++)
			{	
				// Look for other vertices inside the triangle
				if ((active[a]) && (a != p1) && (a != p2) && (a != m1))
				{
					const Matrix<T,3,1>& p = vertex[a];
					Matrix<T,3,1> vec1 = p - vp2;
					Matrix<T,3,1> vec2 = p - vm1;
					Matrix<T,3,1> vec3 = p - vp1;
					vec1.normalize();
					vec2.normalize();
					vec3.normalize();
						
					if ((n1.dot(vec1) > -limits<T>::epsilon())
						&& (n2.dot(vec2) > -limits<T>::epsilon())
						&& (n3.dot(vec3) > -limits<T>::epsilon()))
					{
						positive = false;
						break;
					}
				}
			}
		}
		
		// Determine whether vm1, vm2, and vp1 form
		// a valid triangle
		v = vm2 - vp1;
		v.normalize();
		n1 = normal.cross(v);

		if ( n1.dot(vm1 - vp1) > limits<T>::epsilon())
		{
			negative = true;
			v = vm1 - vm2;
			v.normalize();
			Matrix<T,3,1> n2 = normal.cross(v);
	
			v = vp1 - vm1;
			v.normalize();
			Matrix<T,3,1> n3 = normal.cross(v);
		
			for (long a = 0; a < vertexCount; a++)
			{	
				// Look for other vertices inside the triangle
				if ((active[a])
					&& (a != m1) && (a != m2) && (a != p1))
				{
					const Matrix<T,3,1>& p = vertex[a];
					Matrix<T,3,1> vec1 = p - vp1;
					Matrix<T,3,1> vec2 = p - vm2;
					Matrix<T,3,1> vec3 = p - vm1;
					vec1.normalize();
					vec2.normalize();
					vec3.normalize();
					if ( ( n1.dot(vec1) > -limits<T>::epsilon() )
					&& ( n2.dot(vec2) > -limits<T>::epsilon())
					&& ( n3.dot(vec3) > -limits<T>::epsilon()))
					{
						negative = false;
						break;
					}
				}
			}
		}
		
		// If both triangles valid, choose the one
		// having the larger smallest angle
		Matrix<T,3,1> v2;
		if ((positive) && (negative))
		{
			v = vp2 - vm1;
			v.normalize();
			v2 = vm2 - vm1;
			v2.normalize();
			T pd = v.dot(v2);

			v = vm2 - vp1;
			v.normalize();
			v2 = vp2 - vp1;
			v2.normalize();
			T md = v.dot(v2);
			
			if (Math<T>::FAbs(pd - md) < limits<T>::epsilon())
			{
				if (lastPositive) positive = false;
				else negative = false;
			}
			else
			{
				if (pd < md) negative = false;
				else positive = false;
			}
		}
		
		if (positive)
		{	
			// Output the triangle m1, p1, p2
			active[p1] = false;
			triangle->index[0] = m1;
			triangle->index[1] = p1;
			triangle->index[2] = p2;
			numTris++;
			triangle++;
			
			p1 = getNextActive(p1, vertexCount, active);
			p2 = getNextActive(p2, vertexCount, active);
			lastPositive = true;
			start = -1;
		}
		else if (negative)
		{	
			// Output the triangle m2, m1, p1
			active[m1] = false;
			triangle->index[0] = m2;
			triangle->index[1] = m1;
			triangle->index[2] = p1;
			numTris++;
			triangle++;
			
			m1 = getPrevActive(m1, vertexCount, active);
			m2 = getPrevActive(m2, vertexCount, active);
			lastPositive = false;
			start = -1;
		}
		else
		{
			// Exit if we've gone all the way around the
			// polygon without finding a valid triangle
			if (start == -1)
				start = p2;
			else if (p2 == start)
				break;
			
			// Advance working set of vertices
			m2 = m1;
			m1 = p1;
			p1 = p2;
			p2 = getNextActive(p2, vertexCount, active);
		}
	}
	return numTris;
}

template
class Triangulator<float>;

template
class Triangulator<double>;
