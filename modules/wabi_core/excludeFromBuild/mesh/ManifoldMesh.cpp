// This source file was auto-generated by ClassMate++
// Created: 31 Mar 2011 8:02:54 pm
// Copyright (c) 2011, HurleyWorks

ManifoldMesh::~ManifoldMesh()
{
	for (auto& element : eMap_)
	{
		delete element.second;
	}

	for (auto& element : tMap_)
	{
		delete element.second;
	}
}

ManifoldMesh::ManifoldMesh(ECreator eCreator, TCreator tCreator)
	:
	eCreator_(eCreator ? eCreator : createEdge),
	tCreator_(tCreator ? tCreator : CreateTriangle),
	assertOnNonmanifoldInsertion_(true)
{
}

ManifoldMesh::ManifoldMesh(ManifoldMesh const& mesh)
{
	*this = mesh;
}

ManifoldMesh& ManifoldMesh::operator=(ManifoldMesh const& mesh)
{
	clear();

	eCreator_ = mesh.eCreator_;
	tCreator_ = mesh.tCreator_;
	assertOnNonmanifoldInsertion_ = mesh.assertOnNonmanifoldInsertion_;
	for (auto const& element : mesh.tMap_)
	{
		insert(element.first.V[0], element.first.V[1], element.first.V[2]);
	}

	return *this;
}

ManifoldMesh::EMap const& ManifoldMesh::getEdges() const
{
	return eMap_;
}

ManifoldMesh::TMap const& ManifoldMesh::getTriangles() const
{
	return tMap_;
}

void ManifoldMesh::assertOnNonmanifoldInsertion(bool doAssert)
{
	assertOnNonmanifoldInsertion_ = doAssert;
}

ManifoldMesh::Triangle* ManifoldMesh::insert(int v0, int v1, int v2)
{
	TriangleKey<true> tkey(v0, v1, v2);
	if (tMap_.find(tkey) != tMap_.end())
	{
		// The triangle already exists.  Return a null pointer as a signal to
		// the caller that the insertion failed.
		return nullptr;
	}

	// Add the new triangle.
	Triangle* tri = tCreator_(v0, v1, v2);
	tMap_[tkey] = tri;

	// Add the edges to the mesh if they do not already exist.
	for (int i0 = 2, i1 = 0; i1 < 3; i0 = i1++)
	{
		EdgeKey<false> ekey(tri->V[i0], tri->V[i1]);
		Edge* edge;
		auto eiter = eMap_.find(ekey);
		if (eiter == eMap_.end())
		{
			// This is the first time the edge is encountered.
			edge = eCreator_(tri->V[i0], tri->V[i1]);
			eMap_[ekey] = edge;

			// Update the edge and triangle.
			edge->T[0] = tri;
			tri->E[i0] = edge;
		}
		else
		{
			// This is the second time the edge is encountered.
			edge = eiter->second;
			if (!edge)
			{
				LOG(CRITICAL) << ("Unexpected condition.");
				return nullptr;
			}

			// Update the edge.
			if (edge->T[1])
			{
				if (assertOnNonmanifoldInsertion_)
				{
					LOG(INFO) << ("The mesh must be manifold.");
				}
				return nullptr;
			}
			edge->T[1] = tri;

			// Update the adjacent triangles.
			Triangle* adjacent = edge->T[0];
			if (!adjacent)
			{
				LOG(CRITICAL) << ("Unexpected condition.");
				return nullptr;
			}
			for (int j = 0; j < 3; ++j)
			{
				if (adjacent->E[j] == edge)
				{
					adjacent->T[j] = tri;
					break;
				}
			}

			// Update the triangle.
			tri->E[i0] = edge;
			tri->T[i0] = adjacent;
		}
	}

	return tri;
}

bool ManifoldMesh::remove(int v0, int v1, int v2)
{
	TriangleKey<true> tkey(v0, v1, v2);
	auto titer = tMap_.find(tkey);
	if (titer == tMap_.end())
	{
		// The triangle does not exist.
		return false;
	}

	// Get the triangle.
	Triangle* tri = titer->second;

	// remove the edges and update adjacent triangles if necessary.
	for (int i = 0; i < 3; ++i)
	{
		// Inform the edges the triangle is being deleted.
		Edge* edge = tri->E[i];
		if (!edge)
		{
			// The triangle edge should be nonnull.
			LOG(CRITICAL) << ("Unexpected condition.");
			return false;
		}

		if (edge->T[0] == tri)
		{
			// One-triangle edges always have pointer at index zero.
			edge->T[0] = edge->T[1];
			edge->T[1] = nullptr;
		}
		else if (edge->T[1] == tri)
		{
			edge->T[1] = nullptr;
		}
		else
		{
			LOG(CRITICAL) << ("Unexpected condition.");
			return false;
		}

		// remove the edge if you have the last reference to it.
		if (!edge->T[0] && !edge->T[1])
		{
			EdgeKey<false> ekey(edge->V[0], edge->V[1]);
			eMap_.erase(ekey);
			delete edge;
		}

		// Inform adjacent triangles the triangle is being deleted.
		Triangle* adjacent = tri->T[i];
		if (adjacent)
		{
			for (int j = 0; j < 3; ++j)
			{
				if (adjacent->T[j] == tri)
				{
					adjacent->T[j] = nullptr;
					break;
				}
			}
		}
	}

	tMap_.erase(tkey);
	delete tri;
	return true;
}

void ManifoldMesh::clear()
{
	for (auto& element : eMap_)
	{
		delete element.second;
	}

	for (auto& element : tMap_)
	{
		delete element.second;
	}

	eMap_.clear();
	tMap_.clear();
}

bool ManifoldMesh::isClosed() const
{
	for (auto const& element : eMap_)
	{
		Edge const* edge = element.second;
		if (!edge->T[0] || !edge->T[1])
		{
			return false;
		}
	}
	return true;
}

bool ManifoldMesh::isOriented() const
{
	for (auto const& element : eMap_)
	{
		Edge const* edge = element.second;
		if (edge->T[0] && edge->T[1])
		{
			// In each triangle, find the ordered edge that corresponds to the
			// unordered edge element.first.  Also find the vertex opposite
			// that edge.
			bool edgePositive[2] = { false, false };
			int vOpposite[2] = { -1, -1 };
			for (int j = 0; j < 2; ++j)
			{
				for (int i = 0; i < 3; ++i)
				{
					if (edge->T[j]->V[i] == element.first.V[0])
					{
						int vNext = edge->T[j]->V[(i + 1) % 3];
						if (vNext == element.first.V[1])
						{
							edgePositive[j] = true;
							vOpposite[j] = edge->T[j]->V[(i + 2) % 3];
						}
						else
						{
							edgePositive[j] = false;
							vOpposite[j] = vNext;
						}
						break;
					}
				}
			}

			// To be oriented consistently, the edges must have reversed
			// ordering and the oppositive vertices cannot match.
			if (edgePositive[0] == edgePositive[1]
				|| vOpposite[0] == vOpposite[1])
			{
				return false;
			}
		}
	}
	return true;
}

void ManifoldMesh::getComponents(std::vector<std::vector<Triangle const*>>& components) const
{
	// visited: 0 (unvisited), 1 (discovered), 2 (finished)
	std::map<Triangle const*, int> visited;
	for (auto const& element : tMap_)
	{
		visited.insert(std::make_pair(element.second, 0));
	}

	for (auto& element : tMap_)
	{
		Triangle const* tri = element.second;
		if (visited[tri] == 0)
		{
			std::vector<Triangle const*> component;
			depthFirstSearch(tri, visited, component);
			components.push_back(component);
		}
	}
}

void ManifoldMesh::getComponents(std::vector<std::vector<TriangleKey<true>>>& components) const
{
	// visited: 0 (unvisited), 1 (discovered), 2 (finished)
	std::map<Triangle const*, int> visited;
	for (auto const& element : tMap_)
	{
		visited.insert(std::make_pair(element.second, 0));
	}

	for (auto& element : tMap_)
	{
		Triangle const* tri = element.second;
		if (visited[tri] == 0)
		{
			std::vector<Triangle const*> component;
			depthFirstSearch(tri, visited, component);

			std::vector<TriangleKey<true>> keyComponent;
			keyComponent.reserve(component.size());
			for (auto const* t : component)
			{
				keyComponent.push_back(
					TriangleKey<true>(t->V[0], t->V[1], t->V[2]));
			}
			components.push_back(keyComponent);
		}
	}
}

void ManifoldMesh::print(std::ostream& output) const
{
	if (output.bad())
	{
		LOG(CRITICAL) << ("Output stream is invalid.");
		return;
	}

	std::map<Edge*, int> eIndex;
	std::map<Triangle*, int> tIndex;
	assignUniqueIndices(eIndex, tIndex);
	printEdgesTriangles(output, eIndex, tIndex);
}

void ManifoldMesh::depthFirstSearch(Triangle const* tInitial,
									std::map<Triangle const*, int>& visited,
									std::vector<Triangle const*>& component) const
{
	// Allocate the maximum-size stack that can occur in the depth-first
	// search.  The stack is empty when the index top is -1.
	std::vector<Triangle const*> tStack(tMap_.size());
	int top = -1;
	tStack[++top] = tInitial;
	while (top >= 0)
	{
		Triangle const* tri = tStack[top];
		visited[tri] = 1;
		int i;
		for (i = 0; i < 3; ++i)
		{
			Triangle const* adj = tri->T[i];
			if (adj && visited[adj] == 0)
			{
				tStack[++top] = adj;
				break;
			}
		}
		if (i == 3)
		{
			visited[tri] = 2;
			component.push_back(tri);
			--top;
		}
	}
}

void ManifoldMesh::assignUniqueIndices(std::map<Edge*, int>& eIndex, std::map<Triangle*, int>& tIndex) const
{
	// Assign unique indices to the edges.
	eIndex.clear();
	eIndex[nullptr] = 0;
	int i = 1;
	for (auto const& element : eMap_)
	{
		if (element.second)
		{
			eIndex[element.second] = i++;
		}
	}

	// Assign unique indices to the triangles.
	tIndex[nullptr] = 0;
	i = 1;
	for (auto const& element : tMap_)
	{
		if (element.second)
		{
			tIndex[element.second] = i++;
		}
	}
}

void ManifoldMesh::printEdgesTriangles(std::ostream& output, std::map<Edge*, int>& eIndex, std::map<Triangle*, int>& tIndex) const
{
	output << "edge quantity = " << eMap_.size() << std::endl;
	for (auto const& element : eMap_)
	{
		Edge const& edge = *element.second;
		output << 'e' << eIndex[element.second] << " <"
			<< 'v' << edge.V[0] << ",v" << edge.V[1] << "; ";
		for (int j = 0; j < 2; ++j)
		{
			if (edge.T[j])
			{
				output << 't' << tIndex[edge.T[0]];
			}
			else
			{
				output << '*';
			}
			output << (j == 0 ? ',' : '>');
		}
		output << std::endl;
	}
	output << std::endl;

	output << "triangle quantity = " << tMap_.size() << std::endl;
	for (auto const& element : tMap_)
	{
		Triangle const& tri = *element.second;
		output << 't' << tIndex[element.second] << " <"
			<< 'v' << tri.V[0] << ",v" << tri.V[1] << ",v"
			<< tri.V[2] << "; ";
		for (int j = 0; j < 3; ++j)
		{
			if (tri.E[j])
			{
				output << 'e' << eIndex[tri.E[j]];
			}
			else
			{
				output << '*';
			}
			output << (j < 2 ? "," : "; ");
		}

		for (int j = 0; j < 3; ++j)
		{
			if (tri.T[j])
			{
				output << 't' << tIndex[tri.T[j]];
			}
			else
			{
				output << '*';
			}
			output << (j < 2 ? ',' : '>');
		}
		output << std::endl;
	}
	output << std::endl;
}

ManifoldMesh::Edge* ManifoldMesh::createEdge(int v0, int v1)
{
	return new Edge(v0, v1);
}

ManifoldMesh::Triangle* ManifoldMesh::CreateTriangle(int v0, int v1, int v2)
{
	return new Triangle(v0, v1, v2);
}

ManifoldMesh::Edge::~Edge()
{
}

ManifoldMesh::Edge::Edge(int v0, int v1)
{
	V[0] = v0;
	V[1] = v1;
	T[0] = nullptr;
	T[1] = nullptr;
}

ManifoldMesh::Triangle::~Triangle()
{
}

ManifoldMesh::Triangle::Triangle(int v0, int v1, int v2)
{
	V[0] = v0;
	V[1] = v1;
	V[2] = v2;
	for (int i = 0; i < 3; ++i)
	{
		E[i] = nullptr;
		T[i] = nullptr;
	}
}

