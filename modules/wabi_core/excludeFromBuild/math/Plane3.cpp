// This source file was auto-generated by ClassMate++
// Created: 19 Jul 2010 2:59:18 pm
// Copyright (c) 2010, HurleyWorks


// ctor
template <class T>
Plane3<T>::Plane3 ()
{	
}

// ctor
template <class T>
Plane3<T>::Plane3(const Eigen::Matrix<T,3,1> &p0,
				  const Eigen::Matrix<T,3,1> &p1,
				  const Eigen::Matrix<T,3,1> &p2)
{	
    set(p0,p1,p2);
}

// ctor
template <class T>
Plane3<T>::Plane3(const Eigen::Matrix<T,3,1> &n, T d)
{	
    set(n, d);
}

// ctor
template <class T>
Plane3<T>::Plane3(const Eigen::Matrix<T,3,1> &p, const Eigen::Matrix<T,3,1> &n)
{	
    set(p, n);
}

// dtor
template <class T>
Plane3<T>::~Plane3 ()
{	
}

// set
template <class T>
void Plane3<T>::set(const Eigen::Matrix<T,3,1>& point1,
					const Eigen::Matrix<T,3,1>& point2,
					const Eigen::Matrix<T,3,1>& point3)
{	
    normal = (point2 - point1).cross(point3 - point1);
    normal.normalize();
    distance = normal.dot(point1);
}

// set
template <class T>
void Plane3<T>::set(const Eigen::Matrix<T,3,1>& point, const Eigen::Matrix<T,3,1>& n)
{	
    normal = n;
    normal.normalize();
    distance = normal.dot(point);
}

// set
template <class T>
void Plane3<T>::set(const Eigen::Matrix<T,3,1>& n, T d)
{	
    normal = n;
    normal.normalize();
    distance = d;
}

// distanceTo
template <class T>
T Plane3<T>::distanceTo(const Eigen::Matrix<T,3,1> &point) const
{	
    return point.dot(normal) - distance;
}

// reflectPoint
template <class T>
 Eigen::Matrix<T,3,1> Plane3<T>::reflectPoint(const Eigen::Matrix<T,3,1> &point) const
{	

    return normal * distanceTo(point) * -2.0 + point;
}

// reflectVector
template <class T>
 Eigen::Matrix<T,3,1> Plane3<T>::reflectVector(const Eigen::Matrix<T,3,1> &vector) const
{	
    return normal * normal.dot(vector)  * 2.0 - vector;
}

// intersect
template <class T>
 bool Plane3<T>::intersect(const Line3<T>& line, Eigen::Matrix<T,3,1>& point) const
{	
    T d = normal.dot(line.dir);
    if ( d == 0.0 ) return false;
    T t = - (normal.dot(line.pos) - distance) /  d;
    point = line(t);
   
	return true;
}

// intersectT
template <class T>
 bool Plane3<T>::intersectT(const Line3<T>& line, T &t) const
{	
    T d = normal.dot(line.dir);
    if ( d == 0.0 ) return false;
    t = - (normal.dot(line.pos) - distance) /  d;
    return true;
}

template
struct Plane3<float>;

template
struct Plane3<double>;

