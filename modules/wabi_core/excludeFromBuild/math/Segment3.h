// This header file was auto-generated by ClassMate++
// Created: 6 Mar 2009 9:34:37 pm
// Copyright (c) 2009, HurleyWorks

// Geometric Tools, LLC
// Copyright (c) 1998-2010
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
//
// File Version: 5.0.0 (2010/01/01)

#pragma once

template <typename T>
class Segment3
{

 public:
    // The segment is represented as (1-s)*P0+s*P1, where P0 and P1 are the
    // endpoints of the segment and 0 <= s <= 1.
    //
    // Some algorithms involving segments might prefer a centered
    // representation similar to how oriented bounding boxes are defined.
    // This representation is C+t*D, where C = (P0+P1)/2 is the center of
    // the segment, D = (P1-P0)/Length(P1-P0) is a unit-length direction
    // vector for the segment, and |t| <= e.  The value e = Length(P1-P0)/2
    // is the 'extent' (or radius or half-length) of the segment.
    
    // Construction and destruction.
    Segment3 ();  // uninitialized
    ~Segment3 ();

    // The constructor computes C, D, and E from P0 and P1.
    Segment3 (const Eigen::Matrix<T,3,1>& endPoint0, const Eigen::Matrix<T,3,1>& endPoint1);

     // The constructor computes P0 and P1 from C, D, and E.
    Segment3 (const Eigen::Matrix<T,3,1>& center, const Eigen::Matrix<T,3,1>& direction, T extent);

    // Call this function when you change p0 or p1.
    void computeCenterDirectionExtent ();

    // Call this function when you change C, D, or e.
    void computeEndPoints ();

    // End-point representation.
    Eigen::Matrix<T,3,1> p0, p1;

    // center-direction-extent representation.
    Eigen::Matrix<T,3,1> center;
    Eigen::Matrix<T,3,1> direction;
    T extent;
};

template <typename T>
Segment3<T>::Segment3 ()
{
}

template <typename T>
Segment3<T>::~Segment3 ()
{
}

template <typename T>
Segment3<T>::Segment3 (const Eigen::Matrix<T,3,1>& endPoint0, const Eigen::Matrix<T,3,1>& endPoint1)
    : p0(endPoint0),
	  p1(endPoint1)
{
    computeCenterDirectionExtent();
}

template <typename T>
Segment3<T>::Segment3 (const Eigen::Matrix<T,3,1>& center, const Eigen::Matrix<T,3,1>& direction, T extent)
    : center(center),
	  direction(direction),
	  extent(extent)
{
    computeEndPoints();
}

template <typename T>
void Segment3<T>::computeCenterDirectionExtent ()
{
    center = ((T)0.5)*(p0 + p1);
    direction = p1 - p0;
	extent = ((T)0.5)*normalizeVec3(direction);
}

template <typename T>
void Segment3<T>::computeEndPoints ()
{
    p0 = center - extent*direction;
    p1 = center + extent*direction;
}

typedef Segment3<float> Segment3f;
typedef Segment3<double> Segment3d;
typedef std::vector<Segment3f> Seg3Vecf;
typedef std::vector<Segment3d> Seg3Vecd;
