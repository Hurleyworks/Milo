// This source file was auto-generated by ClassMate++
// Created: 19 Jul 2010 2:59:18 pm
// Copyright (c) 2010, HurleyWorks

// modified version of 
// Geometric Tools, LLC
// Copyright (c) 1998-2010
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt

template <typename T>
Line2Tri2Intersect<T>::Line2Tri2Intersect (const Line2<T>& line, const Triangle2<T>& triangle)
    : mLine(&line),
      mTriangle(&triangle)
{
}

template <typename T>
const Line2<T>& Line2Tri2Intersect<T>::getLine () const
{
    return *mLine;
}

template <typename T>
const Triangle2<T>& Line2Tri2Intersect<T>::getTriangle () const
{
    return *mTriangle;
}

template <typename T>
bool Line2Tri2Intersect<T>::test ()
{
    T dist[3];
    int sign[3], positive, negative, zero;
    TriangleLineRelations(mLine->origin, mLine->direction, *mTriangle,
						  dist, sign, positive, negative, zero);

    if (positive == 3 || negative == 3)
    {
        intersectionType_ = IT_EMPTY;
    }
    else
    {
        T param[2];
        getInterval(mLine->origin, mLine->direction, *mTriangle, dist, sign, param);

        Intersector1<T> intr(param[0], param[1], -Math<T>::MAX_REAL, +Math<T>::MAX_REAL);

        intr.find();

        mQuantity = intr.getNumIntersections();
        if (mQuantity == 2)
        {
            intersectionType_ = IT_SEGMENT;
        }
        else if (mQuantity == 1)
        {
            intersectionType_ = IT_POINT;
        }
        else
        {
            intersectionType_ = IT_EMPTY;
        }
    }

    return intersectionType_ != IT_EMPTY;
}

template <typename T>
bool Line2Tri2Intersect<T>::find ()
{
    T dist[3];
    int sign[3], positive, negative, zero;
    TriangleLineRelations(mLine->origin, mLine->direction, *mTriangle, dist, sign, positive, negative, zero);

    if (positive == 3 || negative == 3)
    {
        // No intersections.
        mQuantity = 0;
        intersectionType_ = IT_EMPTY;
    }
    else
    {
        T param[2];
        getInterval(mLine->origin, mLine->direction, *mTriangle, dist,
            sign, param);

        Intersector1<T> intr(param[0], param[1],
            -Math<T>::MAX_REAL, +Math<T>::MAX_REAL);

        intr.find();

        mQuantity = intr.getNumIntersections();
        if (mQuantity == 2)
        {
            // Segment intersection.
            intersectionType_ = IT_SEGMENT;
            mPoint[0] = mLine->origin +
                intr.getIntersection(0)*mLine->direction;
            mPoint[1] = mLine->origin +
                intr.getIntersection(1)*mLine->direction;
        }
        else if (mQuantity == 1)
        {
            // Point intersection.
            intersectionType_ = IT_POINT;
            mPoint[0] = mLine->origin +
                intr.getIntersection(0)*mLine->direction;
        }
        else
        {
            // No intersections.
            intersectionType_ = IT_EMPTY;
        }
    }

    return intersectionType_ != IT_EMPTY;
}

template <typename T>
int Line2Tri2Intersect<T>::getQuantity () const
{
    return mQuantity;
}

template <typename T>
const Eigen::Matrix<T,2,1>& Line2Tri2Intersect<T>::getPoint (int i) const
{
    return mPoint[i];
}

template <typename T>
void Line2Tri2Intersect<T>::TriangleLineRelations (const Eigen::Matrix<T,2,1>& origin,
												   const Eigen::Matrix<T,2,1>& direction,
												   const Triangle2<T>& triangle, T dist[3], int sign[3],
												   int& positive, int& negative, int& zero)
{
    positive = 0;
    negative = 0;
    zero = 0;
    for (int i = 0; i < 3; ++i)
    {
        Eigen::Matrix<T,2,1> diff = triangle.v_[i] - origin;
        dist[i] = dotPerp(diff, direction);
        if (dist[i] > Math<T>::ZERO_TOLERANCE)
        {
            sign[i] = 1;
            ++positive;
        }
        else if (dist[i] < -Math<T>::ZERO_TOLERANCE)
        {
            sign[i] = -1;
            ++negative;
        }
        else
        {
            dist[i] = (T)0;
            sign[i] = 0;
            ++zero;
        }
    }
}

template <typename T>
void Line2Tri2Intersect<T>::getInterval (const Eigen::Matrix<T,2,1>& origin,
										 const Eigen::Matrix<T,2,1>& direction, 
										 const Triangle2<T>& triangle,
										 const T dist[3], const int sign[3], T param[2])
{
    // Project triangle onto line.
    T proj[3];
    int i;
    for (i = 0; i < 3; ++i)
    {
        Eigen::Matrix<T,2,1> diff = triangle.v_[i] - origin;
        proj[i] = direction.dot(diff);
    }

    // Compute transverse intersections of triangle edges with line.
    T numer, denom;
    int i0, i1, i2;
    int quantity = 0;
    for (i0 = 2, i1 = 0; i1 < 3; i0 = i1++)
    {
        if (sign[i0]*sign[i1] < 0)
        {
			// Too many intersections
            debug_assert(quantity < 2);
            numer = dist[i0]*proj[i1] - dist[i1]*proj[i0];
            denom = dist[i0] - dist[i1];
            param[quantity++] = numer/denom;
        }
    }

    // Check for grazing contact.
    if (quantity < 2)
    {
        for (i0 = 1, i1 = 2, i2 = 0; i2 < 3; i0 = i1, i1 = i2++)
        {
            if (sign[i2] == 0)
            {
				// Too many intersections
                debug_assert(quantity < 2);
                param[quantity++] = proj[i2];
            }
        }
    }

    // Sort.
	// "Need at least one intersection
    debug_assert(quantity >= 1);
    if (quantity == 2)
    {
        if (param[0] > param[1])
        {
            T save = param[0];
            param[0] = param[1];
            param[1] = save;
        }
    }
    else
    {
        param[1] = param[0];
    }
}

// Explicit instantiation.
template 
class Line2Tri2Intersect<float>;

template 
class Line2Tri2Intersect<double>;



