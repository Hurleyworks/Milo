// This source file was auto-generated by ClassMate++
// Created: 19 Jul 2010 2:59:18 pm
// Copyright (c) 2010, HurleyWorks

// modified version of 
// Geometric Tools, LLC
// Copyright (c) 1998-2010
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt

// ctor
template <typename T>
Tri2Tri2Intersect<T>::Tri2Tri2Intersect (const Triangle2 <T> & triangle0,
                                         const Triangle2 <T> & triangle1)
	: mTriangle0(&triangle0),
      mTriangle1(&triangle1)
{	
	mQuantity = 0;
}

// dtor
template <typename T>
Tri2Tri2Intersect<T>::~Tri2Tri2Intersect ()
{	
}

// clipConvexPolygonAgainstLine
template <typename T>
void Tri2Tri2Intersect<T>::clipConvexPolygonAgainstLine (const Eigen::Matrix <T,2,1> & N, 
                                                         T c, 
                                                         int & quantity, 
                                                         Eigen::Matrix <T,2,1> V[6])
{	

	// The input vertices are assumed to be in counterclockwise order.  The
    // ordering is an invariant of this function.

    // test on which side of line the vertices are.
    int positive = 0, negative = 0, pIndex = -1;
    T test[6];
    int i;
    for (i = 0; i < quantity; ++i)
    {
        test[i] = N.dot(V[i]) - c;
        if (test[i] > (T)0)
        {
            positive++;
            if (pIndex < 0)
            {
                pIndex = i;
            }
        }
        else if (test[i] < (T)0)
        {
            negative++;
        }
    }

	if (positive > 0)
    {
        if (negative > 0)
        {
            // Line transversely intersects polygon.
            Eigen::Matrix<T,2,1> CV[6];
            int cQuantity = 0, cur, prv;
            T t;

            if (pIndex > 0)
            {
                // First clip vertex on line.
                cur = pIndex;
                prv = cur - 1;
                t = test[cur]/(test[cur] - test[prv]);
                CV[cQuantity++] = V[cur] + t*(V[prv] - V[cur]);

                // Vertices on positive side of line.
                while (cur < quantity && test[cur] > (T)0)
                {
                    CV[cQuantity++] = V[cur++];
                }

                // Last clip vertex on line.
                if (cur < quantity)
                {
                    prv = cur - 1;
                }
                else
                {
                    cur = 0;
                    prv = quantity - 1;
                }
                t = test[cur]/(test[cur] - test[prv]);
                CV[cQuantity++] = V[cur] + t*(V[prv]-V[cur]);
            }
            else  // pIndex is 0
            {
                // Vertices on positive side of line.
                cur = 0;
                while (cur < quantity && test[cur] > (T)0)
                {
                    CV[cQuantity++] = V[cur++];
                }

                // Last clip vertex on line.
                prv = cur - 1;
                t = test[cur]/(test[cur] - test[prv]);
                CV[cQuantity++] = V[cur] + t*(V[prv] - V[cur]);

                // Skip vertices on negative side.
                while (cur < quantity && test[cur] <= (T)0)
                {
                    ++cur;
                }

                // First clip vertex on line.
                if (cur < quantity)
                {
                    prv = cur - 1;
                    t = test[cur]/(test[cur] - test[prv]);
                    CV[cQuantity++] = V[cur] + t*(V[prv] - V[cur]);

                    // Vertices on positive side of line.
                    while (cur < quantity && test[cur] > (T)0)
                    {
                        CV[cQuantity++] = V[cur++];
                    }
                }
                else
                {
                    // cur = 0
                    prv = quantity - 1;
                    t = test[0]/(test[0] - test[prv]);
                    CV[cQuantity++] = V[0] + t*(V[prv] - V[0]);
                }
            }

            quantity = cQuantity;
            memcpy(V, CV, cQuantity*sizeof(Eigen::Matrix<T,2,1>));
        }
        // else polygon fully on positive side of line, nothing to do.
    }
    else
    {
        // Polygon does not intersect positive side of line, clip all.
        quantity = 0;
    }

}

template <typename T>
const Eigen::Matrix<T,2,1>& Tri2Tri2Intersect<T>::getPoint (int i) const
{
	debug_assert( i >= 0  &&  i < 6 );

	return mPoint[i];
}

// find
template <typename T>
bool Tri2Tri2Intersect<T>::find ()
{	
	// The potential intersection is initialized to triangle1.  The set of
    // vertices is refined based on clipping against each edge of triangle0.
    mQuantity = 3;
    for (int i = 0; i < 3; ++i)
    {
        mPoint[i] = mTriangle1->v_[i];
    }

    for (int i1 = 2, i0 = 0; i0 < 3; i1 = i0++)
    {
        // Clip against edge <V0[i1],V0[i0]>.
        Eigen::Matrix<T,2,1> N(	mTriangle0->v_[i1][1] - mTriangle0->v_[i0][1],
								mTriangle0->v_[i0][0] - mTriangle0->v_[i1][0]);
        T c = N.dot(mTriangle0->v_[i1]);
        clipConvexPolygonAgainstLine(N, c, mQuantity, mPoint);
        if (mQuantity == 0)
        {
            // Triangle completely clipped, no intersection occurs.
            return false;
        }
    }

	return true;
}

// test
template <typename T>
bool Tri2Tri2Intersect<T>::test ()
{	
	return true;
}

// Explicit instantiation.
template 
class Tri2Tri2Intersect<float>;

template 
class Tri2Tri2Intersect<double>;


