// This header file was auto-generated by ClassMate++
// Created: 20 Feb 2009 8:42:31 pm
// Copyright (c) 2009, HurleyWorks

#pragma once

template <class T>
class BoundingBox3
{

 public:
	typedef std::pair<unsigned int, unsigned int> EdgePnts;
	typedef std::vector<EdgePnts> EdgePntsList;

	enum Axis {X, Y, Z};

 public:
	BoundingBox3 ();
	BoundingBox3 (const BoundingBox3 & b);
	BoundingBox3 (const Eigen::Matrix<T,3,1> & point);
	BoundingBox3 (T size);
	BoundingBox3 (Eigen::Matrix<T,3,1> minimum, Eigen::Matrix<T,3,1> maximum);
	BoundingBox3 (T x, T y, T z);

	~BoundingBox3 ();

	std::string asString() const;

	void include(const Eigen::Matrix<T, 3, 1> & point);
	void include(const BoundingBox3 & box);

	bool intersect(const Ray3 <T> & ray, T * hit0 = 0, T * hit1 = 0) const;
	bool intersects(const BoundingBox3 & box) const;

	void setEmpty();
	bool isEmpty() const;

	bool contains (const Eigen::Matrix<T,3,1> & point) const;
	void enlargeByEpsilon ();
	void enlargeBy(T value);

	T getArea () const;
	T getVolume() const;
	Eigen::Matrix<T, 3, 1> getCenter() const;
	Eigen::Matrix<T, 3, 1> getExtents() const;

	int getBiggestAxis () const;
	T getBound (int indx) const;
	
	Eigen::Matrix<T,3,1> getCorner (int indx) const;
	void getEdgePointsList (EdgePntsList & edgeList) const;
	
	BoundingBox3<T>& transform( const Eigen::Transform<T,3,Eigen::Affine> & transform );

	Eigen::Matrix<T, 3, 1> & min() { return min_; }
	Eigen::Matrix<T, 3, 1> & max() { return max_; }
	const Eigen::Matrix<T, 3, 1> & min() const { return min_; }
	const Eigen::Matrix<T, 3, 1> & max() const { return max_; }

	BoundingBox3<T>& operator=(const BoundingBox3<T> & other)
	{
		max_ = other.max_;
		min_ = other.min_;

		return *this;
	}

 private:
	Eigen::Matrix<T,3,1> max_;
	Eigen::Matrix<T,3,1> min_;

}; // end class BoundingBox3

// some useful typedefs
typedef BoundingBox3<float> BBox3f;
typedef BoundingBox3<double> BBox3d;

// ctor
template <class T>
BoundingBox3<T>::BoundingBox3 ()
	: min_(limits<T>::max(),limits<T>::max(),limits<T>::max()),
	  max_(-limits<T>::max(), -limits<T>::max(), -limits<T>::max())
{	
}

// ctor
template <class T>
BoundingBox3<T>::BoundingBox3 (const BoundingBox3 & b)
	: min_(b.min_),
	  max_(b.max_)
{	

}

// ctor
template <class T>
BoundingBox3<T>::BoundingBox3 (const Eigen::Matrix<T,3,1> & point)
	: min_(point),
	  max_(point)
{	
}

// ctor
template <class T>
BoundingBox3<T>::BoundingBox3 (T size)
	: min_(Eigen::Matrix<T,3,1>(-size, -size, -size)),
	  max_(Eigen::Matrix<T,3,1>(size, size, size))
{	
}

// ctor
template <class T>
BoundingBox3<T>::BoundingBox3 (Eigen::Matrix<T,3,1> minimum, Eigen::Matrix<T,3,1> maximum)
	: min_(minimum),
	  max_(maximum)
{	
}

// ctor
template <class T>
BoundingBox3<T>::BoundingBox3 (T x, T y, T z)
	: min_(Eigen::Matrix<T,3,1>(-x,-y,-z)),
	  max_(Eigen::Matrix<T,3,1>(x,y,z))
{	
}

// dtor
template <class T>
BoundingBox3<T>::~BoundingBox3 ()
{	
}

// asString
template <class T>
std::string BoundingBox3<T>::asString () const
{	
	std::string space(" ");
	std::string minX = ToString<T>(min_[0]);
	std::string minY = ToString<T>(min_[1]);
	std::string minZ = ToString<T>(min_[2]);

	std::string maxX = ToString<T>(max_[0]);
	std::string maxY = ToString<T>(max_[1]);
	std::string maxZ = ToString<T>(max_[2]);
	
	std::string box( "Bounding box: < low: " );
	box += minX + space + minY + space + minZ;
	box += "  high:  ";
	box += maxX + space + maxY + space + maxZ;
	box += " >";

	return box;
}

// contains
template <class T>
bool BoundingBox3<T>::contains (const Eigen::Matrix<T,3,1> & point) const
{	
	return (point[0] >= min_[0] && point[0] <= max_[0] &&
	        point[1] >= min_[1] && point[1] <= max_[1] &&
	        point[2] >= min_[2] && point[2] <= max_[2]);
}

// enlargeByEpsilon
template <class T>
void BoundingBox3<T>::enlargeByEpsilon ()
{	
	min_[0] -= limits<T>::epsilon();
	min_[1] -= limits<T>::epsilon();
	min_[2] -= limits<T>::epsilon();
	
	max_[0] += limits<T>::epsilon();
	max_[1] += limits<T>::epsilon();
	max_[2] += limits<T>::epsilon();
}

// enlargeBy
template <class T>
void BoundingBox3<T>::enlargeBy(T value)
{
	min_[0] -= value;
	min_[1] -= value;
	min_[2] -= value;

	max_[0] += value;
	max_[1] += value;
	max_[2] += value;
}


// getArea
template <class T>
T BoundingBox3<T>::getArea () const
{	
	Eigen::Matrix<T,3,1> w = getExtents();
	T ax = std::max<T>(w[0],0);
	T ay = std::max<T>(w[1],0);
	T az = std::max<T>(w[2],0);

	return 2 * ( ax * ay + ay * az + az * ax );
}

// getBiggestAxis
template <class T>
int BoundingBox3<T>::getBiggestAxis () const
{	
	int axis;

	Eigen::Matrix<T,3,1> extents = getExtents();
	if (extents[0] > extents[1] && extents[0] > extents[2])
		axis = 0;
    else if (extents[1] > extents[2])
		axis = 1;
    else
       axis = 2;

	return axis;
}

// getBound
template <class T>
T BoundingBox3<T>::getBound (int indx) const
{	
	switch ( indx )
	{
		case 0:
			return min_[0];
		case 1:
			return max_[0];
		case 2:
			return min_[1];
		case 3:
			return max_[1];
		case 4:
			return min_[2];
		case 5:
			return max_[2];
		default:
			return 0;
	}
}

// getCenter
template <class T>
Eigen::Matrix<T,3,1> BoundingBox3<T>::getCenter () const
{	
	Eigen::Matrix<T,3,1> center;

	center[0] = 0.5f * ( min_[0] + max_[0] );
	center[1] = 0.5f * ( min_[1] + max_[1] );
	center[2] = 0.5f * ( min_[2] + max_[2] );

	return center;
}

// getCorner
template <class T>
Eigen::Matrix<T,3,1> BoundingBox3<T>::getCorner (int indx) const
{	
	T x = (indx & 1 ) == 0 ? min_[0] : max_[0] ;
	T y = (indx & 2 ) == 0 ? min_[1] : max_[1] ;
	T z = (indx & 4 ) == 0 ? min_[2] : max_[2] ;
	
	return Eigen::Matrix<T,3,1>(x,y,z);
}

// getEdgePointsList
template <class T>
void BoundingBox3<T>::getEdgePointsList (EdgePntsList & edgeList) const
{	
	// face 1
	EdgePnts e1;
	e1.first = 0;
	e1.second = 1;
	edgeList.push_back(e1);

	EdgePnts e2;
	e2.first = 2;
	e2.second = 3;
	edgeList.push_back(e2);

	EdgePnts e3;
	e3.first = 0;
	e3.second = 2;
	edgeList.push_back(e3);

	EdgePnts e4;
	e4.first = 1;
	e4.second = 3;
	edgeList.push_back(e4);

	// face 2
	EdgePnts e5;
	e5.first = 4;
	e5.second = 5;
	edgeList.push_back(e5);

	EdgePnts e6;
	e6.first = 6;
	e6.second = 7;
	edgeList.push_back(e6);

	EdgePnts e7;
	e7.first = 4;
	e7.second = 6;
	edgeList.push_back(e7);

	EdgePnts e8;
	e8.first = 5;
	e8.second = 7;
	edgeList.push_back(e8);

	// last set of 4
	EdgePnts e9;
	e9.first = 0;
	e9.second = 4;
	edgeList.push_back(e9);

	EdgePnts e10;
	e10.first = 2;
	e10.second = 6;
	edgeList.push_back(e10);

	EdgePnts e11;
	e11.first = 1;
	e11.second = 5;
	edgeList.push_back(e11);

	EdgePnts e12;
	e12.first = 3;
	e12.second = 7;
	edgeList.push_back(e12);
}

// getExtents
template <class T>
Eigen::Matrix<T,3,1> BoundingBox3<T>::getExtents () const
{	
	return Eigen::Matrix<T,3,1>( max_ - min_ );
}

// getVolume
template <class T>
T BoundingBox3<T>::getVolume () const
{	
	Eigen::Matrix<T,3,1> w = getExtents();
	T ax = std::max<T>(w[0],0);
	T ay = std::max<T>(w[1],0);
	T az = std::max<T>(w[2],0);

	return ax * ay * az;
}

// include
template <class T>
void BoundingBox3<T>::include (const Eigen::Matrix<T,3,1> & point)
{	

	if( point != Eigen::Matrix<T,3,1>(0.0, 0.0, 0.0) )
	{
		 if (point[0] < min_[0])
                min_[0] = point[0];
         if (point[0] > max_[0])
               max_[0] = point[0];
         if (point[1] < min_[1])
                min_[1] = point[1];
         if (point[1] > max_[1])
                max_[1] = point[1];
         if (point[2] < min_[2])
               min_[2] = point[2];
         if (point[2] > max_[2])
                max_[2] = point[2];
	}
}

// include
template <class T>
void BoundingBox3<T>::include (const BoundingBox3<T> & box)
{	
	if( !box.isEmpty() )
	{
		 if (box.min_[0] < min_[0])
                min_[0] = box.min_[0];
         if (box.max_[0] > max_[0])
                max_[0] = box.max_[0];
         if (box.min_[1] < min_[1])
                min_[1] = box.min_[1];
         if (box.max_[1] > max_[1])
                max_[1] = box.max_[1];
         if (box.min_[2] < min_[2])
                min_[2] = box.min_[2];
         if (box.max_[2] > max_[2])
                max_[2] = box.max_[2];
	}
	else
	{
		LOG(CRITICAL) << "Invalid bounding box input";
	}
}

// intersect
template <class T>
bool BoundingBox3<T>::intersect (const Ray3 <T> & ray,
								 T * hit0, 
								 T * hit1) const
{	
	T t0 = ray.tMin;
	T t1 = ray.tMax;

	for (int i = 0; i < 3; ++i) 
	{
		// Update interval for _i_th bounding box slab
		//T val = (ray.dir[i] == 0.0f) ? Math<T>::EPSILON : ray.dir[i];
		//T invRayDir = 1.f / val;
		T invRayDir = 1.f /ray.dir[i];  // PBRT says ok to divide by 0!
		T tNear = (min_[i] - ray.origin[i]) * invRayDir;
		T tFar  = (max_[i] - ray.origin[i]) * invRayDir;

		// Update parametric interval from slab intersection 
		if (tNear > tFar) std::swap(tNear, tFar);
		t0 = tNear > t0 ? tNear : t0;
		t1 = tFar  < t1 ? tFar  : t1;
		if (t0 > t1) return false;
	}
	if (hit0) 
		*hit0 = t0;
	if (hit1)
		*hit1 = t1;

	return true;
}

// intersects
template <class T>
bool BoundingBox3<T>::intersects (const BoundingBox3 & box) const
{	
	bool x = (max_[0] >= box.min_[0]) && (min_[0] <= box.max_[0]);
	bool y = (max_[1] >= box.min_[1]) && (min_[1] <= box.max_[1]);
	bool z = (max_[2] >= box.min_[2]) && (min_[2] <= box.max_[2]);

	return (x && y && z);
}

// isEmpty
template <class T>
bool BoundingBox3<T>::isEmpty () const
{	
	return ( max_[0] < min_[0]) || (max_[1] < min_[1]) || (max_[2] < min_[2] );
}

// setEmpty
template <class T>
void BoundingBox3<T>::setEmpty() 
{
	min_ = Eigen::Matrix<T, 3, 1>(limits<T>::max(), limits<T>::max(), limits<T>::max());
	max_ = Eigen::Matrix<T, 3, 1>(limits<T>::min(), limits<T>::min(), limits<T>::min());
}

// transform
template <class T>
BoundingBox3<T>& BoundingBox3<T>::transform (const Eigen::Transform<T,3,Eigen::Affine> & transform) 
{	
	min_ = transform * min_;
	max_ = transform * max_;

	return *this;
}

