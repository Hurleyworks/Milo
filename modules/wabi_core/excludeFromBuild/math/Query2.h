// This header file was auto-generated by ClassMate++
// Created: 29 Jul 2009 11:33:13 pm
// Copyright (c) 2009, HurleyWorks

// modified version of 
// Geometric Tools, LLC
// Copyright (c) 1998-2010
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt

#pragma once

template <typename T>
class Query2 : public Query
{

 public:
    // The base class handles floating-point queries.
    Query2 (int numVertices, const Eigen::Matrix<T,2,1>* vertices);
    virtual ~Query2 ();

    // Run-time type information.
    virtual Query::Type getType () const;

    // Member access.
    inline int getNumVertices () const;
    inline const Eigen::Matrix<T,2,1>* getVertices () const;

    // Queries about the relation of a point to various geometric objects.

    // Returns:
    //   +1, on right of line
    //   -1, on left of line
    //    0, on the line
    virtual int toLine (int i, int v0, int v1) const;
    virtual int toLine (const Eigen::Matrix<T,2,1>& test, int v0, int v1) const;

    // Returns:
    //   +1, outside triangle
    //   -1, inside triangle
    //    0, on triangle
    virtual int toTriangle (int i, int v0, int v1, int v2) const;
    virtual int toTriangle (const Eigen::Matrix<T,2,1>& test, int v0, int v1, int v2) const;

    // Returns:
    //   +1, outside circumcircle of triangle
    //   -1, inside circumcircle of triangle
    //    0, on circumcircle of triangle
    virtual int toCircumcircle (int i, int v0, int v1, int v2) const;
    virtual int toCircumcircle (const Eigen::Matrix<T,2,1>& test, int v0, int v1,int v2) const;

    // Helper functions.
    static T dot (T x0, T y0, T x1, T y1);
    static T det2 (T x0, T y0, T x1, T y1);
    static T det3 (T x0, T y0, T z0, T x1, T y1, T z1, T x2, T y2, T z2);

 protected:
    // Input points.
    int mNumVertices;
    const Eigen::Matrix<T,2,1>* mVertices;
};


template <typename T>
Query2<T>::Query2 (int numVertices, const Eigen::Matrix<T,2,1>* vertices)
    : mNumVertices(numVertices), 
	  mVertices(vertices)
{
	// Invalid inputs
    debug_assert(mNumVertices > 0 && mVertices);
}

template <typename T>
Query2<T>::~Query2 ()
{
}

template <typename T>
Query::Type Query2<T>::getType () const
{
    return Query::QT_REAL;
}

template <typename T>
inline int Query2<T>::getNumVertices () const
{
    return mNumVertices;
}

template <typename T>
inline const Eigen::Matrix<T,2,1>* Query2<T>::getVertices () const
{
    return mVertices;
}

template <typename T>
int Query2<T>::toLine (int i, int v0, int v1) const
{
    return toLine(mVertices[i], v0, v1);
}

template <typename T>
int Query2<T>::toLine (const Eigen::Matrix<T,2,1>& test, int v0, int v1) const
{
    bool positive = sort(v0, v1);

    const Eigen::Matrix<T,2,1>& vec0 = mVertices[v0];
    const Eigen::Matrix<T,2,1>& vec1 = mVertices[v1];

    T x0 = test[0] - vec0[0];
    T y0 = test[1] - vec0[1];
    T x1 = vec1[0] - vec0[0];
    T y1 = vec1[1] - vec0[1];

    T det = det2(x0, y0, x1, y1);
    if (!positive)
    {
        det = -det;
    }

    return (det > (T)0 ? +1 : (det < (T)0 ? -1 : 0));
}

template <typename T>
int Query2<T>::toTriangle (int i, int v0, int v1, int v2) const
{
    return toTriangle(mVertices[i], v0, v1, v2);
}

template <typename T>
int Query2<T>::toTriangle (const Eigen::Matrix<T,2,1>& test, int v0, int v1,int v2) const
{
    int sign0 = toLine(test, v1, v2);
    if (sign0 > 0)
    {
        return +1;
    }

    int sign1 = toLine(test, v0, v2);
    if (sign1 < 0)
    {
        return +1;
    }

    int sign2 = toLine(test, v0, v1);
    if (sign2 > 0)
    {
        return +1;
    }

    return ((sign0 && sign1 && sign2) ? -1 : 0);
}

template <typename T>
int Query2<T>::toCircumcircle (int i, int v0, int v1, int v2) const
{
    return toCircumcircle(mVertices[i], v0, v1, v2);
}

template <typename T>
int Query2<T>::toCircumcircle (const Eigen::Matrix<T,2,1>& test, int v0, int v1, int v2) const
{
    bool positive = sort(v0, v1, v2);

    const Eigen::Matrix<T,2,1>& vec0 = mVertices[v0];
    const Eigen::Matrix<T,2,1>& vec1 = mVertices[v1];
    const Eigen::Matrix<T,2,1>& vec2 = mVertices[v2];

    T s0x = vec0[0] + test[0];
    T d0x = vec0[0] - test[0];
    T s0y = vec0[1] + test[1];
    T d0y = vec0[1] - test[1];
    T s1x = vec1[0] + test[0];
    T d1x = vec1[0] - test[0];
    T s1y = vec1[1] + test[1];
    T d1y = vec1[1] - test[1];
    T s2x = vec2[0] + test[0];
    T d2x = vec2[0] - test[0];
    T s2y = vec2[1] + test[1];
    T d2y = vec2[1] - test[1];
    T z0 = s0x*d0x + s0y*d0y;
    T z1 = s1x*d1x + s1y*d1y;
    T z2 = s2x*d2x + s2y*d2y;

    T det = det3(d0x, d0y, z0, d1x, d1y, z1, d2x, d2y, z2);
    if (!positive)
    {
        det = -det;
    }

    return (det < (T)0 ? 1 : (det > (T)0 ? -1 : 0));
}

template <typename T>
T Query2<T>::dot (T x0, T y0, T x1, T y1)
{
    return x0*x1 + y0*y1;
}

template <typename T>
T Query2<T>::det2 (T x0, T y0, T x1, T y1)
{
    return x0*y1 - x1*y0;
}

template <typename T>
T Query2<T>::det3 (T x0, T y0, T z0, T x1, T y1,T z1, T x2, T y2, T z2)
{
    T c00 = y1*z2 - y2*z1;
    T c01 = y2*z0 - y0*z2;
    T c02 = y0*z1 - y1*z0;
    return x0*c00 + x1*c01 + x2*c02;
}

typedef Query2<float> Query2f;
typedef Query2<double> Query2d;