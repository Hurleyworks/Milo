// This source file was auto-generated by ClassMate++
// Created: 19 Jul 2010 2:59:18 pm
// Copyright (c) 2010, HurleyWorks

// modified version of 
// Geometric Tools, LLC
// Copyright (c) 1998-2010
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt

// ctor
template <typename T>
Seg2Tri2Intersect<T>::Seg2Tri2Intersect (const Segment2 < T > & segment,
                                        const Triangle2 < T > & triangle)
	: mSegment(&segment),
	  mTriangle(&triangle)
{	
}

// dtor
template <typename T>
Seg2Tri2Intersect<T>::~Seg2Tri2Intersect ()
{	
}

// find
template <typename T>
bool Seg2Tri2Intersect<T>::find ()
{	

	T dist[3];
    int sign[3], positive, negative, zero;
    Line2Tri2Intersect<T>::TriangleLineRelations(mSegment->center,
												 mSegment->direction, *mTriangle, 
												 dist, sign, positive, negative, zero);

    if (positive == 3 || negative == 3)
    {
        // No intersections.
        mQuantity = 0;
        intersectionType_ = IT_EMPTY;
    }
    else
    {
        T param[2];
        Line2Tri2Intersect<T>::getInterval(mSegment->center, mSegment->direction, *mTriangle, dist, sign, param);

        Intersector1<T> intr(param[0], param[1], -mSegment->extent, +mSegment->extent);

        intr.find();

        mQuantity = intr.getNumIntersections();
        if (mQuantity == 2)
        {
            // Segment intersection.
            intersectionType_ = IT_SEGMENT;
            mPoint[0] = mSegment->center +
                intr.getIntersection(0)*mSegment->direction;
            mPoint[1] = mSegment->center +
                intr.getIntersection(1)*mSegment->direction;
        }
        else if (mQuantity == 1)
        {
            // Point intersection.
            intersectionType_ = IT_POINT;
            mPoint[0] = mSegment->center +
                intr.getIntersection(0)*mSegment->direction;
        }
        else
        {
            // No intersections.
            intersectionType_ = IT_EMPTY;
        }
    }

    return intersectionType_ != IT_EMPTY;
}

// getPoint
template <typename T>
const Eigen::Matrix<T,2,1> & Seg2Tri2Intersect<T>::getPoint (int i) const
{	
	debug_assert( i >= 0  && i < 2 );

	return mPoint[i];	
}

// test
template <typename T>
bool Seg2Tri2Intersect<T>::test ()
{	
	T dist[3];
    int sign[3], positive, negative, zero;
    Line2Tri2Intersect<T>::TriangleLineRelations(mSegment->center,
													mSegment->direction,
													*mTriangle, dist, sign, 
													positive, negative,zero);

    if (positive == 3 || negative == 3)
    {
        intersectionType_ = IT_EMPTY;
    }
    else
    {
        T param[2];
        Line2Tri2Intersect<T>::getInterval(mSegment->center,
											  mSegment->direction, 
											  *mTriangle, dist, sign, param);

        Intersector1<T> intr(param[0], param[1], mSegment->extent, +mSegment->extent);

        intr.find();

        mQuantity = intr.getNumIntersections();
        if (mQuantity == 2)
        {
            intersectionType_ = IT_SEGMENT;
        }
        else if (mQuantity == 1)
        {
            intersectionType_ = IT_POINT;
        }
        else
        {
            intersectionType_ = IT_EMPTY;
        }
    }

    return intersectionType_ != IT_EMPTY;
}

// Explicit instantiation.
template 
class Seg2Tri2Intersect<float>;

template 
class Seg2Tri2Intersect<double>;


