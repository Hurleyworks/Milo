// This source file was auto-generated by ClassMate++
// Created: 19 Jul 2010 2:59:18 pm
// Copyright (c) 2010, HurleyWorks

// modified version of 
// Geometric Tools, LLC
// Copyright (c) 1998-2010
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt


template <typename T>
Seg2Seg2Intersect<T>::Seg2Seg2Intersect (const Segment2<T>& segment0, const Segment2<T>& segment1)
    : mSegment0(&segment0),
	  mSegment1(&segment1)
{
}

template <typename T>
bool Seg2Seg2Intersect<T>::test ()
{
    Eigen::Matrix<T,2,1> diff;
    T parameter[2];
    intersectionType_ = classify(parameter, &diff,0);

    if (intersectionType_ == IT_POINT)
    {
        // Test whether the line-line intersection is on the segments.
        if (Math<T>::FAbs(parameter[0]) <= mSegment0->extent
			 &&  Math<T>::FAbs(parameter[1]) <= mSegment1->extent)
        {
            mQuantity = 1;
        }
        else
        {
            mQuantity = 0;
            intersectionType_ = IT_EMPTY;
        }
    }
    else if (intersectionType_ == IT_SEGMENT)
    {
        mQuantity = INT_MAX;
    }
    else
    {
        mQuantity = 0;
    }

    return intersectionType_ != IT_EMPTY;
}

template <typename T>
bool Seg2Seg2Intersect<T>::find ()
{
    Eigen::Matrix<T,2,1> diff;
    T parameter[2];
    intersectionType_ = classify(parameter, &diff, 0);

    if (intersectionType_ == IT_POINT)
    {
        // Test whether the line-line intersection is on the segments.
        if (Math<T>::FAbs(parameter[0]) <= mSegment0->extent
			&&  Math<T>::FAbs(parameter[1]) <= mSegment1->extent)
        {
            mQuantity = 1;
            mPoint = mSegment0->center + parameter[0]*mSegment0->direction;
        }
        else
        {
            mQuantity = 0;
            intersectionType_ = IT_EMPTY;
        }
    }
    else if (intersectionType_ == IT_SEGMENT)
    {
        mQuantity = INT_MAX;
    }
    else
    {
        mQuantity = 0;
    }

    return intersectionType_ != IT_EMPTY;
}

template <typename T>
int Seg2Seg2Intersect<T>::classify (T* s, Eigen::Matrix<T,2,1> * diff, Eigen::Matrix<T,2,1> * diffN)
{
	// The intersection of two lines is a solution to P0+s0*D0 = P1+s1*D1.
    // Rewrite this as s0*D0 - s1*D1 = P1 - P0 = Q.  If D0.Dot(Perp(D1)) = 0,
    // the lines are parallel.  Additionally, if Q.Dot(Perp(D1)) = 0, the
    // lines are the same.  If D0.Dot(Perp(D1)) is not zero, then
    //   s0 = Q.Dot(Perp(D1))/D0.Dot(Perp(D1))
    // produces the point of intersection.  Also,
    //   s1 = Q.Dot(Perp(D0))/D0.Dot(Perp(D1))

    Eigen::Matrix<T,2,1> originDiff = mSegment1->center - mSegment0->center;
    if (diff)
    {
        *diff = originDiff;
    }

    T D0DotPerpD1 = dotPerp(mSegment0->direction, mSegment1->direction);
    if (Math<T>::FAbs(D0DotPerpD1) > Math<T>::ZERO_TOLERANCE)
    {
        // Lines intersect in a single point.
        if (s)
        {
            T invD0DotPerpD1 = ((T)1)/D0DotPerpD1;
            T diffDotPerpD0 = dotPerp(originDiff, mSegment0->direction);
            T diffDotPerpD1 = dotPerp(originDiff, mSegment1->direction);
            s[0] = diffDotPerpD1*invD0DotPerpD1;
            s[1] = diffDotPerpD0*invD0DotPerpD1;
        }
        return IT_POINT;
    }

    // Lines are parallel.
    originDiff.normalize();
    if (diffN)
    {
        *diffN = originDiff;
    }

    T diffNDotPerpD1 = dotPerp(originDiff, mSegment1->direction);
    if (Math<T>::FAbs(diffNDotPerpD1) <= Math<T>::ZERO_TOLERANCE)
    {
        // Lines are colinear.
        return IT_SEGMENT;
    }

    // Lines are parallel, but distinct.
    return IT_EMPTY;
}

// Explicit instantiation.
template 
class Seg2Seg2Intersect<float>;

template 
class Seg2Seg2Intersect<double>;



