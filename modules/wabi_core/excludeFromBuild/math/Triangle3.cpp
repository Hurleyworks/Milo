// This source file was auto-generated by ClassMate++
// Created: 19 Jul 2010 2:59:18 pm
// Copyright (c) 2010, HurleyWorks

// ctor
template<class T>
Triangle3<T>::Triangle3 ()
{
}

// ctor
template<class T>
Triangle3<T>::Triangle3 (const Triangle3<T>& other)
{	
	v_[0] = other.v_[0];
	v_[1] = other.v_[1];
	v_[2] = other.v_[2];
	bounds = other.bounds;
	e1 = other.e1;;
    e2 = other.e2;
	e3 = other.e3;
    n = other.n;
	c = other.c;
}

// ctor
template<class T>
Triangle3<T>::Triangle3 (const Eigen::Matrix<T,3,1> pnts[3])
{	
	c = Matrix<T,3,1>(0.0f, 0.0f, 0.0f );
	for( int i = 0; i < 3; i++ )
	{
		v_[i] = pnts[i];
		c += v_[i];
	}
	c /= 3;

	bounds.include(v_[0]);
	bounds.include(v_[1]);
	bounds.include(v_[2]);

	e1 = v_[1] - v_[0];
    e2 = v_[2] - v_[0];
	e3 = v_[2] - v_[1];

	// don't normalize!
    n = e1.cross(e2);
}

// ctor
template<class T>
Triangle3<T>::Triangle3 (const Eigen::Matrix<T,3,1> & v0,
					     const Eigen::Matrix<T,3,1> & v1, 
                         const Eigen::Matrix<T,3,1> & v2)
{
	c = Matrix<T,3,1>(0.0f, 0.0f, 0.0f );
	v_[0] = v0;
	v_[1] = v1;
	v_[2] = v2;

	c += v0;
	c += v1;
	c += v2;
	c /= 3;

	bounds.include(v_[0]);
	bounds.include(v_[1]);
	bounds.include(v_[2]);

	e1 = v_[1] - v_[0];
    e2 = v_[2] - v_[0];
	e3 = v_[2] - v_[1];

	// don't normalize!
    n = e1.cross(e2);
}

// dtor
template<class T>
Triangle3<T>::~Triangle3 ()
{	
}

template<class T>
Triangle3<T>& Triangle3<T>::operator=( const Triangle3<T>& other )
{	
	v_[0] = other.v_[0];
	v_[1] = other.v_[1];
	v_[2] = other.v_[2];
	bounds = other.bounds;
	e1 = other.e1;;
    e2 = other.e2;
	e3 = other.e3;
    n = other.n;
	c = other.c;

	return *this;
}

// getBound
template<class T>
T Triangle3<T>::getBound( int index ) const
{	
	return bounds.getBound(index);
}

// getArea
template<class T>
T Triangle3<T>::getArea() const
{
	// herons formula
	T a = e1.norm();
	T b = e2.norm();
	T c = e3.norm();

	T perimeter = a + b + c;
	T s = perimeter / 2;

	return Math<T>::Sqrt(s * (s - a) * (s - b) * (s - c));
}

// getVertexPos
template<class T>
Eigen::Matrix <T, 3, 1> Triangle3<T>::getVertexPos(short index)
{
	if (index >= 0 && index < 3)
		return v_[index];
	else
	{
		LOG(CRITICAL) << "Invalid index";
		debug_assert(0);
		return Eigen::Matrix <T, 3, 1>(0, 0, 0);
	}
}

// getVertexPos
template<class T>
const Eigen::Matrix <T, 3, 1> Triangle3<T>::getVertexPos(short index) const
{
	if (index >= 0 && index < 3)
		return v_[index];
	else
	{
		LOG(CRITICAL) << "Invalid index";
		debug_assert(0);
		return Eigen::Matrix <T, 3, 1>(0, 0, 0);
	}
}

template<class T>
bool Triangle3<T>::findIntersect(Ray3<T> & ray)
{
	Eigen::Matrix<T, 3, 1> diff = ray.origin - v_[0];

	// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
	// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
	//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
	//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
	//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)

	T DdN = ray.dir.dot(n);
	T sign;
	if (DdN > Math<T>::ZERO_TOLERANCE)
	{
		sign = (T)1;
	}
	else if (DdN < -Math<T>::ZERO_TOLERANCE)
	{
		sign = (T)-1;
		DdN = -DdN;
	}
	else
	{
		// Ray and triangle are parallel, call it a "no intersection"
		// even if the ray does intersect.
		return false;
	}

	T DdQxE2 = sign*  ray.dir.dot(diff.cross(e2));
	if (DdQxE2 >= (T)0)
	{
		T DdE1xQ = sign* ray.dir.dot(e1.cross(diff));
		if (DdE1xQ >= (T)0)
		{
			if (DdQxE2 + DdE1xQ <= DdN)
			{
				// Line intersects triangle, check if ray does.
				T QdN = -sign* diff.dot(n);
				if (QdN >= (T)0)
				{
					// Ray intersects triangle.
					T inv = ((T)1) / DdN;
					ray.distToHit = QdN*inv;
					ray.bary1 = DdQxE2*inv;
					ray.bary2 = DdE1xQ*inv;
					ray.bary0 = (T)1 - ray.bary1 - ray.bary2;

					return true;
				}
				// else: t < 0, no intersection
			}
			// else: b1+b2 > 1, no intersection
		}
		// else: b2 < 0, no intersection
	}

	// else: b1 < 0, no intersection
	return false;
}

template<class T>
bool Triangle3<T>::testIntersect(Ray3<T> & ray)
{
	Eigen::Matrix<T, 3, 1> diff = ray.origin - v_[0];

	// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
	// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
	//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
	//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
	//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
	//T DdN = ray.dir.Dot(normal);
	T DdN = ray.dir.dot(n);
	T sign;
	if (DdN > Math<T>::ZERO_TOLERANCE)
	{
		sign = (T)1;
	}
	else if (DdN < -Math<T>::ZERO_TOLERANCE)
	{
		sign = (T)-1;
		DdN = -DdN;
	}
	else
	{
		// Ray and triangle are parallel, call it a "no intersection"
		// even if the ray does intersect.
		return false;
	}

	//T DdQxE2 = sign*ray.dir.Dot(diff.Cross(edge2));
	T DdQxE2 = sign* ray.dir.dot(diff.cross(e2));
	if (DdQxE2 >= (T)0)
	{
		//T DdE1xQ = sign*ray.dir.Dot(edge1.Cross(diff));
		T DdE1xQ = sign* ray.dir.dot(e1.cross(diff));
		if (DdE1xQ >= (T)0)
		{
			if (DdQxE2 + DdE1xQ <= DdN)
			{
				// Line intersects triangle, check if ray does.
				//T QdN = -sign*diff.Dot(normal);
				T QdN = -sign* diff.dot(n);
				if (QdN >= (T)0)
				{
					// Ray intersects triangle.
					return true;
				}
				// else: t < 0, no intersection
			}
			// else: b1+b2 > 1, no intersection
		}
		// else: b2 < 0, no intersection
	}
	// else: b1 < 0, no intersection

	return false;
}

template
class Triangle3<float>;

template
class Triangle3<double>;


