// This header file was auto-generated by ClassMate++
// Created: 6 Mar 2009 9:34:37 pm
// Copyright (c) 2009, HurleyWorks

// Geometric Tools, LLC
// Copyright (c) 1998-2010
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
//
// File Version: 5.0.0 (2010/01/01)

#pragma once

template <typename T>
class Triangle2
{

 public:
    // The triangle is represented as an array of three vertices:
    // V0, V1, and V2.

    // Construction and destruction.
    Triangle2 ();  // uninitialized
    ~Triangle2 ();

    Triangle2 (const Eigen::Matrix<T,2,1>& v0, const Eigen::Matrix<T,2,1>& v1,
			   const Eigen::Matrix<T,2,1>& v2);

    Triangle2 (const Eigen::Matrix<T,2,1> vertex[3]);

    // Distance from the point Q to the triangle.  TODO:  Move this
    // to the physics library distance code.
    T DistanceTo (const Eigen::Matrix<T,2,1>& q) const;

    Eigen::Matrix<T,2,1> v_[3];
};


template <typename T>
Triangle2<T>::Triangle2 ()
{
}

template <typename T>
Triangle2<T>::~Triangle2 ()
{
}

template <typename T>
Triangle2<T>::Triangle2 (const Eigen::Matrix<T,2,1>& v0,
						 const Eigen::Matrix<T,2,1>& v1, 
						 const Eigen::Matrix<T,2,1>& v2)
{
    v_[0] = v0;
    v_[1] = v1;
    v_[2] = v2;
}

template <typename T>
Triangle2<T>::Triangle2 (const Eigen::Matrix<T,2,1> vertex[3])
{
    for (int i = 0; i < 3; ++i)
    {
        v_[i] = vertex[i];
    }
}

template <typename T>
T Triangle2<T>::DistanceTo (const Eigen::Matrix<T,2,1>& q) const
{
    Eigen::Matrix<T,2,1> diff = v_[0] - q;
    Eigen::Matrix<T,2,1> edge0 = v_[1] - v_[0];
    Eigen::Matrix<T,2,1> edge1 = v_[2] - v_[0];
    T a00 = edge0.norm2();
    T a01 = edge0.dot(edge1);
    T a11 = edge1.norm2();
    T b0 = diff.dot(edge0);
    T b1 = diff.dot(edge1);
    T c = diff.norm2();
    T det = Math<T>::FAbs(a00*a11 - a01*a01);
    T s = a01*b1 - a11*b0;
    T t = a01*b0 - a00*b1;
    T sqrDistance;

    if (s + t <= det)
    {
        if (s < (T)0)
        {
            if (t < (T)0)  // region 4
            {
                if (b0 < (T)0)
                {
                    if (-b0 >= a00)
                    {
                        sqrDistance = a00 + ((T)2)*b0 + c;
                    }
                    else
                    {
                        sqrDistance = c - b0*b0/a00;
                    }
                }
                else
                {
                    if (b1 >= (T)0)
                    {
                        sqrDistance = c;
                    }
                    else if (-b1 >= a11)
                    {
                        sqrDistance = a11 + ((T)2)*b1 + c;
                    }
                    else
                    {
                        sqrDistance = c - b1*b1/a11;
                    }
                }
            }
            else  // region 3
            {
                if (b1 >= (T)0)
                {
                    sqrDistance = c;
                }
                else if (-b1 >= a11)
                {
                    sqrDistance = a11 + ((T)2)*b1 + c;
                }
                else
                {
                    sqrDistance = c - b1*b1/a11;
                }
            }
        }
        else if (t < (T)0)  // region 5
        {
            if (b0 >= (T)0)
            {
                sqrDistance = c;
            }
            else if (-b0 >= a00)
            {
                sqrDistance = a00 + ((T)2)*b0 + c;
            }
            else
            {
                sqrDistance = b0*s + c - b0*b0/a00;
            }
        }
        else  // region 0
        {
            // The minimum is at an interior point of the triangle.
            T invDet = ((T)1)/det;
            s *= invDet;
            t *= invDet;
            sqrDistance = s*(a00*s + a01*t + ((T)2)*b0) +
                t*(a01*s + a11*t + ((T)2)*b1) + c;
        }
    }
    else
    {
        T tmp0, tmp1, numer, denom;

        if (s < (T)0)  // region 2
        {
            tmp0 = a01 + b0;
            tmp1 = a11 + b1;
            if (tmp1 > tmp0)
            {
                numer = tmp1 - tmp0;
                denom = a00 - ((T)2)*a01 + a11;
                if (numer >= denom)
                {
                    sqrDistance = a00 + ((T)2)*b0 + c;
                }
                else
                {
                    s = numer/denom;
                    t = (T)1 - s;
                    sqrDistance = s*(a00*s + a01*t + ((T)2)*b0) +
                        t*(a01*s + a11*t + ((T)2)*b1) + c;
                }
            }
            else
            {
                if (tmp1 <= (T)0)
                {
                    sqrDistance = a11 + ((T)2)*b1 + c;
                }
                else if (b1 >= (T)0)
                {
                    sqrDistance = c;
                }
                else
                {
                    sqrDistance = c - b1*b1/a11;
                }
            }
        }
        else if (t < (T)0)  // region 6
        {
            tmp0 = a01 + b1;
            tmp1 = a00 + b0;
            if (tmp1 > tmp0)
            {
                numer = tmp1 - tmp0;
                denom = a00 - ((T)2)*a01 + a11;
                if (numer >= denom)
                {
                    t = (T)1;
                    s = (T)0;
                    sqrDistance = a11 + ((T)2)*b1 + c;
                }
                else
                {
                    t = numer/denom;
                    s = (T)1 - t;
                    sqrDistance = s*(a00*s + a01*t + ((T)2)*b0) +
                        t*(a01*s + a11*t + ((T)2)*b1) + c;
                }
            }
            else
            {
                if (tmp1 <= (T)0)
                {
                    sqrDistance = a00 + ((T)2)*b0 + c;
                }
                else if (b0 >= (T)0)
                {
                    sqrDistance = c;
                }
                else
                {
                    sqrDistance = c - b0*b0/a00;
                }
            }
        }
        else  // region 1
        {
            numer = a11 + b1 - a01 - b0;
            if (numer <= (T)0)
            {
                sqrDistance = a11 + ((T)2)*b1 + c;
            }
            else
            {
                denom = a00 - ((T)2)*a01 + a11;
                if (numer >= denom)
                {
                    sqrDistance = a00 + ((T)2)*b0 + c;
                }
                else
                {
                    s = numer/denom;
                    t = (T)1 - s;
                    sqrDistance = s*(a00*s + a01*t + ((T)2)*b0) +
                        t*(a01*s + a11*t + ((T)2)*b1) + c;
                }
            }
        }
    }

    return Math<T>::Sqrt(Math<T>::FAbs(sqrDistance));
}

typedef Triangle2<float> Triangle2f;
typedef Triangle2<double> Triangle2d;
