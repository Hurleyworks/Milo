// This header file was auto-generated by ClassMate++
// Created: 6 Mar 2009 9:34:37 pm
// Copyright (c) 2009, HurleyWorks

// Geometric Tools, LLC
// Copyright (c) 1998-2010
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
//
// File Version: 5.0.0 (2010/01/01)

#pragma once

template <typename T>
class Segment2
{

 public:
    // The segment is represented as (1-s)*p0+s*p1, where p0 and p1 are the
    // endpoints of the segment and 0 <= s <= 1.
    //
    // Some algorithms involving segments might prefer a centered
    // representation similar to how oriented bounding boxes are defined.
    // This representation is C+t*D, where C = (p0+p1)/2 is the center of
    // the segment, D = (p1-p0)/Length(p1-p0) is a unit-length direction
    // vector for the segment, and |t| <= e.  The value e = Length(p1-p0)/2
    // is the 'extent' (or radius or half-length) of the segment.
    
    // Construction and destruction.
    Segment2 ();  // uninitialized
    ~Segment2 ();

    // The constructor computes C, D, and E from p0 and p1.
    Segment2 (const Eigen::Matrix<T,2,1>& endPoint0, const Eigen::Matrix<T,2,1>& endPoint1);

    // The constructor computes p0 and p1 from C, D, and E.
    Segment2 (const Eigen::Matrix<T,2,1>& center, const Eigen::Matrix<T,2,1>& direction, T extent);

    // Call this function when you change p0 or p1.
    void computeCenterDirectionExtent ();

    // Call this function when you change C, D, or e.
    void computeEndPoints ();

    // End-point representation.
    Eigen::Matrix<T,2,1> p0, p1;

    // center-direction-extent representation.
    Eigen::Matrix<T,2,1> center;
    Eigen::Matrix<T,2,1> direction;
    T extent;
};

template <typename T>
Segment2<T>::Segment2 ()
{
}

template <typename T>
Segment2<T>::~Segment2 ()
{
}

template <typename T>
Segment2<T>::Segment2 (const Eigen::Matrix<T,2,1>& endPoint0, const Eigen::Matrix<T,2,1>& endPoint1)
    : p0(endPoint0),
	  p1(endPoint1)
{
    computeCenterDirectionExtent();
}

template <typename T>
Segment2<T>::Segment2 (const Eigen::Matrix<T,2,1>& center, const Eigen::Matrix<T,2,1>& direction, T extent)
    : center(center),
	  direction(direction),
	  extent(extent)
{
    computeEndPoints();
}

template <typename T>
void Segment2<T>::computeCenterDirectionExtent ()
{
    center = ((T)0.5)*(p0 + p1);
    direction = p1 - p0;
	extent = ((T)0.5)*normalizeVec2(direction);
}

template <typename T>
void Segment2<T>::computeEndPoints ()
{
    p0 = center - extent*direction;
    p1 = center + extent*direction;
}


typedef Segment2<float> Segment2f;
typedef Segment2<double> Segment2d;
