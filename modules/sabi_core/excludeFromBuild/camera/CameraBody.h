// This header file was auto-generated by ClassMate++
// Created: 14 Aug 2021 3:45:48 pm
// Copyright (c) 2021, HurleyWorks

#pragma once

using CameraHandle = std::shared_ptr<class CameraBody>;
using ViewportCameraPtr = std::shared_ptr<class CameraBody>;

class CameraBody
{
    // https://www.scratchapixel.com/lessons/3d-basic-rendering/3d-viewing-pinhole-camera/how-pinhole-camera-works-part-2
    // It is very important to remember that two parameters determine the angle of view : the focal length and the film size.
    // The angle of view changes when you change either one of these two parameters : the focal length or the film size.

    // For a fixed film size, changing the focal length will change the angle of view.
    // The longer the focal length, the narrower than angle of view. For a fixed focal length,
    // changing the film size will change the angle of view. The larger the film, the wider
    // the angle of view. If you wish to change the film size but keep the same angle of view,
    // you will need to adjust the focal length accordingly.

 public:
    CameraBody();
    ~CameraBody();

    bool hasSettingsChanged()
    {
        bool changed = false;

        if (eye != lastEye || target != lastTarget || worldUp != lastWorldUp)
        {
            changed = true;
        }
        else if (focalLength != lastFocalLength || aperture != lastAperture)
        {
            changed = true;
        }
        else if (pose.matrix() != lastPose.matrix())
        {
            changed = true;
        }
        else if (verticalFOVradians != lastVerticalFOVradians)
        {
            changed = true;
        }
        /* else if (sensor.pixelResolutionHasChanged())
         {
             changed = true;
         }*/

        // If changed, update the "last" variables
        if (changed)
        {
            lastEye = eye;
            lastTarget = target;
            lastWorldUp = worldUp;
            lastFocalLength = focalLength;
            lastAperture = aperture;
            lastPose = pose;
            lastVerticalFOVradians = verticalFOVradians;
            // sensor.setPixelResolutionHasChanged (false);
        }

        return changed;
    }

    float getFocalLength() const { return focalLength; }
    void setFocalLength (float length)
    {
        debug_assert (length > 0.0f);

        focalLength = length;
        float sensorHalfHeight = sensor.getSensorSize().y() / 2.0f;
        verticalFOVradians = 2 * std::atan (sensorHalfHeight / focalLength);
    }

    float getApeture() const { return aperture; }
    void setApeture (float aperture) { this->aperture = aperture; }

    void lookAt (const Eigen::Vector3f& eyePoint, const Eigen::Vector3f& target, const Eigen::Vector3f& up);
    void lookAt (const Eigen::Vector3f& eyePoint, const Eigen::Vector3f& target);
    void lookAt (const Eigen::Vector3f& eyePoint);

    wabi::Ray3f generateRay (uint32_t x, uint32_t y, bool transformed = true)
    {
        // FIXME aspect < 1.0f ?????

        float u = (2 * ((x + 0.5) * sensor.pixelSize().x()) - 1) * verticalFOVradians * sensor.getPixelAspectRatio();
        float v = (1 - 2 * ((y + 0.5) * sensor.pixelSize().y())) * verticalFOVradians;

        Eigen::Vector3f dir = Eigen::Vector3f (u, v, 1.0f).normalized();

        return wabi::Ray3<float> (pose.translation(), transformed ? pose.linear() * dir : dir);
    }

    // with jittering
    wabi::Ray3f generateRay (uint32_t x, uint32_t y, float jitterU, float jitterV, bool transformed = true)
    {
        // FIXME aspect < 1.0f ?????

        float u = (2 * ((x + jitterU) * sensor.pixelSize().x()) - 1) * verticalFOVradians * sensor.getPixelAspectRatio();
        float v = (1 - 2 * ((y + jitterV) * sensor.pixelSize().y())) * verticalFOVradians;

        Eigen::Vector3f dir = Eigen::Vector3f (u, v, 1.0f).normalized();

        return wabi::Ray3<float> (pose.translation(), transformed ? pose.linear() * dir : dir);
    }

    void rotateAroundTarget (const Eigen::Quaternionf& q);
    void zoom (float d);

    // trackball
    void startTracking() { lastPointOk = false; }
    void track (const Eigen::Vector2f& point2D);

  //  const OIIO::ImageBuf& getSensorHDRPixels() { return sensor.getHDRImage(); }
//const OIIO::ImageBuf& getSensorLDRPixels() { return sensor.getLDRImage(); }

    // OIIO::ImageBuf getSensorHDRPixels() { return sensor.getHDRImage(); }
    //  OIIO::ImageBuf getSensorLDRPixels() { return sensor.getLDRImage(); }

    CameraSensor* getSensor() { return &sensor; }

    void setPose (const Pose& pose) { this->pose = pose; }
    const Pose& getPose() const { return pose; }
    Pose& getPose() { return pose; }

    bool isDirty() const { return dirty; }
    void setDirty (bool state) { dirty = state; }

    float getVerticalFOVradians() { return verticalFOVradians; }

    const Eigen::Matrix4f& getViewMatrix() const
    {
        if (!viewMatrixCached)
            calcViewMatrix();
        return viewMatrix.matrix();
    }

    void setEyePoint (const Eigen::Vector3f& eyePoint, bool update = false)
    {
        eye = eyePoint;
    }

    void setTarget (const Eigen::Vector3f& newTarget)
    {
        target = newTarget;
    }

    Eigen::Vector3f& getEyePoint() { return eye; }
    const Eigen::Vector3f& getEyePoint() const { return eye; }
    const Eigen::Vector3f& getWorldUp() const { return worldUp; }
    const Eigen::Vector3f& getUp() const { return mV; }
    const Eigen::Vector3f& getRight() const { return mU; }
    const Eigen::Vector3f& getFoward() const { return forward; }
    const Eigen::Vector3f& getTarget() const { return target; }
    const Eigen::Vector3f& getViewDirection() const { return viewDirection; }
    const Eigen::Quaternionf& getOrientation() const { return orientation; }

    void panHorizontal (float distance);
    void panVertical (float distance);

    template <class Archive>
    void serialize (Archive& ar)
    {
        ar (CEREAL_NVP (focalLength), CEREAL_NVP (aperture), CEREAL_NVP (eye), CEREAL_NVP (target));
    }

    void setChangedSensorPixelRes (Eigen::Vector2i size) { sensorPixelRes = size; }
    const Eigen::Vector2i& getChangedSensorPixelRes() const { return sensorPixelRes; }
    void debugLog() const;

    void setViewportIndex (uint32_t index) { viewportIndex = index; }
    uint32_t getViewportIndex() const { return viewportIndex; }

 private:
    CameraSensor sensor;
    std::string name = "Perspective Camera";
    Pose pose;
    bool dirty = true;
    float verticalFOVradians = DEFAULT_FOV_DEGREES;
    float focalLength = 0.055f; // 55 mm lens
    float aperture = 0.0f;
    Eigen::Vector3f target = Eigen::Vector3f::Zero();
    uint32_t viewportIndex = 0;

    // trackball
    Eigen::Vector3f lastPoint3D = Eigen::Vector3f::Zero();
    bool lastPointOk = false;
    bool mapToSphere (const Eigen::Vector2f& p2, Eigen::Vector3f& v3);

    Eigen::Vector3f getPosition() { return pose.translation(); }

    Eigen::Vector3f eye = DEFAULT_CAMERA_POSIIION;
    Eigen::Vector3f viewDirection = Eigen::Vector3f::UnitZ();
    mutable Eigen::Vector3f forward = Eigen::Vector3f::UnitX();
    Eigen::Quaternionf orientation;
    Eigen::Vector3f worldUp = Eigen::Vector3f::UnitY();

    mutable Eigen::Vector3f mU; // Right vector
    mutable Eigen::Vector3f mV; // Readjust up-vector
    mutable Eigen::Vector3f mW; // Negative view direction

    mutable Eigen::Affine3f viewMatrix;
    mutable bool viewMatrixCached;
    mutable Matrix4f inverseModelViewMatrix;
    mutable bool inverseModelViewCached;

    Eigen::Vector3f lastEye = Eigen::Vector3f::Zero();
    Eigen::Vector3f lastTarget = Eigen::Vector3f::Zero();
    Eigen::Vector3f lastWorldUp = Eigen::Vector3f::UnitY();
    float lastFocalLength = 0.0f;
    float lastAperture = 0.0f;
    Pose lastPose;
    float lastVerticalFOVradians = 0.0f;

    Eigen::Vector2i sensorPixelRes = DEFAULT_DESKTOP_WINDOW_SIZE;

    void calcMatrices() const;
    virtual void calcViewMatrix() const;
    virtual void calcInverseView() const;
};
