This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
animation/AnimationBuilder.h
camera/CameraBody.cpp
camera/CameraBody.h
camera/CameraSensor.h
cgmodel/CgMaterial.h
cgmodel/cgModel.h
cgmodel/cgModelSurface.h
cgmodel/MeshOptions.h
io/AssetPathManager.h
io/GltfAnimationExporter.h
io/GLTFImporter.cpp
io/GLTFImporter.h
io/GLTFUtil.h
io/LWO3Layer.cpp
io/LWO3Layer.h
io/LWO3Material.cpp
io/LWO3Material.h
io/LWO3MaterialManager.cpp
io/LWO3MaterialManager.h
io/LWO3Navigator.h
io/LWO3NodeData.h
io/LWO3NodeGraph.cpp
io/LWO3NodeGraph.h
io/LWO3Reader.cpp
io/LWO3Reader.h
io/LWO3Surface.cpp
io/LWO3Surface.h
io/LWO3ToCgModelConverter.cpp
io/LWO3ToCgModelConverter.h
io/LWO3Tree.cpp
io/LWO3Tree.h
lwo3/LWO3Chunk.h
lwo3/LWO3Defs.h
lwo3/LWO3Element.h
lwo3/LWO3Form.h
lwo3/LWO3Visitor.h
scene/RayIntersectionInfo.h
scene/Renderable.h
scene/RenderableData.h
scene/RenderableDesc.h
scene/RenderableState.h
scene/SceneOptions.h
scene/SpaceTime.cpp
scene/SpaceTime.h
scene/WorldComposite.cpp
scene/WorldComposite.h
scene/WorldItem.cpp
scene/WorldItem.h
tools/LoadStrategy.h
tools/MeshOps.cpp
tools/MeshOps.h
tools/NormalizedClump.cpp
tools/NormalizedClump.h
tools/RadialFlower.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="animation/AnimationBuilder.h">
class AnimationBuilder
{
 public:
    using EasingFunction = std::function<float (float)>;

    AnimationBuilder (const std::string& targetNode) :
        targetNode_ (targetNode) {}

    // Add a keyframe with multiple properties
    AnimationBuilder& addKeyframe (float time,
                                   const Eigen::Vector3f& translation = Eigen::Vector3f::Zero(),
                                   const Eigen::Quaternionf& rotation = Eigen::Quaternionf::Identity(),
                                   const Eigen::Vector3f& scale = Eigen::Vector3f::Ones())
    {
        KeyFrame keyframe;
        keyframe.time = time;
        keyframe.translation = translation;
        keyframe.rotation = rotation;
        keyframe.scale = scale;
        keyframes_.push_back (keyframe);
        return *this;
    }

    // Set duration
    AnimationBuilder& setDuration (float duration)
    {
        duration_ = duration;
        return *this;
    }

    // Set easing function
    AnimationBuilder& setEasing (EasingFunction easingFunc)
    {
        easingFunc_ = easingFunc;
        return *this;
    }

    // Set looping
    AnimationBuilder& setLooping (bool loop)
    {
        loop_ = loop;
        return *this;
    }

    // Build the AnimationChannels
    std::vector<AnimationChannel> build()
    {
        std::vector<AnimationChannel> channels;

        if (keyframes_.empty())
        {
            LOG (WARNING) << "No keyframes defined for animation on node: " << targetNode_;
            return channels;
        }

        std::map<fastgltf::AnimationPath, AnimationChannel> channelMap;

        // Initialize channels for each path
        channelMap[fastgltf::AnimationPath::Translation].path = fastgltf::AnimationPath::Translation;
        channelMap[fastgltf::AnimationPath::Rotation].path = fastgltf::AnimationPath::Rotation;
        channelMap[fastgltf::AnimationPath::Scale].path = fastgltf::AnimationPath::Scale;

        float lastKeyframeTime = 0.0f;

        for (auto& keyframe : keyframes_)
        {
            keyframe.time *= duration_;
            lastKeyframeTime = std::max (lastKeyframeTime, keyframe.time);

            // Apply easing if set
            if (easingFunc_)
            {
                keyframe.time = easingFunc_ (keyframe.time / duration_) * duration_;
            }

            channelMap[fastgltf::AnimationPath::Translation].keyFrames.push_back (keyframe);
            channelMap[fastgltf::AnimationPath::Rotation].keyFrames.push_back (keyframe);
            channelMap[fastgltf::AnimationPath::Scale].keyFrames.push_back (keyframe);
        }

        // Add looping keyframe if needed
        if (loop_ && !keyframes_.empty())
        {
            KeyFrame loopKeyframe = keyframes_.front();
            loopKeyframe.time = lastKeyframeTime + 0.001f; // Slightly after the last keyframe

            channelMap[fastgltf::AnimationPath::Translation].keyFrames.push_back (loopKeyframe);
            channelMap[fastgltf::AnimationPath::Rotation].keyFrames.push_back (loopKeyframe);
            channelMap[fastgltf::AnimationPath::Scale].keyFrames.push_back (loopKeyframe);
        }

        // Finalize channels
        for (auto& [path, channel] : channelMap)
        {
            channel.targetNode = targetNode_;
            channels.push_back (channel);
        }

        return channels;
    }

 private:
    std::string targetNode_;
    std::vector<KeyFrame> keyframes_;
    float duration_ = 5.0f;
    EasingFunction easingFunc_ = nullptr;
    bool loop_ = true;
};

// Helper function for linear interpolation (default easing)
inline float linearEase (float t)
{
    return t;
}
</file>

<file path="camera/CameraBody.cpp">
using namespace Eigen;

CameraBody::CameraBody()
{
    pose.setIdentity();
}

CameraBody::~CameraBody()
{
}

void CameraBody::lookAt (const Eigen::Vector3f& eyePoint, const Eigen::Vector3f& target, const Eigen::Vector3f& up)
{
    pose.translation() = eyePoint;
    this->target = target;
    Eigen::Vector3f f = (target - eyePoint).normalized();

    eye = eyePoint;
    viewDirection = f;

   // mace::vecStr3f (f, DBUG, "View direction");

    Matrix3f camAxes;
    camAxes.col (2) = -f;
    camAxes.col (0) = worldUp.cross (camAxes.col (2)).normalized();
    camAxes.col (1) = camAxes.col (2).cross (camAxes.col (0)).normalized();
    orientation = Quaternionf (camAxes);

    forward = -(orientation * Vector3f::UnitZ());

    pose.linear() = -orientation.toRotationMatrix();

    calcViewMatrix(); // Call this to update mU and mV
    viewMatrixCached = true;
}

void CameraBody::lookAt (const Eigen::Vector3f& eyePoint, const Eigen::Vector3f& target)
{
   
    this->target = target;
    eye = eyePoint;

    pose.translation() = eye;

    Eigen::Vector3f f = (target - eyePoint).normalized();
    viewDirection = f;

    /// Check for degeneracies.If the upDir and targetDir are parallel
    // or opposite, then compute a new, arbitrary up direction that is
    // not parallel or opposite to the targetDir.
    Vector3f upDir = worldUp;

    if (upDir.cross (f).squaredNorm() == 0)
    {
        upDir = f.cross (Vector3f::UnitX());
        if (upDir.squaredNorm() == 0)
            upDir = f.cross (Vector3f::UnitZ());

        upDir *= -1.0f; // to match Cinder
    }

    Matrix3f camAxes;
    camAxes.col (2) = -f;
    camAxes.col (0) = upDir.cross (camAxes.col (2)).normalized();
    camAxes.col (1) = camAxes.col (2).cross (camAxes.col (0)).normalized();
    orientation = Quaternionf (camAxes);

    forward = -(orientation * Vector3f::UnitZ());

    pose.linear() = orientation.toRotationMatrix();

    calcViewMatrix(); // Call this to update mU and mV
    viewMatrixCached = true;
}

void CameraBody::lookAt (const Eigen::Vector3f& eyePoint)
{
    eye = eyePoint;

    pose.translation() = eye;

    Eigen::Vector3f f = (target - eyePoint).normalized();
    viewDirection = f;

    /// Check for degeneracies.If the upDir and targetDir are parallel
    // or opposite, then compute a new, arbitrary up direction that is
    // not parallel or opposite to the targetDir.
    Vector3f upDir = worldUp;

    if (upDir.cross (f).squaredNorm() == 0)
    {
        upDir = f.cross (Vector3f::UnitX());
        if (upDir.squaredNorm() == 0)
            upDir = f.cross (Vector3f::UnitZ());

        upDir *= -1.0f; // to match Cinder
    }

    Matrix3f camAxes;
    camAxes.col (2) = -f;
    camAxes.col (0) = upDir.cross (camAxes.col (2)).normalized();
    camAxes.col (1) = camAxes.col (2).cross (camAxes.col (0)).normalized();
    orientation = Quaternionf (camAxes);

    forward = -(orientation * Vector3f::UnitZ());

    pose.linear() = orientation.toRotationMatrix();

    calcViewMatrix(); // Call this to update mU and mV
    viewMatrixCached = true;
}

void CameraBody::rotateAroundTarget (const Eigen::Quaternionf& q)
{
    // update the transform matrix
    if (!viewMatrixCached)
        calcViewMatrix();

    Vector3f t = viewMatrix * target;

    viewMatrix = Translation3f (t) * q * Translation3f (-t) * viewMatrix;

    Quaternionf qa (viewMatrix.linear());
    qa = qa.conjugate();
    orientation = qa;

    eye = -(qa * viewMatrix.translation());

    pose.translation() = eye;

    forward = -(orientation * Vector3f::UnitZ());
    viewDirection = (target - eye).normalized();

    pose.linear() = orientation.toRotationMatrix();

    viewMatrixCached = false;
}

void CameraBody::zoom (float d)
{
    float dist = (eye - target).norm();
    if (dist > d)
    {
        eye = eye + viewDirection * d;
        forward = -(orientation * Vector3f::UnitZ());
        viewMatrixCached = false;
        pose.translation() = eye;
    }
}

void CameraBody::track (const Eigen::Vector2f& point2D)
{
    Vector3f newPoint3D;
    bool newPointOk = mapToSphere (point2D, newPoint3D);

    if (lastPointOk && newPointOk)
    {
        Vector3f axis = lastPoint3D.cross (newPoint3D).normalized();
        float cos_angle = lastPoint3D.dot (newPoint3D);
        if (std::abs (cos_angle) < 1.0)
        {
            float angle = 2.0f * acos (cos_angle);
            //if (mMode == Around)
            rotateAroundTarget (Quaternionf (AngleAxisf (angle, axis)));
            //else
            //mpCamera->localRotate (Quaternionf (AngleAxisf (-angle, axis)));
        }
    }

    lastPoint3D = newPoint3D;
    lastPointOk = newPointOk;
}

void CameraBody::calcMatrices() const
{
    if (!viewMatrixCached) calcViewMatrix();
}

void CameraBody::calcViewMatrix() const
{
    mW = viewDirection.normalized();
    mU = orientation * Vector3f::UnitX();
    mV = orientation * Vector3f::UnitY();

    Quaternionf q = orientation.conjugate();
    viewMatrix.linear() = q.toRotationMatrix();

    if (!wabi::isOrthogonal<float> (viewMatrix.linear()))
    {
        Matrix3f m = viewMatrix.linear();
        if (!wabi::reOrthogonalize (m))
        {
            throw std::runtime_error ("Could not fix non-orthogongal matrix");
        }

        viewMatrix.linear() = m;
    }

    viewMatrix.translation() = -(viewMatrix.linear() * eye);

    forward = -(orientation * Vector3f::UnitZ());

    viewMatrixCached = true;
    inverseModelViewCached = false;
}

void CameraBody::calcInverseView() const
{
}

bool CameraBody::mapToSphere (const Eigen::Vector2f& p2, Eigen::Vector3f& v3)
{
    int w = sensor.getPixelResolution().x();
    int h = sensor.getPixelResolution().y();

    if ((p2.x() >= 0) && (p2.x() <= w &&
                          (p2.y() >= 0) && (p2.y() <= h)))
    {
        double x = (double)(p2.x() - 0.5 * w) / (double)w;
        double y = (double)(0.5 * h - p2.y()) / (double)h;
        double sinx = sin (M_PI * x * 0.5);
        double siny = sin (M_PI * y * 0.5);
        double sinx2siny2 = sinx * sinx + siny * siny;

        v3.x() = sinx;
        v3.y() = siny;
        v3.z() = sinx2siny2 < 1.0 ? sqrt (1.0 - sinx2siny2) : 0.0;

        return true;
    }
    else
        return false;
}


 void CameraBody::panHorizontal (float distance)
{
    eye += distance * mU;
    target += distance * mU;
    viewMatrixCached = false; // Since the view matrix will change
}

void CameraBody::panVertical (float distance)
{
    eye += distance * mV;
    target += distance * mV;
    viewMatrixCached = false; // Since the view matrix will change
}

void CameraBody::debugLog() const
{
    LOG (DBUG) << "Camera Debug Information:";
    LOG (DBUG) << "------------------------";
    LOG (DBUG) << "Camera Name: " << name;
    LOG (DBUG) << "Eye Position: " << eye.transpose();
    LOG (DBUG) << "Target Position: " << target.transpose();
    LOG (DBUG) << "World Up: " << worldUp.transpose();
    LOG (DBUG) << "View Direction: " << viewDirection.transpose();
    LOG (DBUG) << "Forward Vector: " << forward.transpose();
    LOG (DBUG) << "Right Vector (U): " << mU.transpose();
    LOG (DBUG) << "Up Vector (V): " << mV.transpose();
    LOG (DBUG) << "Focal Length: " << focalLength << " m";
    LOG (DBUG) << "Aperture: " << aperture;
    LOG (DBUG) << "Vertical FOV: " << verticalFOVradians * 180.0f / M_PI << " degrees";
    LOG (DBUG) << "Pose Translation: " << pose.translation().transpose();
    LOG (DBUG) << "Pose Rotation: " << Eigen::Quaternionf (pose.rotation()).coeffs().transpose();

    // Log sensor information
    const CameraSensor* sensor = &this->sensor;
    Eigen::Vector2i resolution = sensor->getPixelResolution();
    LOG (DBUG) << "Sensor Information:";
    LOG (DBUG) << "  Resolution: " << resolution.x() << "x" << resolution.y();
    LOG (DBUG) << "  Aspect Ratio: " << sensor->getPixelAspectRatio();
    LOG (DBUG) << "  Sensor Size: " << sensor->getSensorSize().transpose() << " m";
    LOG (DBUG) << "  Pixel Size: " << sensor->pixelSize().transpose();

    // Log matrices
    LOG (DBUG) << "View Matrix:";
    LOG (DBUG) << viewMatrix.matrix();

    // Log state flags
    LOG (DBUG) << "Camera State:";
    LOG (DBUG) << "  Dirty: " << (dirty ? "Yes" : "No");
    LOG (DBUG) << "  View Matrix Cached: " << (viewMatrixCached ? "Yes" : "No");
    LOG (DBUG) << "  Inverse Model View Cached: " << (inverseModelViewCached ? "Yes" : "No");

    // Log changes
    LOG (DBUG) << "Changes since last update:";
    LOG (DBUG) << "  Position changed: " << ((eye != lastEye) ? "Yes" : "No");
    LOG (DBUG) << "  Target changed: " << ((target != lastTarget) ? "Yes" : "No");
    LOG (DBUG) << "  World Up changed: " << ((worldUp != lastWorldUp) ? "Yes" : "No");
    LOG (DBUG) << "  Focal Length changed: " << ((focalLength != lastFocalLength) ? "Yes" : "No");
    LOG (DBUG) << "  Aperture changed: " << ((aperture != lastAperture) ? "Yes" : "No");
    LOG (DBUG) << "  Pose changed: " << ((pose.matrix() != lastPose.matrix()) ? "Yes" : "No");
    LOG (DBUG) << "  Vertical FOV changed: " << ((verticalFOVradians != lastVerticalFOVradians) ? "Yes" : "No");

    LOG (DBUG) << "------------------------";
}
</file>

<file path="camera/CameraBody.h">
// This header file was auto-generated by ClassMate++
// Created: 14 Aug 2021 3:45:48 pm
// Copyright (c) 2021, HurleyWorks

#pragma once

using CameraHandle = std::shared_ptr<class CameraBody>;
using ViewportCameraPtr = std::shared_ptr<class CameraBody>;

class CameraBody
{
    // https://www.scratchapixel.com/lessons/3d-basic-rendering/3d-viewing-pinhole-camera/how-pinhole-camera-works-part-2
    // It is very important to remember that two parameters determine the angle of view : the focal length and the film size.
    // The angle of view changes when you change either one of these two parameters : the focal length or the film size.

    // For a fixed film size, changing the focal length will change the angle of view.
    // The longer the focal length, the narrower than angle of view. For a fixed focal length,
    // changing the film size will change the angle of view. The larger the film, the wider
    // the angle of view. If you wish to change the film size but keep the same angle of view,
    // you will need to adjust the focal length accordingly.

 public:
    CameraBody();
    ~CameraBody();

    bool hasSettingsChanged()
    {
        bool changed = false;

        if (eye != lastEye || target != lastTarget || worldUp != lastWorldUp)
        {
            changed = true;
        }
        else if (focalLength != lastFocalLength || aperture != lastAperture)
        {
            changed = true;
        }
        else if (pose.matrix() != lastPose.matrix())
        {
            changed = true;
        }
        else if (verticalFOVradians != lastVerticalFOVradians)
        {
            changed = true;
        }
        /* else if (sensor.pixelResolutionHasChanged())
         {
             changed = true;
         }*/

        // If changed, update the "last" variables
        if (changed)
        {
            lastEye = eye;
            lastTarget = target;
            lastWorldUp = worldUp;
            lastFocalLength = focalLength;
            lastAperture = aperture;
            lastPose = pose;
            lastVerticalFOVradians = verticalFOVradians;
            // sensor.setPixelResolutionHasChanged (false);
        }

        return changed;
    }

    float getFocalLength() const { return focalLength; }
    void setFocalLength (float length)
    {
        debug_assert (length > 0.0f);

        focalLength = length;
        float sensorHalfHeight = sensor.getSensorSize().y() / 2.0f;
        verticalFOVradians = 2 * std::atan (sensorHalfHeight / focalLength);
    }

    float getApeture() const { return aperture; }
    void setApeture (float aperture) { this->aperture = aperture; }

    void lookAt (const Eigen::Vector3f& eyePoint, const Eigen::Vector3f& target, const Eigen::Vector3f& up);
    void lookAt (const Eigen::Vector3f& eyePoint, const Eigen::Vector3f& target);
    void lookAt (const Eigen::Vector3f& eyePoint);

    wabi::Ray3f generateRay (uint32_t x, uint32_t y, bool transformed = true)
    {
        // FIXME aspect < 1.0f ?????

        float u = (2 * ((x + 0.5) * sensor.pixelSize().x()) - 1) * verticalFOVradians * sensor.getPixelAspectRatio();
        float v = (1 - 2 * ((y + 0.5) * sensor.pixelSize().y())) * verticalFOVradians;

        Eigen::Vector3f dir = Eigen::Vector3f (u, v, 1.0f).normalized();

        return wabi::Ray3<float> (pose.translation(), transformed ? pose.linear() * dir : dir);
    }

    // with jittering
    wabi::Ray3f generateRay (uint32_t x, uint32_t y, float jitterU, float jitterV, bool transformed = true)
    {
        // FIXME aspect < 1.0f ?????

        float u = (2 * ((x + jitterU) * sensor.pixelSize().x()) - 1) * verticalFOVradians * sensor.getPixelAspectRatio();
        float v = (1 - 2 * ((y + jitterV) * sensor.pixelSize().y())) * verticalFOVradians;

        Eigen::Vector3f dir = Eigen::Vector3f (u, v, 1.0f).normalized();

        return wabi::Ray3<float> (pose.translation(), transformed ? pose.linear() * dir : dir);
    }

    void rotateAroundTarget (const Eigen::Quaternionf& q);
    void zoom (float d);

    // trackball
    void startTracking() { lastPointOk = false; }
    void track (const Eigen::Vector2f& point2D);

  //  const OIIO::ImageBuf& getSensorHDRPixels() { return sensor.getHDRImage(); }
//const OIIO::ImageBuf& getSensorLDRPixels() { return sensor.getLDRImage(); }

    // OIIO::ImageBuf getSensorHDRPixels() { return sensor.getHDRImage(); }
    //  OIIO::ImageBuf getSensorLDRPixels() { return sensor.getLDRImage(); }

    CameraSensor* getSensor() { return &sensor; }

    void setPose (const Pose& pose) { this->pose = pose; }
    const Pose& getPose() const { return pose; }
    Pose& getPose() { return pose; }

    bool isDirty() const { return dirty; }
    void setDirty (bool state) { dirty = state; }

    float getVerticalFOVradians() { return verticalFOVradians; }

    const Eigen::Matrix4f& getViewMatrix() const
    {
        if (!viewMatrixCached)
            calcViewMatrix();
        return viewMatrix.matrix();
    }

    void setEyePoint (const Eigen::Vector3f& eyePoint, bool update = false)
    {
        eye = eyePoint;
    }

    void setTarget (const Eigen::Vector3f& newTarget)
    {
        target = newTarget;
    }

    Eigen::Vector3f& getEyePoint() { return eye; }
    const Eigen::Vector3f& getEyePoint() const { return eye; }
    const Eigen::Vector3f& getWorldUp() const { return worldUp; }
    const Eigen::Vector3f& getUp() const { return mV; }
    const Eigen::Vector3f& getRight() const { return mU; }
    const Eigen::Vector3f& getFoward() const { return forward; }
    const Eigen::Vector3f& getTarget() const { return target; }
    const Eigen::Vector3f& getViewDirection() const { return viewDirection; }
    const Eigen::Quaternionf& getOrientation() const { return orientation; }

    void panHorizontal (float distance);
    void panVertical (float distance);

    template <class Archive>
    void serialize (Archive& ar)
    {
        ar (CEREAL_NVP (focalLength), CEREAL_NVP (aperture), CEREAL_NVP (eye), CEREAL_NVP (target));
    }

    void setChangedSensorPixelRes (Eigen::Vector2i size) { sensorPixelRes = size; }
    const Eigen::Vector2i& getChangedSensorPixelRes() const { return sensorPixelRes; }
    void debugLog() const;

    void setViewportIndex (uint32_t index) { viewportIndex = index; }
    uint32_t getViewportIndex() const { return viewportIndex; }

 private:
    CameraSensor sensor;
    std::string name = "Perspective Camera";
    Pose pose;
    bool dirty = true;
    float verticalFOVradians = DEFAULT_FOV_DEGREES;
    float focalLength = 0.055f; // 55 mm lens
    float aperture = 0.0f;
    Eigen::Vector3f target = Eigen::Vector3f::Zero();
    uint32_t viewportIndex = 0;

    // trackball
    Eigen::Vector3f lastPoint3D = Eigen::Vector3f::Zero();
    bool lastPointOk = false;
    bool mapToSphere (const Eigen::Vector2f& p2, Eigen::Vector3f& v3);

    Eigen::Vector3f getPosition() { return pose.translation(); }

    Eigen::Vector3f eye = DEFAULT_CAMERA_POSIIION;
    Eigen::Vector3f viewDirection = Eigen::Vector3f::UnitZ();
    mutable Eigen::Vector3f forward = Eigen::Vector3f::UnitX();
    Eigen::Quaternionf orientation;
    Eigen::Vector3f worldUp = Eigen::Vector3f::UnitY();

    mutable Eigen::Vector3f mU; // Right vector
    mutable Eigen::Vector3f mV; // Readjust up-vector
    mutable Eigen::Vector3f mW; // Negative view direction

    mutable Eigen::Affine3f viewMatrix;
    mutable bool viewMatrixCached;
    mutable Matrix4f inverseModelViewMatrix;
    mutable bool inverseModelViewCached;

    Eigen::Vector3f lastEye = Eigen::Vector3f::Zero();
    Eigen::Vector3f lastTarget = Eigen::Vector3f::Zero();
    Eigen::Vector3f lastWorldUp = Eigen::Vector3f::UnitY();
    float lastFocalLength = 0.0f;
    float lastAperture = 0.0f;
    Pose lastPose;
    float lastVerticalFOVradians = 0.0f;

    Eigen::Vector2i sensorPixelRes = DEFAULT_DESKTOP_WINDOW_SIZE;

    void calcMatrices() const;
    virtual void calcViewMatrix() const;
    virtual void calcInverseView() const;
};
</file>

<file path="camera/CameraSensor.h">
#pragma once

// The CameraSensor class represents a digital camera sensor, managing both HDR (High Dynamic Range)
// and LDR (Low Dynamic Range) image data. It utilizes a double-buffering technique to ensure
// thread-safe operations between the rendering thread and the front-end thread.
//
// Key features:
// 1. Double buffering: The class maintains two sets of image buffers (HDR) to allow
//    simultaneous reading and writing operations.
// 2. Thread safety: Uses atomic operations and memory ordering to ensure safe concurrent access.
// 3.
// 4. Flexible resolution: Allows dynamic changes to sensor resolution.
// 5. Performance optimization: Uses OIIO (OpenImageIO) for efficient image processing.
//
// Double buffering implementation:
// - Two image buffers are maintained: images[0] and images[1]
// - currentReadBuffer atomic variable indicates which buffer is currently safe for reading.
// - updateImage() writes to the non-reading buffer, then atomically switches the currentReadBuffer.
// - getHDRImage() always read from the current read buffer.
//
// This approach allows the rendering thread to update the image data while the front-end thread
// can safely read the most recent complete image, preventing data races and ensuring consistency.
//
// The class is designed for high-performance scenarios, such as real-time rendering in a LightWave3D
// plugin, where efficient and thread-safe image handling is crucial.

using Eigen::Vector2i;

class CameraSensor
{
 public:
    CameraSensor() :
        currentReadBuffer (0)
    {
        // Start with default resolution
        setPixelResolution (DEFAULT_DESKTOP_WINDOW_WIDTH, DEFAULT_DESKTOP_WINDOW_HEIGHT);
    }

    void setPixelResolution (uint32_t w, uint32_t h)
    {
        LOG (DBUG) << _FN_ << "   " << w << ", " << h;
        // Create new buffers at new resolution
        OIIO::ImageSpec newSpec (w, h, 4, OIIO::TypeDesc::FLOAT);

        // Initialize both buffers before switching
        OIIO::ImageBuf newBuffers[2];
        newBuffers[0].reset (newSpec, OIIO::InitializePixels::Yes);
        newBuffers[1].reset (newSpec, OIIO::InitializePixels::Yes);

        // Verify both buffers initialized correctly
        if (!newBuffers[0].initialized() || !newBuffers[1].initialized())
        {
            return;
        }

        // Update dimensions
        width.store (w, std::memory_order_release);
        height.store (h, std::memory_order_release);

        // Only swap buffers if both new ones are valid
        images[0].swap (newBuffers[0]);
        images[1].swap (newBuffers[1]);

        aspect = static_cast<float> (w) / static_cast<float> (h);
        invPixelResolution = Eigen::Vector2f (1.0f / static_cast<float> (w),
                                              1.0f / static_cast<float> (h));
    }

    bool getHDRImageCopy (OIIO::ImageBuf& outBuffer) const
    {
        const int readBuffer = currentReadBuffer.load (std::memory_order_acquire);
        const OIIO::ImageBuf& srcBuf = images[readBuffer];

        if (!srcBuf.initialized()) return false;

        // Create new buffer with same specs
        const OIIO::ImageSpec& spec = srcBuf.spec();
        outBuffer.reset (spec);

        // Copy the pixels
        return OIIO::ImageBufAlgo::copy (outBuffer, srcBuf);
    }

    bool updateImage (const void* renderedPixels, Vector2i renderSize, bool previewMode, uint32_t renderScale)
    {
        // Early validation of input data
        if (!renderedPixels)
        {
            LOG (WARNING) << "Invalid pixel data pointer";
            return false;
        }

        uint32_t renderWidth = renderSize.x();
        uint32_t renderHeight = renderSize.y();

        const int writeBuffer = 1 - currentReadBuffer.load (std::memory_order_acquire);
        const uint32_t viewportWidth = width.load (std::memory_order_acquire);
        const uint32_t viewportHeight = height.load (std::memory_order_acquire);

        // Validate viewport dimensions
        if (viewportWidth == 0 || viewportHeight == 0)
        {
            LOG (WARNING) << "Invalid viewport dimensions: " << viewportWidth << "x" << viewportHeight;
            return false;
        }

        // Validate render dimensions
        if (renderWidth == 0 || renderHeight == 0)
        {
            LOG (WARNING) << "Invalid render dimensions: " << renderWidth << "x" << renderHeight;
            return false;
        }

        /*  LOG (DBUG) << "UpdateImage: viewport=" << viewportWidth << "x" << viewportHeight
                     << " render=" << renderWidth << "x" << renderHeight
                     << " preview=" << (previewMode ? "true" : "false")
                     << " scale=" << renderScale;*/

        if (previewMode && renderScale > 1)
        {
            // Create temp buffer at viewport dimensions
            OIIO::ImageSpec spec (viewportWidth, viewportHeight, 4, OIIO::TypeDesc::FLOAT);
            OIIO::ImageBuf tempBuf (spec);

            // Create source buffer at render dimensions
            OIIO::ImageSpec srcSpec (renderWidth, renderHeight, 4, OIIO::TypeDesc::FLOAT);
            OIIO::ImageBuf srcBuf (srcSpec);

            // Validate source buffer creation
            if (!srcBuf.initialized())
            {
                LOG (WARNING) << "Failed to initialize source buffer";
                return false;
            }

            // Copy rendered pixels to source buffer
            void* srcPixels = srcBuf.localpixels();
            if (!srcPixels)
            {
                LOG (WARNING) << "Failed to get source buffer pixels";
                return false;
            }

            const size_t srcByteSize = renderWidth * renderHeight * 4 * sizeof (float);
            std::memcpy (srcPixels, renderedPixels, srcByteSize);

            // Resize from render dimensions to viewport dimensions
            if (!OIIO::ImageBufAlgo::resize (tempBuf, srcBuf))
            {
                LOG (WARNING) << "Resize failed: " << tempBuf.geterror();
                return false;
            }

            // Initialize write buffer at viewport dimensions
            images[writeBuffer].reset (spec, OIIO::InitializePixels::Yes);
            if (!images[writeBuffer].initialized())
            {
                LOG (WARNING) << "Failed to initialize write buffer";
                return false;
            }

            // Copy resized result
            if (!OIIO::ImageBufAlgo::copy (images[writeBuffer], tempBuf))
            {
                LOG (WARNING) << "Failed to copy to write buffer";
                return false;
            }
        }
        else
        {
            // Create buffers - source at render dimensions, destination at viewport dimensions
            OIIO::ImageSpec srcSpec (renderWidth, renderHeight, 4, OIIO::TypeDesc::FLOAT);
            OIIO::ImageBuf srcBuf (srcSpec);

            void* srcPixels = srcBuf.localpixels();
            if (!srcPixels)
            {
                LOG (WARNING) << "Failed to get source buffer pixels";
                return false;
            }

            const size_t srcByteSize = renderWidth * renderHeight * 4 * sizeof (float);
            std::memcpy (srcPixels, renderedPixels, srcByteSize);

            // If dimensions don't match, resize
            if (renderWidth != viewportWidth || renderHeight != viewportHeight)
            {
                OIIO::ImageSpec destSpec (viewportWidth, viewportHeight, 4, OIIO::TypeDesc::FLOAT);
                OIIO::ImageBuf destBuf (destSpec);

                if (!OIIO::ImageBufAlgo::resize (destBuf, srcBuf))
                {
                    LOG (WARNING) << "Failed to resize rendered image: " << destBuf.geterror();
                    return false;
                }

                images[writeBuffer].reset (destSpec, OIIO::InitializePixels::Yes);
                if (!OIIO::ImageBufAlgo::copy (images[writeBuffer], destBuf))
                {
                    LOG (WARNING) << "Failed to copy resized image";
                    return false;
                }
            }
            else
            {
                // Dimensions match, direct copy
                images[writeBuffer].reset (srcSpec, OIIO::InitializePixels::Yes);
                if (!OIIO::ImageBufAlgo::copy (images[writeBuffer], srcBuf))
                {
                    LOG (WARNING) << "Failed to copy to write buffer";
                    return false;
                }
            }
        }

        // Flip the result vertically
        OIIO::ImageBuf flipped;
        if (!OIIO::ImageBufAlgo::flip (flipped, images[writeBuffer]))
        {
            LOG (WARNING) << "Failed to flip buffer: " << flipped.geterror();
            return false;
        }
        images[writeBuffer].copy (flipped);

        currentReadBuffer.store (writeBuffer, std::memory_order_release);
        return true;
    }
#if 0
    bool updateImage (const void* renderedPixels, Vector2i renderSize, bool previewMode, uint32_t renderScale)
    {
        if (!renderedPixels) return false;

        const int writeBuffer = 1 - currentReadBuffer.load (std::memory_order_acquire);
        const uint32_t viewportWidth = width.load (std::memory_order_acquire);
        const uint32_t viewportHeight = height.load (std::memory_order_acquire);

        if (previewMode && renderScale > 1)
        {
            // Create temp buffer at viewport dimensions (not render dimensions)
            OIIO::ImageSpec spec (viewportWidth, viewportHeight, 4, OIIO::TypeDesc::FLOAT);
            OIIO::ImageBuf tempBuf (spec);

            // Create source buffer at render dimensions
            OIIO::ImageSpec srcSpec (viewportWidth * renderScale, viewportHeight * renderScale, 4, OIIO::TypeDesc::FLOAT);
            OIIO::ImageBuf srcBuf (srcSpec);

            // Copy rendered pixels to source buffer
            void* srcPixels = srcBuf.localpixels();
            if (!srcPixels) return false;

            const size_t srcByteSize = srcSpec.width * srcSpec.height * 4 * sizeof (float);
            std::memcpy (srcPixels, renderedPixels, srcByteSize);

            // Resize from render dimensions to viewport dimensions
            if (!OIIO::ImageBufAlgo::resize (tempBuf, srcBuf))
            {
                LOG (WARNING) << "Resize failed: " << tempBuf.geterror();
                return false;
            }

            // Initialize write buffer at viewport dimensions
            images[writeBuffer].reset (spec, OIIO::InitializePixels::Yes);
            if (!images[writeBuffer].initialized())
            {
                LOG (WARNING) << "Failed to initialize write buffer";
                return false;
            }

            // Copy resized result
            if (!OIIO::ImageBufAlgo::copy (images[writeBuffer], tempBuf))
            {
                LOG (WARNING) << "Failed to copy to write buffer";
                return false;
            }
        }
        else
        {
            // Handle non-preview mode (same as original)
            OIIO::ImageSpec spec (viewportWidth, viewportHeight, 4, OIIO::TypeDesc::FLOAT);
            OIIO::ImageBuf tempBuf (spec);

            void* destPixels = tempBuf.localpixels();
            if (!destPixels) return false;

            const size_t byteSize = viewportWidth * viewportHeight * 4 * sizeof (float);
            std::memcpy (destPixels, renderedPixels, byteSize);

            images[writeBuffer].reset (spec, OIIO::InitializePixels::Yes);
            if (!OIIO::ImageBufAlgo::copy (images[writeBuffer], tempBuf))
            {
                return false;
            }
        }

        // Flip the result vertically
        OIIO::ImageBuf flipped;
        if (!OIIO::ImageBufAlgo::flip (flipped, images[writeBuffer]))
        {
            LOG (WARNING) << "Failed to flip buffer: " << flipped.geterror();
            return false;
        }
        images[writeBuffer].copy (flipped);

        currentReadBuffer.store (writeBuffer, std::memory_order_release);
        return true;
    }
#endif

    bool isValid() const
    {
        const int readBuffer = currentReadBuffer.load (std::memory_order_acquire);
        return images[readBuffer].initialized();
    }

    const OIIO::ImageBuf& getHDRImage() const
    {
        const int readBuffer = currentReadBuffer.load (std::memory_order_acquire);
        return images[readBuffer];
    }

    Eigen::Vector2i getPixelResolution() const
    {
        return Eigen::Vector2i (
            width.load (std::memory_order_acquire),
            height.load (std::memory_order_acquire));
    }
    // Returns the size of one pixel (1 / pixel resolution)
    const Eigen::Vector2f& pixelSize() const
    {
        return invPixelResolution;
    }

    float getPixelAspectRatio() const { return aspect; }
    void setPixelAspectRatio (float aspect) { this->aspect = aspect; }

    const Eigen::Vector2f& getSensorSize() const
    {
        return sensorSize;
    }

 private:
    float aspect;
    Eigen::Vector2f invPixelResolution;
    Eigen::Vector2f sensorSize = Eigen::Vector2f (0.036f, 0.024f);

    std::array<OIIO::ImageBuf, 2> images;
    std::atomic<int> currentReadBuffer;
    std::atomic<uint32_t> width;
    std::atomic<uint32_t> height;
};
</file>

<file path="cgmodel/CgMaterial.h">
#pragma once

#pragma once

#include <optional>
#include <memory>

struct CgTextureTransform
{
    float rotation = 0.0f;
    Eigen::Vector2f uvOffset = Eigen::Vector2f::Zero();
    Eigen::Vector2f uvScale = Eigen::Vector2f::Ones();
    std::optional<std::size_t> texCoordIndex;
};

struct CgTextureInfo
{
    std::size_t textureIndex;
    std::size_t texCoordIndex = 0;
    // Changed back to unique_ptr
    std::unique_ptr<CgTextureTransform> transform;

    // Special texture info variants
    float scale = 1.0f;    // For normal maps
    float strength = 1.0f; // For occlusion maps

    // Default Constructor
    CgTextureInfo() = default;

    // Copy Constructor (Deep Copy)
    CgTextureInfo (const CgTextureInfo& other) :
        textureIndex (other.textureIndex),
        texCoordIndex (other.texCoordIndex),
        scale (other.scale),
        strength (other.strength)
    {
        if (other.transform)
        {
            transform = std::make_unique<CgTextureTransform> (*other.transform);
        }
    }
    // Move Constructor
    CgTextureInfo (CgTextureInfo&& other) noexcept = default;

    // Copy Assignment Operator (Deep Copy)
    CgTextureInfo& operator= (const CgTextureInfo& other)
    {
        textureIndex = other.textureIndex;
        texCoordIndex = other.texCoordIndex;
        scale = other.scale;
        strength = other.strength;

        if (other.transform)
        {
            transform = std::make_unique<CgTextureTransform> (*other.transform);
        }
        else
        {
            transform.reset();
        }
        return *this;
    }
    // Move Assignment operator
    CgTextureInfo& operator= (CgTextureInfo&& other) noexcept = default;
};

struct CgTexture
{
    std::optional<std::size_t> samplerIndex;
    std::optional<std::size_t> imageIndex;

    // Extension texture indices
    std::optional<std::size_t> basisuImageIndex;
    std::optional<std::size_t> ddsImageIndex;
    std::optional<std::size_t> webpImageIndex;

    std::string name;
};

struct CgImage
{
    std::string uri;
    std::string mimeType;

    // For embedded/loaded images
    OIIO::ImageBuf extractedImage;

    std::size_t index = 0;
    std::string name;
};

// Using our own enum types to avoid dependency on fastgltf
enum class CgFilter : uint16_t
{
    Nearest = 9728,
    Linear = 9729,
    NearestMipMapNearest = 9984,
    LinearMipMapNearest = 9985,
    NearestMipMapLinear = 9986,
    LinearMipMapLinear = 9987
};

enum class CgWrap : uint16_t
{
    ClampToEdge = 33071,
    MirroredRepeat = 33648,
    Repeat = 10497
};

struct CgSampler
{
    std::optional<CgFilter> magFilter;
    std::optional<CgFilter> minFilter;
    CgWrap wrapS = CgWrap::Repeat;
    CgWrap wrapT = CgWrap::Repeat;

    std::string name;
};

enum class AlphaMode : std::uint8_t
{
    Opaque,
    Mask,
    Blend,
};

struct CgMaterial
{
    // Core PBR Properties aligned with UI organization
    struct CoreProperties
    {
        Eigen::Vector3f baseColor = {0.5f, 0.5f, 0.5f};
        float roughness = 0.0f;
        float specular = 0.5f;
        float specularTint = 0.0f;
        std::optional<CgTextureInfo> baseColorTexture;
        std::optional<CgTextureInfo> roughnessTexture;
    };

    struct SheenProperties
    {
        Eigen::Vector3f sheenColorFactor = {0.0f,0.0f, 0.0f};
        float sheenRoughnessFactor = 0.0f;
        std::optional<CgTextureInfo> sheenColorTexture;
        std::optional<CgTextureInfo> sheenRoughnessTexture;
    };

    struct TranslucencyProperties
    {
        float translucency = 0.0f;
        float flatness = 0.0f;
        std::optional<CgTextureInfo> translucencyTexture;
    };

    struct SubsurfaceProperties
    {
        float subsurface = 0.0f;
        Eigen::Vector3f subsurfaceColor = {1.0f, 1.0f, 1.0f};
        float subsurfaceDistance = 1.0f; // mm
        float asymmetry = 0.0f;
        std::optional<CgTextureInfo> subsurfaceColorTexture;
    };

    struct EmissionProperties
    {
        float luminous = 0.0f;
        Eigen::Vector3f luminousColor = {0.5f, 0.5f, 0.5f};
        std::optional<CgTextureInfo> luminousTexture;
    };

    struct MetallicProperties
    {
        float metallic = 0.0f;
        float anisotropic = 0.0f;
        float anisotropicRotation = 0.0f;
        std::optional<CgTextureInfo> metallicTexture;
        std::optional<CgTextureInfo> anisotropicTexture;
        std::optional<CgTextureInfo> anisotropicRotationTexture;
    };

    struct ClearcoatProperties
    {
        float clearcoat = 0.0f;
        float clearcoatGloss = 1.0f;
        std::optional<CgTextureInfo> clearcoatTexture;
        std::optional<CgTextureInfo> clearcoatRoughnessTexture;
        std::optional<CgTextureInfo> clearcoatNormalTexture;
    };

    struct TransparencyProperties
    {
        bool thin = false;
        float transparency = 0.0f;
        Eigen::Vector3f transmittance = {0.5f, 0.5f, 0.5f};
        float transmittanceDistance = 1.0f; // meters
        float refractionIndex = 1.5f;
        std::optional<CgTextureInfo> transparencyTexture;
        std::optional<CgTextureInfo> transmittanceTexture;
    };

    struct PackedTextureProperties
    {
        std::optional<CgTextureInfo> occlusionRoughnessMetallicTexture;
        std::optional<CgTextureInfo> normalRoughnessMetallicTexture;
        std::optional<CgTextureInfo> roughnessMetallicOcclusionTexture;
    };

    // Main material components
    CoreProperties core;
    SheenProperties sheen;
    TranslucencyProperties translucency;
    SubsurfaceProperties subsurface;
    EmissionProperties emission;
    MetallicProperties metallic;
    ClearcoatProperties clearcoat;
    TransparencyProperties transparency;
    PackedTextureProperties packedTextures;

    // Common material properties
    float bumpHeight = 1.0f;
    std::optional<CgTextureInfo> normalTexture;
    std::optional<CgTextureInfo> bumpTexture;
    std::optional<CgTextureInfo> occlusionTexture;
    bool doubleSided = false;

    // Material variant support
    std::vector<std::size_t> variantIndices;

    std::string name;

    // Add Material flags
    struct Flags
    {
        bool unlit = false;
        AlphaMode alphaMode = AlphaMode::Opaque;
        float alphaCutoff = 0.5f;
    } flags;
};
</file>

<file path="cgmodel/cgModel.h">
#pragma once

#include "CgModelSurface.h"

using CgModelPtr = std::shared_ptr<struct CgModel>;
using Eigen::Vector3f;

struct CgModel
{
    static CgModelPtr create() { return std::make_shared<CgModel>(); }

    MatrixXf V;   // vertices
    MatrixXf VD;  // displaced vertices
    MatrixXf N;   // vertex normals
    MatrixXf FN;  // face normals
    ParticleData P; // particle data
    MatrixXf UV0; // uv0
    MatrixXf UV1; // uv1

    // list of Surfaces and surface attributes
    std::vector<CgModelSurface> S;
    std::vector<Texture> textures;
    std::vector<Image> images;
    std::vector<Sampler> samplers;

    
    // CgMaterial Texture/Image/Sampler support
    std::vector<sabi::CgTexture> cgTextures;
    std::vector<sabi::CgImage> cgImages;
    std::vector<sabi::CgSampler> cgSamplers;
    

    fs::path contentDirectory;

    size_t triCount = 0; // must be computed
    size_t vertexCount() const { return V.cols(); }
    size_t triangleCount() 
    {
        // compute total face count if neccessary
        if (triCount == 0 && S.size())
        {
            MatrixXu allIndices;
            getAllSurfaceIndices (allIndices);
        }
        return triCount;
    }

    void reset()
    {
        V.resize (3, 0);
        N.resize (3, 0);
        UV0.resize (2, 0);
        UV1.resize (2, 0);
        triCount = 0;
        S.clear();
        textures.clear();
        images.clear();
        samplers.clear();
    }

    Eigen::AlignedBox3f computeBoundingBox() const
    {
        if (V.cols() == 0)
        {
            return Eigen::AlignedBox3f();
        }

        Eigen::AlignedBox3f bbox;
        bbox.min() = V.rowwise().minCoeff();
        bbox.max() = V.rowwise().maxCoeff();

        return bbox;
    }

     float computeSurfaceArea() const
    {
        float totalArea = 0.0f;

        for (const auto& surface : S)
        {
            const MatrixXu& F = surface.indices();

            for (int i = 0; i < F.cols(); ++i)
            {
                const Vector3u& tri = F.col (i);
                const Vector3f& v0 = V.col (tri[0]);
                const Vector3f& v1 = V.col (tri[1]);
                const Vector3f& v2 = V.col (tri[2]);

                Vector3f e1 = v1 - v0;
                Vector3f e2 = v2 - v0;

                float area = 0.5f * e1.cross (e2).norm();

                // Check for degenerate triangles
                if (std::isnan (area) || std::isinf (area) || area <= std::numeric_limits<float>::epsilon())
                {
                    // Skip degenerate triangles and log a warning
                    LOG (CRITICAL) << "Warning: Degenerate triangle found. Skipping...";
                    continue;
                }

                totalArea += area;
            }
        }

        return totalArea;
    }

    bool isValid()
    {
        if (V.cols() < 3 || N.cols() < 3) return false;
        if (N.cols() > 0 && V.cols() != N.cols()) return false;
        if (triangleCount() == 0) return false;
        if (S.size() == 0) return false;
        for (const auto& s : S)
            if (s.vertexCount == 0) return false;

        return true;
    }

    void transformVertices (const Eigen::Affine3f& t)
    {
        for (int i = 0; i < V.cols(); ++i)
        {
            Eigen::Vector3f p = V.col (i);
            V.col (i) = t * p;
        }
    }

    void getAllSurfaceIndices (MatrixXu& allIndices, bool unwelded = false) 
    {
        triCount = 0;
        for (const auto& s : S)
        {
            triCount += s.triangleCount();
        }

        allIndices.resize (3, triCount);

        int index = 0;
        for (const auto& s : S)
        {
            size_t triCount = s.triangleCount();

            for (int i = 0; i < triCount; i++)
                allIndices.col (index++) = s.indices().col (i);
        }
    }
    void debugMaterials()
    {
        for (auto& surface : S)
        {
           //  auto& mat = surface.material;
           // mat.debug();
        }

    }
};

using CgModelList = std::vector<CgModelPtr>;
</file>

<file path="cgmodel/cgModelSurface.h">
#pragma once

using Eigen::Vector3f;

// a Surface is a group of triangles with a unique Material
struct CgModelSurface
{
    std::string name;
    MatrixXu F; // triangle indices
    Material material;
    CgMaterial cgMaterial;
    float maxSmoothingAngle = 0.0f; // Maximum smoothing angle in radians

  
    bool materialHasChanged = false;

    const size_t triangleCount() const { return F.cols(); }
    MatrixXu& indices() { return F; }
    const MatrixXu& indices() const { return F; }

    uint32_t vertexCount = 0;

    float computeSurfaceArea (const MatrixXf& V) const
    {
        float area = 0.0f;

        for (int i = 0; i < F.cols(); ++i)
        {
            const Vector3u& tri = F.col (i);
            const Vector3f& v0 = V.col (tri[0]);
            const Vector3f& v1 = V.col (tri[1]);
            const Vector3f& v2 = V.col (tri[2]);

            Vector3f e1 = v1 - v0;
            Vector3f e2 = v2 - v0;

            float triArea = 0.5f * e1.cross (e2).norm();

            // Check for degenerate triangles
            if (std::isnan (triArea) || std::isinf (triArea) || triArea <= std::numeric_limits<float>::epsilon())
            {
                // Skip degenerate triangles and log a warning
                LOG (CRITICAL) << "Warning: Degenerate triangle found in surface. Skipping...";
                continue;
            }

            area += triArea;
        }

        return area;
    }

    Vector3f computeCentroid (const MatrixXf& V) const
    {
        Vector3f centroid = Vector3f::Zero();

        for (int i = 0; i < F.cols(); ++i)
        {
            const Vector3u& tri = F.col (i);
            const Vector3f& v0 = V.col (tri[0]);
            const Vector3f& v1 = V.col (tri[1]);
            const Vector3f& v2 = V.col (tri[2]);

            centroid += (v0 + v1 + v2) / 3.0f;
        }

        centroid /= static_cast<float> (F.cols());

        return centroid;
    }
};
</file>

<file path="cgmodel/MeshOptions.h">
// This header file was auto-generated by ClassMate++
// Created: 16 Sep 2017 5:37:16 pm
// Copyright (c) 2017, HurleyWorks

#pragma once

static const char* MeshOptionsTable[] =
    {
        "CenterVertices",
        "NormalizeSize",
        "ReduceMesh",
        "RestOnGround",
        "LoadStrategy",
        "ConvertToRHCoords",
        "Invalid"};

struct MeshOptions
{
    enum EMeshOptions
    {
        CenterVertices = 1 << 0,
        NormalizeSize = 1 << 1,
        ReduceMesh = 1 << 2,
        RestOnGround = 1 << 3,
        LoadStrategy = 1 << 4,
        ConvertToRHCoords = 1 << 5,
        Invalid = 1 << 6
    };

    union
    {
        EMeshOptions name;
        unsigned value;
    };

    MeshOptions (EMeshOptions name) :
        name (name) {}
    MeshOptions (unsigned value) :
        value (value) {}
    MeshOptions() :
        value (0) {}
    void clear() { value = 0; }
    operator EMeshOptions() const { return name; }
    unsigned operator|= (MeshOptions m) { return value |= m; }
    unsigned operator&= (MeshOptions m) { return value &= m; }
    unsigned operator^= (MeshOptions m) { return value ^= m; }

    std::string toString()
    {
        std::ostringstream ostr;
        ostr << "  MeshOptions";

        if (value & CenterVertices)
            ostr << "::CenterVertices";

        if (value & NormalizeSize)
            ostr << "::NormalizeSize:";

        if (value & ReduceMesh)
            ostr << "::ReduceMesh:";

        if (value & RestOnGround)
            ostr << "::RestOnGround:";

        if (value & LoadStrategy)
            ostr << "::LoadStrategy:";

        if (value & ConvertToRHCoords)
            ostr << "::ConvertToRHCoords:";

        if (value & Invalid)
            ostr << "::Invalid:";

        return ostr.str();
    }
};

static const char* RetopologyOptionsTable[] =
    {
        "ReduceMesh",
        "ReduceConvexHull",
        "Invalid"};

struct RetopologyOptions
{
    enum ERetopologyOptions
    {
        ReduceMesh = 1 << 0,
        ReduceConvexHull = 1 << 2,
        Invalid = 1 << 2
    };

    union
    {
        ERetopologyOptions name;
        unsigned value;
    };

    RetopologyOptions (ERetopologyOptions name) :
        name (name) {}
    RetopologyOptions (unsigned value) :
        value (value) {}
    RetopologyOptions() :
        value (0) {}
    void clear() { value = 0; }
    operator ERetopologyOptions() const { return name; }
    unsigned operator|= (RetopologyOptions m) { return value |= m; }
    unsigned operator&= (RetopologyOptions m) { return value &= m; }
    unsigned operator^= (RetopologyOptions m) { return value ^= m; }

    std::string toString()
    {
        std::ostringstream ostr;
        ostr << "  RetopologyOptions";

        if (value & ReduceMesh)
            ostr << "::ReduceMesh";

        if (value & ReduceConvexHull)
            ostr << "::ReduceConvexHull:";

        if (value & Invalid)
            ostr << "::Invalid:";

        return ostr.str();
    }
};
</file>

<file path="io/AssetPathManager.h">
#pragma once

//#include <mace_core/mace_core.h>

class AssetPathManager
{
 public:
    void addAssetMapping (const fs::path& originalPath, const fs::path& newRelativePath)
    {
        assetMap[originalPath.string()] = newRelativePath.string();
    }

    std::string getRelativePath (const std::string& originalPath) const
    {
        auto it = assetMap.find (originalPath);
        if (it != assetMap.end())
        {
            return it->second;
        }
        return originalPath; // Return original path if not found
    }

 private:
    std::unordered_map<std::string, std::string> assetMap;
};
</file>

<file path="io/GltfAnimationExporter.h">
#pragma once

class GltfAnimationExporter
{
 public:
    std::vector<AnimationChannel> exportAnimation (const fastgltf::Asset& asset, size_t animationIndex)
    {
        std::vector<AnimationChannel> channels;

        if (animationIndex >= asset.animations.size())
        {
            LOG (CRITICAL) << "Invalid animation index: " << animationIndex;
            return channels;
        }

        const auto& animation = asset.animations[animationIndex];

        for (const auto& channel : animation.channels)
        {
            AnimationChannel animChannel;
            animChannel.targetNode = asset.nodes[*channel.nodeIndex].name;
            animChannel.path = channel.path;

            const auto& sampler = animation.samplers[channel.samplerIndex];
            const auto& input = asset.accessors[sampler.inputAccessor];
            const auto& output = asset.accessors[sampler.outputAccessor];

            auto times = getAccessorData<float> (asset, input);

            switch (channel.path)
            {
                case fastgltf::AnimationPath::Translation:
                case fastgltf::AnimationPath::Scale:
                case fastgltf::AnimationPath::Rotation:
                {
                    auto values = getAccessorData<float> (asset, output);

                    auto componentCount = fastgltf::getNumComponents (output.type);
                    
                    for (size_t i = 0; i < times.size(); ++i)
                    {
                        KeyFrame keyFrame = createKeyFrame (channel, times[i], &values[i * componentCount]);

                        keyFrame.debug();
                        animChannel.keyFrames.push_back (keyFrame);
                    }

                    break;
                }

                default:
                    LOG (CRITICAL) << "Unsupported animation path";
                    continue;
            }

            channels.push_back (std::move (animChannel));
        }

        return channels;
    }

 private:
    template <typename T>
    std::vector<T> getAccessorData (const fastgltf::Asset& asset, const fastgltf::Accessor& accessor)
    {
        auto componentCount = fastgltf::getNumComponents (accessor.type);
        std::vector<T> data (accessor.count * componentCount);

        fastgltf::copyComponentsFromAccessor<T> (asset, accessor, data.data());

        return data;
    }

    KeyFrame createKeyFrame (const auto& channel, float time, const float* values)
    {
        KeyFrame keyFrame;
        keyFrame.time = time;

        switch (channel.path)
        {
            case fastgltf::AnimationPath::Translation:
                keyFrame.translation = Eigen::Vector3f (values[0], values[1], values[2]);
                keyFrame.rotation = Eigen::Quaternionf::Identity(); // Set identity rotation
                keyFrame.scale = Eigen::Vector3f::Ones();           // Set unit scale
                break;
            case fastgltf::AnimationPath::Rotation:
                keyFrame.translation = Eigen::Vector3f::Zero(); // Set zero translation
                keyFrame.rotation = Eigen::Quaternionf (values[3], values[0], values[1], values[2]).normalized();
                keyFrame.scale = Eigen::Vector3f::Ones(); // Set unit scale
                break;
            case fastgltf::AnimationPath::Scale:
                keyFrame.translation = Eigen::Vector3f::Zero();     // Set zero translation
                keyFrame.rotation = Eigen::Quaternionf::Identity(); // Set identity rotation
                keyFrame.scale = Eigen::Vector3f (values[0], values[1], values[2]);
                break;
            default:
                LOG (CRITICAL) << "Unsupported animation path in createKeyFrame";
                // Set default values for all fields
                keyFrame.translation = Eigen::Vector3f::Zero();
                keyFrame.rotation = Eigen::Quaternionf::Identity();
                keyFrame.scale = Eigen::Vector3f::Ones();
        }

        return keyFrame;
    }
};
</file>

<file path="io/GLTFImporter.cpp">
#include <stb_image/stb_image.h>

using fastgltf::Asset;
using fastgltf::Expected;
using fastgltf::GltfDataBuffer;
using fastgltf::Options;
using fastgltf::Parser;

using sabi::CgModelSurface;
using sabi::Material;

std::pair<CgModelPtr, std::vector<Animation>> GLTFImporter::importModel (const std::string& filePath)
{
    try
    {
        if (!fs::exists (filePath) || !fs::is_regular_file (filePath))
        {
            throw std::runtime_error ("File does not exist!");
        }

        auto asset = loadGLTF (filePath);

        processScenes (asset);
        if (models.size() == 0) return {nullptr, {}};

        CgModelPtr cgModel = models.size() > 1 ? forgeIntoOne (models) : models[0];
        if (!cgModel) return {nullptr, {}};

        importImages (asset, *cgModel);
        importTextures (asset, *cgModel);
        importSamplers (asset, *cgModel);

        // CgMaterial support
        importCgImages (asset, *cgModel);
        importCgTextures (asset, *cgModel);
        importCgSamplers (asset, *cgModel);

        std::vector<Animation> animations = importAnimations (asset);

        return {cgModel, animations};
    }
    catch (const std::exception& e)
    {
        LOG (DBUG) << "Failed to load glTF file: " << filePath << ". Error: " << e.what();
        throw;
        //  return nullptr;
    }
}


// Asset loading and parsing implementation
fastgltf::Asset GLTFImporter::loadGLTF (const std::string& filePath)
{
    Expected<fastgltf::GltfDataBuffer> data = GltfDataBuffer::FromPath (filePath);
    Expected<Asset> asset (fastgltf::Error::None);

    // Set up parsing options and supported extensions
    auto options = fastgltf::Options::LoadExternalBuffers;
    auto extensions = fastgltf::Extensions::MSFT_packing_normalRoughnessMetallic |
                      fastgltf::Extensions::MSFT_packing_occlusionRoughnessMetallic;

    Parser parser (extensions);

    // Handle both .gltf and .glb formats
    switch (fastgltf::determineGltfFileType (data.get()))
    {
        case fastgltf::GltfType::glTF:
            asset = parser.loadGltf (data.get(), fs::path (filePath).parent_path(), options);
            break;

        case fastgltf::GltfType::GLB:
            asset = parser.loadGltfBinary (data.get(), fs::path (filePath).parent_path(), options);
            break;

        default:
            throw std::invalid_argument ("Error: Failed to determine glTF container type");
    }

    // Handle potential parsing errors
    if (asset.error() != fastgltf::Error::None)
    {
        std::string errorMsg = "Error loading glTF asset: ";
        switch (asset.error())
        {
            case fastgltf::Error::InvalidPath:
                errorMsg += "Invalid glTF directory path";
                break;
            case fastgltf::Error::MissingExtensions:
                errorMsg += "Required extensions not enabled in Parser";
                break;
            case fastgltf::Error::UnknownRequiredExtension:
                errorMsg += "Required extension not supported";
                break;
            case fastgltf::Error::InvalidJson:
                errorMsg += "JSON parsing error";
                break;
            case fastgltf::Error::InvalidGltf:
                errorMsg += "Missing or invalid data";
                break;
            case fastgltf::Error::InvalidGLB:
                errorMsg += "Invalid GLB container";
                break;
            case fastgltf::Error::MissingField:
                errorMsg += "Required field missing";
                break;
            case fastgltf::Error::InvalidFileData:
                errorMsg += "Invalid file data";
                break;
            default:
                errorMsg += "Unknown error occurred";
        }
        LOG (CRITICAL) << errorMsg;
        throw std::runtime_error (errorMsg);
    }

    return std::move (asset.get());
}

// Scene graph processing implementation
void GLTFImporter::processScenes (const fastgltf::Asset& asset)
{
    if (asset.scenes.empty())
    {
        LOG (CRITICAL) << "No scenes found in the glTF file";
        return;
    }

    // Use default scene or first scene if no default specified
    size_t sceneIndex = asset.defaultScene.value_or (0);
    const auto& scene = asset.scenes[sceneIndex];

    // Process each root node in the scene
    for (const auto& nodeIndex : scene.nodeIndices)
    {
        const auto& node = asset.nodes[nodeIndex];
        processNode (asset, node, Eigen::Affine3f::Identity());
    }
}

void GLTFImporter::processNode (const fastgltf::Asset& asset, const fastgltf::Node& node,
                                const Eigen::Affine3f& parentTransform)
{
    // Compute node's transform
    Eigen::Affine3f localTransform = computeLocalTransform (node);
    Eigen::Affine3f globalTransform = parentTransform * localTransform;

    // Process mesh if present
    if (node.meshIndex.has_value())
    {
        const auto& mesh = asset.meshes[node.meshIndex.value()];

        // Process each primitive in the mesh
        for (const auto& primitive : mesh.primitives)
        {
            CgModelPtr model = CgModel::create();
            importPrimitive (asset, mesh, primitive, globalTransform, *model);
            models.push_back (model);
        }
    }

    // Recursively process child nodes
    for (const auto& childIndex : node.children)
    {
        const auto& childNode = asset.nodes[childIndex];
        processNode (asset, childNode, globalTransform);
    }
}

// Geometry import implementations
void GLTFImporter::importPrimitive (const fastgltf::Asset& asset, const fastgltf::Mesh& mesh,
                                    const fastgltf::Primitive& primitive,
                                    const Eigen::Affine3f& transform, CgModel& model)
{
    // Import geometry data
    importVertices (asset, primitive, model);
    importIndices (asset, primitive, model);
    importNormals (asset, primitive, model);
    importUVs (asset, primitive, model);
    importMaterial (asset, primitive, model);

    // Apply transformation to vertices
    for (int i = 0; i < model.V.cols(); ++i)
    {
        Vector3f p = model.V.col (i);
        model.V.col (i) = transform * p;

        // Convert from right-handed to left-handed coordinate system
        Vector3f v = model.V.col (i);
        model.V.col (i) = Vector3f (v.x(), v.y(), v.z() * -1.0f);
    }

    // Transform normals if they exist
    if (model.N.cols() > 0)
    {
        Eigen::Matrix3f normalTransform = transform.linear().inverse().transpose();
        for (int i = 0; i < model.N.cols(); ++i)
        {
            model.N.col (i) = (normalTransform * model.N.col (i)).normalized();
        }
    }
}

void GLTFImporter::importVertices (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive,
                                   CgModel& model)
{
    auto it = primitive.findAttribute ("POSITION");
    if (it == primitive.attributes.end())
    {
        return;
    }

    const auto& accessor = asset.accessors[it->accessorIndex];
    if (!accessor.bufferViewIndex.has_value())
    {
        LOG (CRITICAL) << "Position accessor missing buffer view";
        return;
    }

    // Allocate vertex buffer
    std::size_t vertexCount = accessor.count;
    model.V.resize (3, vertexCount);
    std::size_t i = 0;

    // Read vertex data
    fastgltf::iterateAccessor<fastgltf::math::fvec3> (
        asset, accessor,
        [&] (auto&& v3)
        {
            model.V.col (i++) = Eigen::Vector3f (v3[0], v3[1], v3[2]);
        });
}

void GLTFImporter::importIndices (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive,
                                  CgModel& model)
{
    CgModelSurface surface;

    if (primitive.indicesAccessor.has_value())
    {
        const auto& accessor = asset.accessors[*primitive.indicesAccessor];
        std::size_t indexCount = accessor.count;
        surface.F.resize (3, indexCount / 3);

        // Read index data
        std::vector<uint32_t> indices (indexCount);
        fastgltf::iterateAccessorWithIndex<std::uint32_t> (
            asset, accessor,
            [&] (std::uint32_t index, size_t idx)
            {
                indices[idx] = index;
            });

        // Copy indices with winding order adjustment for LH coordinate system
        for (size_t i = 0; i < indexCount; i += 3)
        {
            surface.F.col (i / 3) << indices[i], indices[i + 2], indices[i + 1];
        }
    }

    model.S.push_back (std::move (surface));
}

void GLTFImporter::importNormals (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive,
                                  CgModel& model)
{
    auto it = primitive.findAttribute ("NORMAL");
    if (it == primitive.attributes.end())
    {
        return;
    }

    const auto& accessor = asset.accessors[it->accessorIndex];
    if (!accessor.bufferViewIndex.has_value())
    {
        LOG (CRITICAL) << "Normal accessor missing buffer view";
        return;
    }

    // Allocate normal buffer
    std::size_t normalCount = accessor.count;
    model.N.resize (3, normalCount);
    std::size_t i = 0;

    // Read normal data
    fastgltf::iterateAccessor<fastgltf::math::fvec3> (
        asset, accessor,
        [&] (auto&& v3)
        {
            model.N.col (i++) = Eigen::Vector3f (v3[0], v3[1], v3[2]);
        });
}

void GLTFImporter::importUVs (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive,
                              CgModel& model)
{
    auto it = primitive.findAttribute ("TEXCOORD_0");
    if (it == primitive.attributes.end())
    {
        return;
    }

    const auto& accessor = asset.accessors[it->accessorIndex];
    if (!accessor.bufferViewIndex.has_value())
    {
        LOG (CRITICAL) << "UV accessor missing buffer view";
        return;
    }

    // Allocate UV buffer
    std::size_t uvCount = accessor.count;
    model.UV0.resize (2, uvCount);
    std::size_t i = 0;

    // Read UV data
    fastgltf::iterateAccessor<fastgltf::math::fvec2> (
        asset, accessor,
        [&] (auto&& v2)
        {
            model.UV0.col (i++) = Eigen::Vector2f (v2[0], v2[1]);
        });
}
void GLTFImporter::importMaterial (const fastgltf::Asset& asset,
                                   const fastgltf::Primitive& primitive,
                                   sabi::CgModel& model)
{
    if (!primitive.materialIndex.has_value())
    {
        LOG (DBUG) << "Primitive does not have a material";
        if (!model.S.empty())
        {
            model.S.back().name = generateUniqueName ("Default_Surface");
        }
        return;
    }

    const auto& gltfMaterial = asset.materials[primitive.materialIndex.value()];
    sabi::Material material;

    // Set basic material properties
    std::string materialName = std::string (gltfMaterial.name);
    material.name = generateUniqueName (materialName.empty() ? "Material" : materialName);

    // Import CgMaterial properties
    auto& cgMaterial = model.S.back().cgMaterial;
    cgMaterial.name = material.name;
    cgMaterial.doubleSided = gltfMaterial.doubleSided;
    cgMaterial.flags.unlit = gltfMaterial.unlit;
    cgMaterial.flags.alphaMode = static_cast<sabi::AlphaMode> (gltfMaterial.alphaMode);
    cgMaterial.flags.alphaCutoff = gltfMaterial.alphaCutoff;

    // Import all material properties
    importCoreMaterialProperties (asset, gltfMaterial, cgMaterial.core);
    importMetallicProperties (asset, gltfMaterial, cgMaterial.metallic);
    importSheenProperties (asset, gltfMaterial, cgMaterial.sheen);
    importTranslucencyProperties (asset, gltfMaterial, cgMaterial.translucency);
    importSubsurfaceProperties (asset, gltfMaterial, cgMaterial.subsurface);
    importEmissionProperties (asset, gltfMaterial, cgMaterial.emission);
    importClearcoatProperties (asset, gltfMaterial, cgMaterial.clearcoat);
    importTransparencyProperties (asset, gltfMaterial, cgMaterial.transparency);
    importPackedTextures (asset, gltfMaterial, cgMaterial.packedTextures);

    // Handle normal texture
    if (gltfMaterial.normalTexture)
    {
        sabi::CgTextureInfo normalTextureInfo = importCgTextureInfo (asset, gltfMaterial.normalTexture.value());
        normalTextureInfo.scale = gltfMaterial.normalTexture->scale;
        cgMaterial.normalTexture = std::move (normalTextureInfo);
    }

    // Handle occlusion texture
    if (gltfMaterial.occlusionTexture)
    {
        sabi::CgTextureInfo occlusionTextureInfo = importCgTextureInfo (asset, gltfMaterial.occlusionTexture.value());
        occlusionTextureInfo.strength = gltfMaterial.occlusionTexture->strength;
        cgMaterial.occlusionTexture = std::move (occlusionTextureInfo);
    }

    // Apply material to surface
    if (!model.S.empty())
    {
        model.S.back().material = material;
        model.S.back().name = generateUniqueName (material.name + "_Surface");
    }
    else
    {
        LOG (CRITICAL) << "No surface available to assign material";
    }
}
#if 0
void GLTFImporter::importMaterial (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive,
                                   sabi::CgModel& model)
{
    if (!primitive.materialIndex.has_value())
    {
        LOG (DBUG) << "Primitive does not have a material";
        if (!model.S.empty())
        {
            model.S.back().name = generateUniqueName ("Default_Surface");
        }
        return;
    }

    const auto& gltfMaterial = asset.materials[primitive.materialIndex.value()];
    sabi::Material material;

    // Set basic material properties
    std::string materialName = std::string (gltfMaterial.name);
    material.name = generateUniqueName (materialName.empty() ? "Material" : materialName);

    // Import material properties
    auto& cgMaterial = model.S.back().cgMaterial;
    cgMaterial.name = material.name;
    cgMaterial.doubleSided = gltfMaterial.doubleSided;
    cgMaterial.flags.unlit = gltfMaterial.unlit;
    cgMaterial.flags.alphaMode = static_cast<sabi::AlphaMode> (gltfMaterial.alphaMode);
    cgMaterial.flags.alphaCutoff = gltfMaterial.alphaCutoff;

    // Import all material properties
    importCoreMaterialProperties (asset, gltfMaterial, cgMaterial.core);
    importMetallicProperties (asset, gltfMaterial, cgMaterial.metallic);
    importSheenProperties (asset, gltfMaterial, cgMaterial.sheen);
    importTranslucencyProperties (asset, gltfMaterial, cgMaterial.translucency);
    importSubsurfaceProperties (asset, gltfMaterial, cgMaterial.subsurface);
    importEmissionProperties (asset, gltfMaterial, cgMaterial.emission);
    importClearcoatProperties (asset, gltfMaterial, cgMaterial.clearcoat);
    importTransparencyProperties (asset, gltfMaterial, cgMaterial.transparency);
    importPackedTextures (asset, gltfMaterial, cgMaterial.packedTextures);

    // Apply material to surface
    if (!model.S.empty())
    {
        model.S.back().material = material;
        model.S.back().name = generateUniqueName (material.name + "_Surface");
    }
    else
    {
        LOG (CRITICAL) << "No surface available to assign material";
    }
}

#endif
void GLTFImporter::importCoreMaterialProperties (const fastgltf::Asset& asset,
                                                 const fastgltf::Material& gltfMaterial,
                                                 sabi::CgMaterial::CoreProperties& core)
{
    // Base color
    core.baseColor = {
        gltfMaterial.pbrData.baseColorFactor[0],
        gltfMaterial.pbrData.baseColorFactor[1],
        gltfMaterial.pbrData.baseColorFactor[2]};

    core.roughness = gltfMaterial.pbrData.roughnessFactor;
    core.specular = 0.5f;

    // Import base color texture
    if (gltfMaterial.pbrData.baseColorTexture)
    {
        core.baseColorTexture = importCgTextureInfo (asset, gltfMaterial.pbrData.baseColorTexture.value());
    }

    // Import roughness texture
    if (gltfMaterial.pbrData.metallicRoughnessTexture)
    {
        core.roughnessTexture = importCgTextureInfo (asset, gltfMaterial.pbrData.metallicRoughnessTexture.value());
    }

    
}

#if 0
void GLTFImporter::importCoreMaterialProperties (const fastgltf::Asset& asset,
                                                 const fastgltf::Material& gltfMaterial,
                                                 sabi::CgMaterial::CoreProperties& core)
{
    // Set base color
    core.baseColor = {
        gltfMaterial.pbrData.baseColorFactor[0],
        gltfMaterial.pbrData.baseColorFactor[1],
        gltfMaterial.pbrData.baseColorFactor[2]};

    // Set roughness and specular properties
    core.roughness = gltfMaterial.pbrData.roughnessFactor;
    core.specular = 0.5f; // Default value as glTF PBR doesn't have direct specular

    // Import textures
    if (gltfMaterial.pbrData.baseColorTexture)
    {
        core.baseColorTexture = importCgTextureInfo (asset, gltfMaterial.pbrData.baseColorTexture.value());
    }

    if (gltfMaterial.pbrData.metallicRoughnessTexture)
    {
        core.roughnessTexture = importCgTextureInfo (asset, gltfMaterial.pbrData.metallicRoughnessTexture.value());
    }
}

#endif

void GLTFImporter::importMetallicProperties (const fastgltf::Asset& asset,
                                             const fastgltf::Material& gltfMaterial,
                                             sabi::CgMaterial::MetallicProperties& metallic)
{
    metallic.metallic = gltfMaterial.pbrData.metallicFactor;

    // Handle anisotropic properties if present
    if (gltfMaterial.anisotropy)
    {
        metallic.anisotropic = gltfMaterial.anisotropy->anisotropyStrength;
        metallic.anisotropicRotation = gltfMaterial.anisotropy->anisotropyRotation;

        if (gltfMaterial.anisotropy->anisotropyTexture)
        {
            metallic.anisotropicTexture = importCgTextureInfo (asset,
                                                               gltfMaterial.anisotropy->anisotropyTexture.value());
        }
    }

    // Import metallic texture if present
    if (gltfMaterial.pbrData.metallicRoughnessTexture)
    {
        metallic.metallicTexture = importCgTextureInfo (asset,
                                                        gltfMaterial.pbrData.metallicRoughnessTexture.value());
    }
}

void GLTFImporter::importSheenProperties (const fastgltf::Asset& asset,
                                          const fastgltf::Material& gltfMaterial,
                                          sabi::CgMaterial::SheenProperties& sheen)
{
    if (gltfMaterial.sheen)
    {
        sheen.sheenColorFactor = Eigen::Vector3f (
            gltfMaterial.sheen->sheenColorFactor.x(),
            gltfMaterial.sheen->sheenColorFactor.y(),
            gltfMaterial.sheen->sheenColorFactor.z());
        sheen.sheenRoughnessFactor = gltfMaterial.sheen->sheenRoughnessFactor;

        if (gltfMaterial.sheen->sheenColorTexture)
        {
            sheen.sheenColorTexture = importCgTextureInfo (asset,
                                                           gltfMaterial.sheen->sheenColorTexture.value());
        }
        if (gltfMaterial.sheen->sheenRoughnessTexture)
        {
            sheen.sheenRoughnessTexture = importCgTextureInfo (asset,
                                                               gltfMaterial.sheen->sheenRoughnessTexture.value());
        }
    }
}

void GLTFImporter::importTranslucencyProperties (const fastgltf::Asset& asset,
                                                 const fastgltf::Material& gltfMaterial,
                                                 sabi::CgMaterial::TranslucencyProperties& translucency)
{
    // glTF doesn't have direct translucency properties
    // Set reasonable defaults or map from other properties if needed
    translucency.translucency = 0.0f;
    //translucency.scatterDistance = 0.0f;
}

void GLTFImporter::importSubsurfaceProperties (const fastgltf::Asset& asset,
                                               const fastgltf::Material& gltfMaterial,
                                               sabi::CgMaterial::SubsurfaceProperties& subsurface)
{
    if (gltfMaterial.volume)
    {
        subsurface.subsurface = gltfMaterial.volume->thicknessFactor;
        subsurface.subsurfaceColor = {
            gltfMaterial.volume->attenuationColor[0],
            gltfMaterial.volume->attenuationColor[1],
            gltfMaterial.volume->attenuationColor[2]};
        subsurface.subsurfaceDistance = gltfMaterial.volume->attenuationDistance;

        if (gltfMaterial.volume->thicknessTexture)
        {
            subsurface.subsurfaceColorTexture = importCgTextureInfo (asset,
                                                                     gltfMaterial.volume->thicknessTexture.value());
        }
    }

    subsurface.asymmetry = 0.0f; // Not directly supported in glTF
}

void GLTFImporter::importEmissionProperties (const fastgltf::Asset& asset,
                                             const fastgltf::Material& gltfMaterial,
                                             sabi::CgMaterial::EmissionProperties& emission)
{
    emission.luminous = gltfMaterial.emissiveStrength;
    emission.luminousColor = {
        gltfMaterial.emissiveFactor[0],
        gltfMaterial.emissiveFactor[1],
        gltfMaterial.emissiveFactor[2]};

    if (gltfMaterial.emissiveTexture)
    {
        emission.luminousTexture = importCgTextureInfo (asset,
                                                        gltfMaterial.emissiveTexture.value());
    }
}

void GLTFImporter::importClearcoatProperties (const fastgltf::Asset& asset,
                                              const fastgltf::Material& gltfMaterial,
                                              sabi::CgMaterial::ClearcoatProperties& clearcoat)
{
    if (gltfMaterial.clearcoat)
    {
        clearcoat.clearcoat = gltfMaterial.clearcoat->clearcoatFactor;
        clearcoat.clearcoatGloss = gltfMaterial.clearcoat->clearcoatRoughnessFactor;

        if (gltfMaterial.clearcoat->clearcoatTexture)
        {
            clearcoat.clearcoatTexture = importCgTextureInfo (asset,
                                                              gltfMaterial.clearcoat->clearcoatTexture.value());
        }

        if (gltfMaterial.clearcoat->clearcoatRoughnessTexture)
        {
            clearcoat.clearcoatRoughnessTexture = importCgTextureInfo (asset,
                                                                       gltfMaterial.clearcoat->clearcoatRoughnessTexture.value());
        }

        if (gltfMaterial.clearcoat->clearcoatNormalTexture)
        {
            clearcoat.clearcoatNormalTexture = importCgTextureInfo (asset,
                                                                    gltfMaterial.clearcoat->clearcoatNormalTexture.value());
        }
    }
}

void GLTFImporter::importTransparencyProperties (const fastgltf::Asset& asset,
                                                 const fastgltf::Material& gltfMaterial,
                                                 sabi::CgMaterial::TransparencyProperties& transparency)
{
    if (gltfMaterial.transmission)
    {
        transparency.transparency = gltfMaterial.transmission->transmissionFactor;

        if (gltfMaterial.transmission->transmissionTexture)
        {
            transparency.transparencyTexture = importCgTextureInfo (asset,
                                                                    gltfMaterial.transmission->transmissionTexture.value());
        }
    }

    transparency.refractionIndex = gltfMaterial.ior > 1.0f ? gltfMaterial.ior : 1.45f;
    transparency.thin = false;
    transparency.transmittance = {0.5f, 0.5f, 0.5f};
    transparency.transmittanceDistance = 1.0f;
}

void GLTFImporter::importPackedTextures (const fastgltf::Asset& asset,
                                         const fastgltf::Material& gltfMaterial,
                                         sabi::CgMaterial::PackedTextureProperties& packedTextures)
{
    if (gltfMaterial.packedOcclusionRoughnessMetallicTextures)
    {
        const auto& packedTexturesData = *gltfMaterial.packedOcclusionRoughnessMetallicTextures;

        // Handle ORM combined texture (Occlusion-Roughness-Metallic)
        if (packedTexturesData.occlusionRoughnessMetallicTexture)
        {
            packedTextures.occlusionRoughnessMetallicTexture = importCgTextureInfo (asset,
                                                                                    packedTexturesData.occlusionRoughnessMetallicTexture.value());
        }

        // Handle RMO combined texture (Roughness-Metallic-Occlusion)
        if (packedTexturesData.roughnessMetallicOcclusionTexture)
        {
            packedTextures.roughnessMetallicOcclusionTexture = importCgTextureInfo (asset,
                                                                                    packedTexturesData.roughnessMetallicOcclusionTexture.value());
        }

        // Handle normal texture from packed textures
        if (packedTexturesData.normalTexture)
        {
            packedTextures.normalRoughnessMetallicTexture = importCgTextureInfo (asset,
                                                                                 packedTexturesData.normalTexture.value());
        }
    }

    if (gltfMaterial.packedNormalMetallicRoughnessTexture)
    {
        packedTextures.normalRoughnessMetallicTexture = importCgTextureInfo (asset,
                                                                             gltfMaterial.packedNormalMetallicRoughnessTexture.value());
    }
}

void GLTFImporter::importImages (const fastgltf::Asset& asset, CgModel& model)
{
    model.images.reserve (asset.images.size());

    size_t index = 0;
    for (const auto& gltfImage : asset.images)
    {
        sabi::Image sabiImage;
        sabiImage.name = gltfImage.name;
        sabiImage.index = index;

        // Temporary storage for extracted image data
        std::vector<unsigned char> extractedImageBytes;
        std::uint32_t width, height, channels;
        std::string imageId;

        // Extract image data from GLTF source
        extractImageData (asset, sabiImage, gltfImage, index++,
                          extractedImageBytes, width, height, channels, imageId);

        // If we successfully extracted image data, store it in an ImageBuf
        if (extractedImageBytes.size())
        {
            OIIO::ImageSpec spec (width, height, channels, OIIO::TypeDesc::UINT8);
            OIIO::ImageBuf imageBuf (spec, extractedImageBytes.data());
            sabiImage.extractedImage = imageBuf;
        }

        model.images.push_back (std::move (sabiImage));
    }
}

void GLTFImporter::importCgImages (const fastgltf::Asset& asset, sabi::CgModel& model)
{
    model.cgImages.reserve (asset.images.size());

    size_t index = 0;
    for (const auto& gltfImage : asset.images)
    {
        sabi::CgImage cgImage;
        cgImage.name = gltfImage.name;
        cgImage.index = index;

        // Temporary storage for extracted image data
        std::vector<unsigned char> extractedImageBytes;
        std::uint32_t width, height, channels;
        std::string imageId;

        // Extract image data from GLTF source
        extractImageData (asset, cgImage, gltfImage, index++,
                          extractedImageBytes, width, height, channels, imageId);

        // If we successfully extracted image data, store it in an ImageBuf
        if (extractedImageBytes.size())
        {
            OIIO::ImageSpec spec (width, height, channels, OIIO::TypeDesc::UINT8);
            OIIO::ImageBuf imageBuf (spec, extractedImageBytes.data());
            cgImage.extractedImage = imageBuf;
        }

        model.cgImages.push_back (std::move (cgImage));
    }
}

void GLTFImporter::importTextures (const fastgltf::Asset& asset, CgModel& model)
{
    model.textures.reserve (asset.textures.size());

    for (const auto& gltfTexture : asset.textures)
    {
        sabi::Texture texture;

        // Copy basic properties
        texture.name = gltfTexture.name;
        texture.source = gltfTexture.imageIndex.value_or (-1);
        texture.sampler = gltfTexture.samplerIndex.value_or (-1);

        model.textures.push_back (std::move (texture));
    }

    LOG (DBUG) << "Imported " << model.textures.size() << " textures";
}

void GLTFImporter::importCgTextures (const fastgltf::Asset& asset, sabi::CgModel& model)
{
    model.cgTextures.reserve (asset.textures.size());

    for (const auto& gltfTexture : asset.textures)
    {
        sabi::CgTexture texture;

        // Copy basic properties
        texture.name = gltfTexture.name;
        texture.imageIndex = gltfTexture.imageIndex;
        texture.samplerIndex = gltfTexture.samplerIndex;

        // Copy extended format indices
        texture.basisuImageIndex = gltfTexture.basisuImageIndex;
        texture.ddsImageIndex = gltfTexture.ddsImageIndex;
        texture.webpImageIndex = gltfTexture.webpImageIndex;

        model.cgTextures.push_back (std::move (texture));
    }

    LOG (DBUG) << "Imported " << model.cgTextures.size() << " CG textures";
}

void GLTFImporter::importSamplers (const fastgltf::Asset& asset, CgModel& model)
{
    model.samplers.reserve (asset.samplers.size());

    for (const auto& gltfSampler : asset.samplers)
    {
        sabi::Sampler sampler;

        // Copy basic properties
        sampler.name = gltfSampler.name;

        // Handle optional magFilter and minFilter
        sampler.magFilter = gltfSampler.magFilter.has_value() ? static_cast<int> (gltfSampler.magFilter.value()) : INVALID_INDEX;

        sampler.minFilter = gltfSampler.minFilter.has_value() ? static_cast<int> (gltfSampler.minFilter.value()) : INVALID_INDEX;

        // Handle wrap modes
        sampler.wrapS = static_cast<int> (gltfSampler.wrapS);
        sampler.wrapT = static_cast<int> (gltfSampler.wrapT);

        model.samplers.push_back (std::move (sampler));
    }

    LOG (DBUG) << "Imported " << model.samplers.size() << " samplers";
}

void GLTFImporter::importCgSamplers (const fastgltf::Asset& asset, CgModel& model)
{
    model.cgSamplers.reserve (asset.samplers.size());

    for (const auto& gltfSampler : asset.samplers)
    {
        sabi::CgSampler sampler;

        // Copy basic properties
        sampler.name = gltfSampler.name;

        // Handle optional magFilter and minFilter with CgFilter types
        sampler.magFilter = gltfSampler.magFilter.has_value() ? static_cast<sabi::CgFilter> (gltfSampler.magFilter.value()) : sabi::CgFilter::Linear;

        sampler.minFilter = gltfSampler.minFilter.has_value() ? static_cast<sabi::CgFilter> (gltfSampler.minFilter.value()) : sabi::CgFilter::Linear;

        // Handle wrap modes with CgWrap types
        sampler.wrapS = static_cast<sabi::CgWrap> (gltfSampler.wrapS);
        sampler.wrapT = static_cast<sabi::CgWrap> (gltfSampler.wrapT);

        model.cgSamplers.push_back (std::move (sampler));
    }

    LOG (DBUG) << "Imported " << model.cgSamplers.size() << " CG samplers";
}

void GLTFImporter::extractImageData (const fastgltf::Asset& asset, sabi::Image& sabiImage,
                                     const fastgltf::Image& image, size_t imageIndex,
                                     std::vector<unsigned char>& imageBytes, std::uint32_t& width,
                                     std::uint32_t& height, std::uint32_t& channels,
                                     std::string& imageIdentifier)
{
    imageIdentifier = getImageIdentifier (asset, imageIndex);
    imageBytes.clear();
    width = height = channels = 0;

    // Handle different image source types
    std::visit ([&] (const auto& source)
                {
        using T = std::decay_t<decltype(source)>;
        
        if constexpr (std::is_same_v<T, fastgltf::sources::BufferView>) {
            const auto& bufferView = asset.bufferViews[source.bufferViewIndex];
            const auto& buffer = asset.buffers[bufferView.bufferIndex];

            std::visit([&](const auto& bufferSource) {
                using BufferT = std::decay_t<decltype(bufferSource)>;
                if constexpr (std::is_same_v<BufferT, fastgltf::sources::Array>) {
                    if (bufferView.byteOffset + bufferView.byteLength <= bufferSource.bytes.size()) {
                        imageBytes.resize(bufferView.byteLength);
                        std::transform(
                            bufferSource.bytes.begin() + bufferView.byteOffset,
                            bufferSource.bytes.begin() + bufferView.byteOffset + bufferView.byteLength,
                            imageBytes.begin(),
                            [](std::byte b) { return static_cast<unsigned char>(b); });
                    }
                }
            }, buffer.data);
        }
        else if constexpr (std::is_same_v<T, fastgltf::sources::URI>) {
            sabiImage.uri = source.uri.string();
            sabiImage.mimeType = fastgltf::getMimeTypeString(source.mimeType);
            LOG(DBUG) << "Stored image URI: " << sabiImage.uri;
        }
        else if constexpr (std::is_same_v<T, fastgltf::sources::Vector> || 
                          std::is_same_v<T, fastgltf::sources::Array>) {
            sabiImage.mimeType = fastgltf::getMimeTypeString(source.mimeType);
            auto start = reinterpret_cast<const unsigned char*>(source.bytes.data());
            imageBytes.assign(start, start + source.bytes.size());
        } },
                image.data);

    // Process image data if available
    if (!imageBytes.empty())
    {
        int w, h, c;
        unsigned char* decodedData = stbi_load_from_memory (
            imageBytes.data(),
            static_cast<int> (imageBytes.size()),
            &w, &h, &c, 0);

        if (decodedData)
        {
            width = static_cast<std::uint32_t> (w);
            height = static_cast<std::uint32_t> (h);
            channels = static_cast<std::uint32_t> (c);
            imageBytes.assign (decodedData, decodedData + (width * height * channels));
            stbi_image_free (decodedData);
        }
    }
}

void GLTFImporter::extractImageData (const fastgltf::Asset& asset, sabi::CgImage& sabiImage,
                                     const fastgltf::Image& image, size_t imageIndex,
                                     std::vector<unsigned char>& imageBytes, std::uint32_t& width,
                                     std::uint32_t& height, std::uint32_t& channels,
                                     std::string& imageIdentifier)
{
    // This implementation is identical to the above but operates on CgImage
    // Reuse the same implementation pattern but with CgImage specific features
    imageIdentifier = getImageIdentifier (asset, imageIndex);
    imageBytes.clear();
    width = height = channels = 0;

    std::visit ([&] (const auto& source)
                {
        using T = std::decay_t<decltype(source)>;
        
        if constexpr (std::is_same_v<T, fastgltf::sources::BufferView>) {
            // Same as above implementation
            const auto& bufferView = asset.bufferViews[source.bufferViewIndex];
            const auto& buffer = asset.buffers[bufferView.bufferIndex];

            std::visit([&](const auto& bufferSource) {
                using BufferT = std::decay_t<decltype(bufferSource)>;
                if constexpr (std::is_same_v<BufferT, fastgltf::sources::Array>) {
                    if (bufferView.byteOffset + bufferView.byteLength <= bufferSource.bytes.size()) {
                        imageBytes.resize(bufferView.byteLength);
                        std::transform(
                            bufferSource.bytes.begin() + bufferView.byteOffset,
                            bufferSource.bytes.begin() + bufferView.byteOffset + bufferView.byteLength,
                            imageBytes.begin(),
                            [](std::byte b) { return static_cast<unsigned char>(b); });
                    }
                }
            }, buffer.data);
        }
        else if constexpr (std::is_same_v<T, fastgltf::sources::URI>) {
            sabiImage.uri = source.uri.string();
            sabiImage.mimeType = fastgltf::getMimeTypeString(source.mimeType);
        }
        else if constexpr (std::is_same_v<T, fastgltf::sources::Vector> || 
                          std::is_same_v<T, fastgltf::sources::Array>) {
            sabiImage.mimeType = fastgltf::getMimeTypeString(source.mimeType);
            auto start = reinterpret_cast<const unsigned char*>(source.bytes.data());
            imageBytes.assign(start, start + source.bytes.size());
        } },
                image.data);

    if (!imageBytes.empty())
    {
        int w, h, c;
        unsigned char* decodedData = stbi_load_from_memory (
            imageBytes.data(),
            static_cast<int> (imageBytes.size()),
            &w, &h, &c, 0);

        if (decodedData)
        {
            width = static_cast<std::uint32_t> (w);
            height = static_cast<std::uint32_t> (h);
            channels = static_cast<std::uint32_t> (c);
            imageBytes.assign (decodedData, decodedData + (width * height * channels));
            stbi_image_free (decodedData);
        }
    }
}

std::string GLTFImporter::mimeTypeToString (fastgltf::MimeType mimeType)
{
    switch (mimeType)
    {
        case fastgltf::MimeType::JPEG:
            return "image/jpeg";
        case fastgltf::MimeType::PNG:
            return "image/png";
        case fastgltf::MimeType::KTX2:
            return "image/ktx2";
        case fastgltf::MimeType::DDS:
            return "image/vnd-ms.dds";
        case fastgltf::MimeType::GltfBuffer:
            return "application/gltf-buffer";
        case fastgltf::MimeType::OctetStream:
            return "application/octet-stream";
        default:
            return "unknown";
    }
}

std::string GLTFImporter::getImageIdentifier (const fastgltf::Asset& asset, size_t imageIndex)
{
    const auto& image = asset.images[imageIndex];
    std::string mimeTypeStr = "unknown";
    size_t byteLength = 0;

    std::visit ([&] (const auto& source)
                {
        using T = std::decay_t<decltype(source)>;
        if constexpr (std::is_same_v<T, fastgltf::sources::BufferView>) {
            const auto& bufferView = asset.bufferViews[source.bufferViewIndex];
            byteLength = bufferView.byteLength;
            mimeTypeStr = mimeTypeToString(source.mimeType);
        }
        else if constexpr (std::is_same_v<T, fastgltf::sources::URI>) {
            mimeTypeStr = mimeTypeToString(source.mimeType);
        } },
                image.data);

    return "Image_" + std::to_string (imageIndex) + "_" +
           mimeTypeStr + "_" + std::to_string (byteLength);
}

std::string GLTFImporter::generateUniqueName (const std::string& baseName)
{
    std::string uniqueName = baseName;
    int counter = 1;

    while (usedNames.find (uniqueName) != usedNames.end())
    {
        uniqueName = baseName + "_" + std::to_string (counter++);
    }
    usedNames.insert (uniqueName);
    return uniqueName;
}


Eigen::Affine3f GLTFImporter::computeLocalTransform (const fastgltf::Node& node)
{
    if (std::holds_alternative<fastgltf::TRS> (node.transform))
    {
        const auto& trs = std::get<fastgltf::TRS> (node.transform);
        Eigen::Affine3f transform = Eigen::Affine3f::Identity();

        // Apply translation
        transform.translate (Eigen::Vector3f (trs.translation[0], trs.translation[1], trs.translation[2]));

        // Apply rotation
        Eigen::Quaternionf rotation (trs.rotation.w(), trs.rotation.x(), trs.rotation.y(), trs.rotation.z());
        transform.rotate (rotation);

        // Apply scale
        transform.scale (Eigen::Vector3f (trs.scale[0], trs.scale[1], trs.scale[2]));

        return transform;
    }
    else if (std::holds_alternative<fastgltf::math::fmat4x4> (node.transform))
    {
        const auto& matrix = std::get<fastgltf::math::fmat4x4> (node.transform);
        Eigen::Matrix4f eigenMatrix;
        for (int i = 0; i < 4; ++i)
        {
            for (int j = 0; j < 4; ++j)
            {
                eigenMatrix (i, j) = matrix[j][i]; // Note the swapped indices
            }
        }
        return Eigen::Affine3f (eigenMatrix);
    }

    return Eigen::Affine3f::Identity();
}

std::vector<Animation> GLTFImporter::importAnimations (const fastgltf::Asset& asset)
{
    std::vector<Animation> animations;
    animations.reserve (asset.animations.size());

    for (size_t i = 0; i < asset.animations.size(); ++i)
    {
        Animation animation;
        animation.name = asset.animations[i].name;
        animation.channels = animationExporter.exportAnimation (asset, i);
        animations.push_back (std::move (animation));
    }

    return animations;
}

CgModelPtr GLTFImporter::forgeIntoOne (const CgModelList& models)
{
    if (models.empty()) return nullptr;

    // Initialize counters for total vertices and triangles
    uint32_t totalVertices = 0;
    uint32_t totalTriangles = 0;

    // Calculate vertex offsets
    std::vector<uint32_t> vertexOffsets;
    vertexOffsets.reserve (models.size());
    vertexOffsets.push_back (totalVertices);

    // Create output model
    auto flattenedModel = CgModel::create();

    // First pass: count totals and verify data
    for (const auto& m : models)
    {
        totalVertices += m->V.cols();
        vertexOffsets.push_back (totalVertices);

        // Verify single surface per mesh constraint
        if (m->S.size() != 1)
        {
            LOG (CRITICAL) << "Multiple surfaces found in mesh during merge";
            return nullptr;
        }

        totalTriangles += m->S[0].triangleCount();

        // Generate unique surface name
        auto& surface = m->S[0];
        surface.name = generateUniqueName (surface.name.empty() ? "Surface" : surface.name);

        flattenedModel->S.emplace_back (std::move (m->S[0]));
    }

    // Allocate vertex data
    flattenedModel->V.resize (3, totalVertices);
    if (models[0]->UV0.cols() > 0)
    {
        flattenedModel->UV0.resize (2, totalVertices);
    }

    // Copy vertex and UV data
    for (uint32_t index = 0; index < models.size(); ++index)
    {
        const auto& mesh = models[index];

        // Copy vertex data
        std::memcpy (flattenedModel->V.data() + vertexOffsets[index] * 3,
                     mesh->V.data(),
                     mesh->vertexCount() * 3 * sizeof (float));

        // Copy UV data if present
        if (mesh->UV0.cols() > 0)
        {
            std::memcpy (flattenedModel->UV0.data() + vertexOffsets[index] * 2,
                         mesh->UV0.data(),
                         mesh->vertexCount() * 2 * sizeof (float));
        }
    }

    // Update triangle indices
    for (uint32_t index = 0; index < flattenedModel->S.size(); ++index)
    {
        auto& s = flattenedModel->S[index];
        uint32_t vertexOffset = vertexOffsets[index];
        auto& tris = s.indices();

        for (int i = 0; i < s.triangleCount(); i++)
        {
            Vector3u tri = tris.col (i);
            for (int j = 0; j < 3; j++)
            {
                tri[j] += vertexOffset;
            }
            tris.col (i) = tri;
        }
    }

    return flattenedModel;
}

sabi::TextureInfo GLTFImporter::importTextureInfo (const fastgltf::Asset& asset, const fastgltf::TextureInfo& textureInfo)
{
    sabi::TextureInfo result;
    result.textureIndex = textureInfo.textureIndex;
    result.texCoord = textureInfo.texCoordIndex;
    return result;
}

sabi::CgTextureInfo GLTFImporter::importCgTextureInfo (const fastgltf::Asset& asset, const fastgltf::TextureInfo& textureInfo)
{
    sabi::CgTextureInfo result;
    result.textureIndex = textureInfo.textureIndex;
    result.texCoordIndex = textureInfo.texCoordIndex;

    if (textureInfo.transform)
    {
        auto transform = std::make_unique<sabi::CgTextureTransform>();
        transform->rotation = textureInfo.transform->rotation;
        transform->uvOffset = Eigen::Vector2f (textureInfo.transform->uvOffset[0], textureInfo.transform->uvOffset[1]);
        transform->uvScale = Eigen::Vector2f (textureInfo.transform->uvScale[0], textureInfo.transform->uvScale[1]);
        transform->texCoordIndex = textureInfo.transform->texCoordIndex;
        result.transform = std::move (transform);
    }

    return result;
}


#if 0

std::pair<CgModelPtr, std::vector<Animation>> GLTFImporter::importModel (const std::string& filePath)
{
    try
    {
        if (!fs::exists (filePath) || !fs::is_regular_file (filePath))
        {
            throw std::runtime_error ("File does not exist!");
        }

        auto asset = loadGLTF (filePath);

        processScenes (asset);
        if (models.size() == 0) return {nullptr, {}};

        CgModelPtr cgModel = models.size() > 1 ? forgeIntoOne (models) : models[0];
        if (!cgModel) return {nullptr, {}};

        importImages (asset, *cgModel);
        importTextures (asset, *cgModel);
        importSamplers (asset, *cgModel);

        // CgMaterial support
        importCgImages (asset, *cgModel);
        importCgTextures (asset, *cgModel);
        importCgSamplers (asset, *cgModel);


        std::vector<Animation> animations = importAnimations (asset);

        return {cgModel, animations};
    }
    catch (const std::exception& e)
    {
        LOG (DBUG) << "Failed to load glTF file: " << filePath << ". Error: " << e.what();
        throw;
        //  return nullptr;
    }
}

std::string GLTFImporter::generateUniqueName (const std::string& baseName)
{
    std::string uniqueName = baseName;
    int counter = 1;
    while (usedNames.find (uniqueName) != usedNames.end())
    {
        uniqueName = baseName + "_" + std::to_string (counter);
        counter++;
    }
    usedNames.insert (uniqueName);
    return uniqueName;
}

fastgltf::Asset GLTFImporter::loadGLTF (const std::string& filePath)
{
   

    Expected<fastgltf::GltfDataBuffer> data = GltfDataBuffer::FromPath (filePath);

    Expected<Asset> asset (fastgltf::Error::None);

    
    auto options = fastgltf::Options::LoadExternalBuffers;
    auto extensions = fastgltf::Extensions::MSFT_packing_normalRoughnessMetallic |
                      fastgltf::Extensions::MSFT_packing_occlusionRoughnessMetallic;

    // Initialize parser with extensions...
    Parser parser (extensions);

    switch (fastgltf::determineGltfFileType (data.get()))
    {
        case fastgltf::GltfType::glTF:
            asset = parser.loadGltf (data.get(), fs::path (filePath).parent_path(), options);
            break;

        case fastgltf::GltfType::GLB:
            asset = parser.loadGltfBinary (data.get(), fs::path (filePath).parent_path(), options);
            break;

        default:
            throw std::invalid_argument ("Error: Failed to determine glTF container.");
    }
    if (asset.error() != fastgltf::Error::None)
    {
        std::string errorMsg = "Error loading glTF asset: ";
        switch (asset.error())
        {
            case fastgltf::Error::InvalidPath:
                errorMsg += "Invalid glTF directory path.";
                break;
            case fastgltf::Error::MissingExtensions:
                errorMsg += "One or more required extensions are not enabled in the Parser.";
                break;
            case fastgltf::Error::UnknownRequiredExtension:
                errorMsg += "A required extension is not supported by fastgltf.";
                break;
            case fastgltf::Error::InvalidJson:
                errorMsg += "JSON parsing error occurred.";
                break;
            case fastgltf::Error::InvalidGltf:
                errorMsg += "The glTF file is missing required data or contains invalid data.";
                break;
            case fastgltf::Error::InvalidOrMissingAssetField:
                errorMsg += "The glTF asset object is missing or invalid.";
                break;
            case fastgltf::Error::InvalidGLB:
                errorMsg += "The GLB container is invalid.";
                break;
            case fastgltf::Error::MissingField:
                errorMsg += "A required field is missing in the JSON.";
                break;
            case fastgltf::Error::MissingExternalBuffer:
                errorMsg += "An external buffer was not found.";
                break;
            case fastgltf::Error::UnsupportedVersion:
                errorMsg += "The glTF version is not supported by fastgltf.";
                break;
            case fastgltf::Error::InvalidURI:
                errorMsg += "Failed to parse a URI from a buffer or image.";
                break;
            case fastgltf::Error::InvalidFileData:
                errorMsg += "The file data is invalid or the file type could not be determined.";
                break;
            case fastgltf::Error::FailedWritingFiles:
                errorMsg += "Failed to write some files (buffers/images) to disk.";
                break;
            case fastgltf::Error::FileBufferAllocationFailed:
                errorMsg += "Failed to allocate a sufficiently large buffer for file data.";
                break;
            default:
                errorMsg += "An unknown error occurred.";
        }
        LOG (CRITICAL) << errorMsg;
        throw std::runtime_error (errorMsg);
    }

    return std::move (asset.get());
}

void GLTFImporter::processScenes (const fastgltf::Asset& asset)
{
    if (asset.scenes.empty())
    {
        LOG (CRITICAL) << "No scenes found in the glTF file.";
        return;
    }

    size_t sceneIndex = asset.defaultScene.value_or (0);
    const auto& scene = asset.scenes[sceneIndex];

    for (const auto& nodeIndex : scene.nodeIndices)
    {
        const auto& node = asset.nodes[nodeIndex];
        processNode (asset, node, Eigen::Affine3f::Identity());
    }
}

void GLTFImporter::processNode (const fastgltf::Asset& asset, const fastgltf::Node& node, const Eigen::Affine3f& parentTransform)
{
    Eigen::Affine3f localTransform = computeLocalTransform (node);
    Eigen::Affine3f globalTransform = parentTransform * localTransform;

    if (node.meshIndex.has_value())
    {
        const auto& mesh = asset.meshes[node.meshIndex.value()];

        for (const auto& primitive : mesh.primitives)
        {
            CgModelPtr model = CgModel::create();
            importPrimitive (asset, mesh, primitive, globalTransform, *model);
            models.push_back (model);
        }
    }

    for (const auto& childIndex : node.children)
    {
        const auto& childNode = asset.nodes[childIndex];
        processNode (asset, childNode, globalTransform);
    }
}

void GLTFImporter::importPrimitive (const fastgltf::Asset& asset, const fastgltf::Mesh& mesh, const fastgltf::Primitive& primitive, const Eigen::Affine3f& transform, CgModel& model)
{
    importVertices (asset, primitive, model);
    importIndices (asset, primitive, model);
    importNormals (asset, primitive, model);
    importUVs (asset, primitive, model);
    importMaterial (asset, primitive, model);

    // Apply the global transformation to the vertices
    for (int i = 0; i < model.V.cols(); ++i)
    {
        Vector3f p = model.V.col (i);
        model.V.col (i) = transform * p;

        // instead of messing with trying to apply transforms using a Lefthand system
        // we'll just wait and convert to LH system after RH system transform is complete
        // by negate=ing the z component
        Vector3f v = model.V.col (i);
        model.V.col (i) = Vector3f (v.x(), v.y(), v.z() * -1.0f);
    }

    // Transform normals if they exist
    if (model.N.cols() > 0)
    {
        Eigen::Matrix3f normalTransform = transform.linear().inverse().transpose();
        for (int i = 0; i < model.N.cols(); ++i)
        {
            model.N.col (i) = (normalTransform * model.N.col (i)).normalized();
        }
    }
}

void GLTFImporter::importVertices (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive, CgModel& model)
{
    auto it = primitive.findAttribute ("POSITION");
    if (it != primitive.attributes.end())
    {
        const auto& accessor = asset.accessors[it->accessorIndex];
        if (!accessor.bufferViewIndex.has_value())
        {
            LOG (CRITICAL) << "Position accessor does not have a buffer view";
            return;
        }

        std::size_t vertexCount = accessor.count;
        model.V.resize (3, vertexCount);
        std::size_t i = 0;

        fastgltf::iterateAccessor<fastgltf::math::fvec3> (asset, accessor, [&] (auto&& v3)
                                                          { model.V.col (i++) = Eigen::Vector3f (v3[0], v3[1], v3[2]); });
    }
}

void GLTFImporter::importIndices (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive, CgModel& model)
{
    CgModelSurface surface;
    if (primitive.indicesAccessor.has_value())
    {
        const auto& accessor = asset.accessors[*primitive.indicesAccessor];
        std::size_t indexCount = accessor.count;
        surface.F.resize (3, indexCount / 3);

        std::vector<uint32_t> indices (indexCount);
        fastgltf::iterateAccessorWithIndex<std::uint32_t> (asset, accessor, [&] (std::uint32_t index, size_t idx)
                                                           { indices[idx] = index; });

        // negating the z coord and reversing winding order may have fixed all
        for (size_t i = 0; i < indexCount; i += 3)
        {
            // Reverse winding order for each triangle
            surface.F.col (i / 3) << indices[i], indices[i + 2], indices[i + 1];
        }
    }
    model.S.push_back (std::move (surface));
}

void GLTFImporter::importNormals (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive, CgModel& model)
{
    auto it = primitive.findAttribute ("NORMAL");
    if (it != primitive.attributes.end())
    {
        const auto& accessor = asset.accessors[it->accessorIndex];
        if (!accessor.bufferViewIndex.has_value())
        {
            LOG (CRITICAL) << "Normal accessor does not have a buffer view";
            return;
        }

        std::size_t normalCount = accessor.count;
        model.N.resize (3, normalCount);
        std::size_t i = 0;

        fastgltf::iterateAccessor<fastgltf::math::fvec3> (asset, accessor, [&] (auto&& v3)
                                                          { model.N.col (i++) = Eigen::Vector3f (v3[0], v3[1], v3[2]); });
    }
}

void GLTFImporter::importUVs (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive, CgModel& model)
{
    auto it = primitive.findAttribute ("TEXCOORD_0");
    if (it != primitive.attributes.end())
    {
        const auto& accessor = asset.accessors[it->accessorIndex];
        if (!accessor.bufferViewIndex.has_value())
        {
            LOG (CRITICAL) << "UV accessor does not have a buffer view";
            return;
        }

        std::size_t uvCount = accessor.count;
        model.UV0.resize (2, uvCount);
        std::size_t i = 0;

        fastgltf::iterateAccessor<fastgltf::math::fvec2> (asset, accessor, [&] (auto&& v2)
                                                          { model.UV0.col (i++) = Eigen::Vector2f (v2[0], v2[1]); });
    }
}

void GLTFImporter::importMaterial (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive, sabi::CgModel& model)
{
    static std::unordered_set<std::string> usedMaterialNames;

    if (primitive.materialIndex.has_value())
    {
        const auto& gltfMaterial = asset.materials[primitive.materialIndex.value()];
        sabi::Material material;

        // Set basic material properties
        std::string materialName = std::string (gltfMaterial.name);
        material.name = generateUniqueName (materialName.empty() ? "Material" : materialName);

        // PBR Metallic Roughness
        material.pbrMetallicRoughness.baseColorFactor = {
            gltfMaterial.pbrData.baseColorFactor[0],
            gltfMaterial.pbrData.baseColorFactor[1],
            gltfMaterial.pbrData.baseColorFactor[2],
            gltfMaterial.pbrData.baseColorFactor[3]};
        material.pbrMetallicRoughness.metallicFactor = gltfMaterial.pbrData.metallicFactor;
        material.pbrMetallicRoughness.roughnessFactor = gltfMaterial.pbrData.roughnessFactor;

        // Textures
        if (gltfMaterial.pbrData.baseColorTexture.has_value())
        {
            material.pbrMetallicRoughness.baseColorTexture = importTextureInfo (asset, gltfMaterial.pbrData.baseColorTexture.value());
        }
        if (gltfMaterial.pbrData.metallicRoughnessTexture.has_value())
        {
            material.pbrMetallicRoughness.metallicRoughnessTexture = importTextureInfo (asset, gltfMaterial.pbrData.metallicRoughnessTexture.value());
        }

        // Normal Texture
        if (gltfMaterial.normalTexture.has_value())
        {
            material.normalTexture = importTextureInfo (asset, gltfMaterial.normalTexture.value());
            if (material.normalTexture.has_value())
            {
                material.normalTexture->scale = gltfMaterial.normalTexture->scale;
            }
        }

        // Occlusion Texture
        if (gltfMaterial.occlusionTexture.has_value())
        {
            material.occlusionTexture = importTextureInfo (asset, gltfMaterial.occlusionTexture.value());
            if (material.occlusionTexture.has_value())
            {
                material.occlusionTexture->strength = gltfMaterial.occlusionTexture->strength;
            }
        }

        // Emissive Texture
        if (gltfMaterial.emissiveTexture.has_value())
        {
            material.emissiveTexture = importTextureInfo (asset, gltfMaterial.emissiveTexture.value());
        }

        // Emissive Factor
        material.emissiveFactor = {
            gltfMaterial.emissiveFactor[0],
            gltfMaterial.emissiveFactor[1],
            gltfMaterial.emissiveFactor[2]};

        // Add CgMaterial properties here
        auto& cgMaterial = model.S.back().cgMaterial;

        // Set basic material properties
        cgMaterial.name = material.name;
        cgMaterial.doubleSided = gltfMaterial.doubleSided;
        cgMaterial.flags.unlit = gltfMaterial.unlit;
        cgMaterial.flags.alphaMode = static_cast<sabi::AlphaMode> (gltfMaterial.alphaMode); // Assuming AlphaMode is in sabi namespace
        cgMaterial.flags.alphaCutoff = gltfMaterial.alphaCutoff;

        // Import Core Properties
        importCoreMaterialProperties (asset, gltfMaterial, cgMaterial.core);

        // Import Metallic Properties (including anisotropy)
        importMetallicProperties (asset, gltfMaterial, cgMaterial.metallic);

        // Add the material to the appropriate surface
        if (!model.S.empty())
        {
            model.S.back().material = material;
            model.S.back().name = generateUniqueName (material.name + "_Surface");
        }
        else
        {
            LOG (CRITICAL) << "No surface available to assign material";
        }
    }
    else
    {
        LOG (DBUG) << "Primitive does not have a material";
        if (!model.S.empty())
        {
            model.S.back().name = generateUniqueName ("Default_Surface");
        }
    }
}
sabi::TextureInfo GLTFImporter::importTextureInfo (const fastgltf::Asset& asset, const fastgltf::TextureInfo& textureInfo)
{
    sabi::TextureInfo result;
    result.textureIndex = textureInfo.textureIndex;
    result.texCoord = textureInfo.texCoordIndex;
    return result;
}

std::string GLTFImporter::mimeTypeToString (fastgltf::MimeType mimeType)
{
    switch (mimeType)
    {
        case fastgltf::MimeType::JPEG:
            return "image/jpeg";
        case fastgltf::MimeType::PNG:
            return "image/png";
        case fastgltf::MimeType::KTX2:
            return "image/ktx2";
        case fastgltf::MimeType::DDS:
            return "image/vnd-ms.dds";
        case fastgltf::MimeType::GltfBuffer:
            return "application/gltf-buffer";
        case fastgltf::MimeType::OctetStream:
            return "application/octet-stream";
        default:
            return "unknown";
    }
}

std::string GLTFImporter::getImageIdentifier (const fastgltf::Asset& asset, size_t imageIndex)
{
    const auto& image = asset.images[imageIndex];
    std::string mimeTypeStr = "unknown";
    size_t byteLength = 0;

    std::visit ([&] (const auto& source)
                {
                    using T = std::decay_t<decltype (source)>;
                    if constexpr (std::is_same_v<T, fastgltf::sources::BufferView>)
                    {
                        const auto& bufferView = asset.bufferViews[source.bufferViewIndex];
                        byteLength = bufferView.byteLength;
                        mimeTypeStr = mimeTypeToString (source.mimeType);
                    }
                    else if constexpr (std::is_same_v<T, fastgltf::sources::URI>)
                    {
                        mimeTypeStr = mimeTypeToString (source.mimeType);
                        // Note: byteLength might not be available for URI sources
                    }
                    // Handle other source types if necessary
                },
                image.data);

    return "Image_" + std::to_string (imageIndex) + "_" +
           mimeTypeStr + "_" + std::to_string (byteLength);
}


 void GLTFImporter::extractImageData (const fastgltf::Asset& asset, sabi::CgImage& sabiImage, const fastgltf::Image& image,
                                     size_t imageIndex, std::vector<unsigned char>& imageBytes,
                                     std::uint32_t& width, std::uint32_t& height, std::uint32_t& channels,
                                     std::string& imageIdentifier)
{
    imageIdentifier = getImageIdentifier (asset, imageIndex);
    imageBytes.clear();
    width = 0;
    height = 0;
    channels = 0;

    LOG (DBUG) << "Extracting image data...";

    std::visit ([&] (const auto& source)
                {
        using T = std::decay_t<decltype(source)>;
        if constexpr (std::is_same_v<T, fastgltf::sources::BufferView>) {
            const auto& bufferView = asset.bufferViews[source.bufferViewIndex];
            const auto& buffer = asset.buffers[bufferView.bufferIndex];

            std::visit([&](const auto& bufferSource) {
                using BufferT = std::decay_t<decltype(bufferSource)>;
                if constexpr (std::is_same_v<BufferT, fastgltf::sources::Array>) {
                    if (bufferView.byteOffset + bufferView.byteLength <= bufferSource.bytes.size()) {
                        imageBytes.resize(bufferView.byteLength);
                        std::transform(
                            bufferSource.bytes.begin() + bufferView.byteOffset,
                            bufferSource.bytes.begin() + bufferView.byteOffset + bufferView.byteLength,
                            imageBytes.begin(),
                            [](std::byte b) { return static_cast<unsigned char>(b); });
                    }
                }
            }, buffer.data);
        }
        else if constexpr (std::is_same_v<T, fastgltf::sources::URI>) {
            sabiImage.uri = source.uri.string();
            sabiImage.mimeType = fastgltf::getMimeTypeString(source.mimeType);
            LOG(DBUG) << "Stored image URI: " << sabiImage.uri;
        }
        else if constexpr (std::is_same_v<T, fastgltf::sources::Vector> || 
                           std::is_same_v<T, fastgltf::sources::Array>) {
            sabiImage.mimeType = fastgltf::getMimeTypeString(source.mimeType);
            auto start = reinterpret_cast<const unsigned char*>(source.bytes.data());
            imageBytes.assign(start, start + source.bytes.size());
            LOG(DBUG) << "Loaded embedded image data";
        } },
                image.data);

    if (imageBytes.empty())
    {
        LOG (DBUG) << "No image data to extract";
        return;
    }

    LOG (DBUG) << "Extracted " << imageBytes.size() << " bytes of image data";

    // Use stbi to decode the image data
    int w, h, c;
    unsigned char* decodedData = stbi_load_from_memory (
        imageBytes.data(),
        static_cast<int> (imageBytes.size()),
        &w, &h, &c, 0);

    if (decodedData)
    {
        width = static_cast<std::uint32_t> (w);
        height = static_cast<std::uint32_t> (h);
        channels = static_cast<std::uint32_t> (c);

        // Update imageBytes with the decoded data
        imageBytes.assign (decodedData, decodedData + (width * height * channels));

        LOG (DBUG) << "Image dimensions: " << width << "x" << height << ", channels: " << channels;

        // Free the decoded data
        stbi_image_free (decodedData);
    }
    else
    {
        LOG (DBUG) << "Failed to decode image data";
    }
}
void GLTFImporter::extractImageData (const fastgltf::Asset& asset, sabi::Image& sabiImage, const fastgltf::Image& image,
                                     size_t imageIndex, std::vector<unsigned char>& imageBytes,
                                     std::uint32_t& width, std::uint32_t& height, std::uint32_t& channels,
                                     std::string& imageIdentifier)
{
    imageIdentifier = getImageIdentifier (asset, imageIndex);
    imageBytes.clear();
    width = 0;
    height = 0;
    channels = 0;

    LOG (DBUG) << "Extracting image data...";

    std::visit ([&] (const auto& source)
                {
        using T = std::decay_t<decltype(source)>;
        if constexpr (std::is_same_v<T, fastgltf::sources::BufferView>) {
            const auto& bufferView = asset.bufferViews[source.bufferViewIndex];
            const auto& buffer = asset.buffers[bufferView.bufferIndex];

            std::visit([&](const auto& bufferSource) {
                using BufferT = std::decay_t<decltype(bufferSource)>;
                if constexpr (std::is_same_v<BufferT, fastgltf::sources::Array>) {
                    if (bufferView.byteOffset + bufferView.byteLength <= bufferSource.bytes.size()) {
                        imageBytes.resize(bufferView.byteLength);
                        std::transform(
                            bufferSource.bytes.begin() + bufferView.byteOffset,
                            bufferSource.bytes.begin() + bufferView.byteOffset + bufferView.byteLength,
                            imageBytes.begin(),
                            [](std::byte b) { return static_cast<unsigned char>(b); });
                    }
                }
            }, buffer.data);
        }
        else if constexpr (std::is_same_v<T, fastgltf::sources::URI>) {
            sabiImage.uri = source.uri.string();
            sabiImage.mimeType = fastgltf::getMimeTypeString(source.mimeType);
            LOG(DBUG) << "Stored image URI: " << sabiImage.uri;
        }
        else if constexpr (std::is_same_v<T, fastgltf::sources::Vector> || 
                           std::is_same_v<T, fastgltf::sources::Array>) {
            sabiImage.mimeType = fastgltf::getMimeTypeString(source.mimeType);
            auto start = reinterpret_cast<const unsigned char*>(source.bytes.data());
            imageBytes.assign(start, start + source.bytes.size());
            LOG(DBUG) << "Loaded embedded image data";
        } },
                image.data);

    if (imageBytes.empty())
    {
        LOG (DBUG) << "No image data to extract";
        return;
    }

    LOG (DBUG) << "Extracted " << imageBytes.size() << " bytes of image data";

    // Use stbi to decode the image data
    int w, h, c;
    unsigned char* decodedData = stbi_load_from_memory (
        imageBytes.data(),
        static_cast<int> (imageBytes.size()),
        &w, &h, &c, 0);

    if (decodedData)
    {
        width = static_cast<std::uint32_t> (w);
        height = static_cast<std::uint32_t> (h);
        channels = static_cast<std::uint32_t> (c);

        // Update imageBytes with the decoded data
        imageBytes.assign (decodedData, decodedData + (width * height * channels));

        LOG (DBUG) << "Image dimensions: " << width << "x" << height << ", channels: " << channels;

        // Free the decoded data
        stbi_image_free (decodedData);
    }
    else
    {
        LOG (DBUG) << "Failed to decode image data";
    }
}

void GLTFImporter::importCgImages (const fastgltf::Asset& asset, sabi::CgModel& model)
{
    model.images.reserve (asset.images.size());

    size_t index = 0;
    for (const auto& gltfImage : asset.images)
    {
        sabi::CgImage cgImage;
        cgImage.name = gltfImage.name;
        cgImage.index = index;
        std::vector<unsigned char> extractedImageBytes;
        std::uint32_t width, height, channels;
        std::string imageId;

        extractImageData (asset, cgImage, gltfImage, index++, extractedImageBytes, width, height, channels, imageId);

        if (extractedImageBytes.size())
        {
            // Use OIIO to store the extracted image
            OIIO::ImageSpec spec (width, height, channels, OIIO::TypeDesc::UINT8);
            OIIO::ImageBuf imageBuf (spec, extractedImageBytes.data());

            cgImage.extractedImage = imageBuf;
        }
        model.cgImages.emplace_back (std::move (cgImage));
    }
}
void GLTFImporter::importImages (const fastgltf::Asset& asset, CgModel& model)
{
    model.images.reserve (asset.images.size());

    size_t index = 0;
    for (const auto& gltfImage : asset.images)
    {
        sabi::Image sabiImage;
        sabiImage.name = gltfImage.name;
        sabiImage.index = index;
        std::vector<unsigned char> extractedImageBytes;
        std::uint32_t width, height, channels;
        std::string imageId;

        extractImageData (asset, sabiImage, gltfImage, index++, extractedImageBytes, width, height, channels, imageId);

        if (extractedImageBytes.size())
        {
            // Use OIIO to store the extracted image
            OIIO::ImageSpec spec (width, height, channels, OIIO::TypeDesc::UINT8);
            OIIO::ImageBuf imageBuf (spec, extractedImageBytes.data());

            sabiImage.extractedImage = imageBuf;
        }

        model.images.push_back (std::move (sabiImage));
    }
}

void GLTFImporter::importTextures (const fastgltf::Asset& asset, sabi::CgModel& model)
{
    model.textures.reserve (asset.textures.size());
    for (const auto& gltfTexture : asset.textures)
    {
        sabi::Texture texture;
        texture.name = gltfTexture.name;
        texture.source = gltfTexture.imageIndex.value_or (-1);
        texture.sampler = gltfTexture.samplerIndex.value_or (-1);

        model.textures.push_back (std::move (texture));
    }
    // LOG (DBUG) << "Imported " << model.textures.size() << " textures";
}

void GLTFImporter::importCgTextures (const fastgltf::Asset& asset, sabi::CgModel& model)
{
    model.cgTextures.reserve (asset.textures.size());
    for (const auto& gltfTexture : asset.textures)
    {
        sabi::CgTexture texture;
        texture.name = gltfTexture.name;
        texture.imageIndex = gltfTexture.imageIndex;
        texture.samplerIndex = gltfTexture.samplerIndex;
        texture.basisuImageIndex = gltfTexture.basisuImageIndex;
        texture.ddsImageIndex = gltfTexture.ddsImageIndex;
        texture.webpImageIndex = gltfTexture.webpImageIndex;

        model.cgTextures.push_back (std::move (texture));
    }
    // LOG (DBUG) << "Imported " << model.cgTextures.size() << " textures";
}

//void GLTFImporter::importTextures (const fastgltf::Asset& asset, CgModel& model)
//{
//    model.textures.reserve (asset.textures.size());
//    for (const auto& gltfTexture : asset.textures)
//    {
//        sabi::Texture texture;
//        texture.name = gltfTexture.name;
//        texture.source = gltfTexture.imageIndex.value_or (-1);
//        texture.sampler = gltfTexture.samplerIndex.value_or (-1);
//
//        model.textures.push_back (std::move (texture));
//    }
//    // LOG (DBUG) << "Imported " << model.textures.size() << " textures";
//}

void GLTFImporter::importSamplers (const fastgltf::Asset& asset, CgModel& model)
{
    model.samplers.reserve (asset.samplers.size());
    for (const auto& gltfSampler : asset.samplers)
    {
        sabi::Sampler sampler;
        sampler.name = gltfSampler.name;

        // Handle magFilter and minFilter
        sampler.magFilter = gltfSampler.magFilter.has_value() ? static_cast<int> (gltfSampler.magFilter.value()) : INVALID_INDEX;
        sampler.minFilter = gltfSampler.minFilter.has_value() ? static_cast<int> (gltfSampler.minFilter.value()) : INVALID_INDEX;

        // Handle wrapS and wrapT
        sampler.wrapS = static_cast<int> (gltfSampler.wrapS);
        sampler.wrapT = static_cast<int> (gltfSampler.wrapT);

        model.samplers.push_back (std::move (sampler));
    }
    // LOG (DBUG) << "Imported " << model.samplers.size() << " samplers";
}


void GLTFImporter::importCgSamplers (const fastgltf::Asset& asset, sabi::CgModel& model)
{
    model.cgSamplers.reserve (asset.samplers.size());
    for (const auto& gltfSampler : asset.samplers)
    {
        sabi::CgSampler sampler;
        sampler.name = gltfSampler.name;

        // Handle magFilter and minFilter
        sampler.magFilter = gltfSampler.magFilter.has_value() ? static_cast<sabi::CgFilter> (gltfSampler.magFilter.value()) : sabi::CgFilter::Linear;
        sampler.minFilter = gltfSampler.minFilter.has_value() ? static_cast<sabi::CgFilter> (gltfSampler.minFilter.value()) : sabi::CgFilter::Linear;

        // Handle wrapS and wrapT
        sampler.wrapS = static_cast<sabi::CgWrap> (gltfSampler.wrapS);
        sampler.wrapT = static_cast<sabi::CgWrap> (gltfSampler.wrapT);

        model.cgSamplers.push_back (std::move (sampler));
    }
}

Eigen::Affine3f GLTFImporter::computeLocalTransform (const fastgltf::Node& node)
{
    if (std::holds_alternative<fastgltf::TRS> (node.transform))
    {
        const auto& trs = std::get<fastgltf::TRS> (node.transform);
        Eigen::Affine3f transform = Eigen::Affine3f::Identity();

        // Apply translation
        transform.translate (Eigen::Vector3f (trs.translation[0], trs.translation[1], trs.translation[2]));

        // Apply rotation
        Eigen::Quaternionf rotation (trs.rotation.w(), trs.rotation.x(), trs.rotation.y(), trs.rotation.z());
        transform.rotate (rotation);

        // Apply scale
        transform.scale (Eigen::Vector3f (trs.scale[0], trs.scale[1], trs.scale[2]));

        return transform;
    }
    else if (std::holds_alternative<fastgltf::math::fmat4x4> (node.transform))
    {
        const auto& matrix = std::get<fastgltf::math::fmat4x4> (node.transform);
        Eigen::Matrix4f eigenMatrix;
        for (int i = 0; i < 4; ++i)
        {
            for (int j = 0; j < 4; ++j)
            {
                eigenMatrix (i, j) = matrix[j][i]; // Note the swapped indices
            }
        }
        return Eigen::Affine3f (eigenMatrix);
    }

    return Eigen::Affine3f::Identity();
}


// Helper function implementations
void GLTFImporter::importCoreMaterialProperties (const fastgltf::Asset& asset, const fastgltf::Material& gltfMaterial, sabi::CgMaterial::CoreProperties& core)
{
    // Base color
    core.baseColor = {
        gltfMaterial.pbrData.baseColorFactor[0],
        gltfMaterial.pbrData.baseColorFactor[1],
        gltfMaterial.pbrData.baseColorFactor[2]};

    core.roughness = gltfMaterial.pbrData.roughnessFactor;
    core.specular = 0.5f; // Default value as this isn't directly in glTF PBR

    if (gltfMaterial.pbrData.baseColorTexture)
    {
        core.baseColorTexture = importCgTextureInfo (asset, gltfMaterial.pbrData.baseColorTexture.value());
    }

    if (gltfMaterial.pbrData.metallicRoughnessTexture)
    {
        core.roughnessTexture = importCgTextureInfo (asset, gltfMaterial.pbrData.metallicRoughnessTexture.value());
    }
}

void GLTFImporter::importMetallicProperties (const fastgltf::Asset& asset, const fastgltf::Material& gltfMaterial, sabi::CgMaterial::MetallicProperties& metallic)
{
    metallic.metallic = gltfMaterial.pbrData.metallicFactor;

    if (gltfMaterial.anisotropy)
    {
        metallic.anisotropic = gltfMaterial.anisotropy->anisotropyStrength;
        metallic.anisotropicRotation = gltfMaterial.anisotropy->anisotropyRotation;

        if (gltfMaterial.anisotropy->anisotropyTexture)
        {
            metallic.anisotropicTexture = importCgTextureInfo (asset, gltfMaterial.anisotropy->anisotropyTexture.value());
        }
    }

    if (gltfMaterial.pbrData.metallicRoughnessTexture)
    {
        metallic.metallicTexture = importCgTextureInfo (asset, gltfMaterial.pbrData.metallicRoughnessTexture.value());
    }
}

sabi::TextureInfo GLTFImporter::importTextureInfo (const fastgltf::Asset& asset, const fastgltf::TextureInfo& textureInfo)
{
    sabi::TextureInfo result;
    result.textureIndex = textureInfo.textureIndex;
    result.texCoord = textureInfo.texCoordIndex;
    return result;
}

sabi::CgTextureInfo GLTFImporter::importCgTextureInfo (const fastgltf::Asset& asset, const fastgltf::TextureInfo& textureInfo)
{
    sabi::CgTextureInfo result;
    result.textureIndex = textureInfo.textureIndex;
    result.texCoordIndex = textureInfo.texCoordIndex;

    if (textureInfo.transform)
    {
        auto transform = std::make_unique<sabi::CgTextureTransform>();
        transform->rotation = textureInfo.transform->rotation;
        transform->uvOffset = Eigen::Vector2f (textureInfo.transform->uvOffset[0], textureInfo.transform->uvOffset[1]);
        transform->uvScale = Eigen::Vector2f (textureInfo.transform->uvScale[0], textureInfo.transform->uvScale[1]);
        transform->texCoordIndex = textureInfo.transform->texCoordIndex;
        result.transform = std::move (transform);
    }

    return result;
}


 void GLTFImporter::importSheenProperties (const fastgltf::Asset& asset, const fastgltf::Material& gltfMaterial, CgMaterial::SheenProperties& sheen)
{
    if (gltfMaterial.sheen)
    {
        sheen.sheenColorFactor = Eigen::Vector3f (gltfMaterial.sheen->sheenColorFactor.x(),
                                                  gltfMaterial.sheen->sheenColorFactor.y(),
                                                  gltfMaterial.sheen->sheenColorFactor.z());
        sheen.sheenRoughnessFactor = gltfMaterial.sheen->sheenRoughnessFactor;

        if (gltfMaterial.sheen->sheenColorTexture)
        {
            sheen.sheenColorTexture = importCgTextureInfo (asset, gltfMaterial.sheen->sheenColorTexture.value());
        }
        if (gltfMaterial.sheen->sheenRoughnessTexture)
        {
            sheen.sheenRoughnessTexture = importCgTextureInfo (asset, gltfMaterial.sheen->sheenRoughnessTexture.value());
        }
    }
}


void GLTFImporter::importTranslucencyProperties (const fastgltf::Asset& asset, const fastgltf::Material& gltfMaterial, sabi::CgMaterial::TranslucencyProperties& translucency)
{
    
}

void GLTFImporter::importSubsurfaceProperties (const fastgltf::Asset& asset, const fastgltf::Material& gltfMaterial, sabi::CgMaterial::SubsurfaceProperties& subsurface)
{
    if (gltfMaterial.volume)
    {
        subsurface.subsurface = gltfMaterial.volume->thicknessFactor;
        subsurface.subsurfaceColor = {
            gltfMaterial.volume->attenuationColor[0],
            gltfMaterial.volume->attenuationColor[1],
            gltfMaterial.volume->attenuationColor[2]};
        subsurface.subsurfaceDistance = gltfMaterial.volume->attenuationDistance;

        if (gltfMaterial.volume->thicknessTexture)
        {
            subsurface.subsurfaceColorTexture = importCgTextureInfo (asset, gltfMaterial.volume->thicknessTexture.value());
        }
    }

    // subsurface.asymmetry
    subsurface.asymmetry = 0.0f; // no support for this at the moment.
}
void GLTFImporter::importEmissionProperties (const fastgltf::Asset& asset, const fastgltf::Material& gltfMaterial, sabi::CgMaterial::EmissionProperties& emission)
{
    emission.luminous = 1.0f; // Strength not provided in the glTF spec, it seems.
    emission.luminousColor = {
        gltfMaterial.emissiveFactor[0],
        gltfMaterial.emissiveFactor[1],
        gltfMaterial.emissiveFactor[2]};

    if (gltfMaterial.emissiveTexture)
    {
        emission.luminousTexture = importCgTextureInfo (asset, gltfMaterial.emissiveTexture.value());
    }
}
void GLTFImporter::importClearcoatProperties (const fastgltf::Asset& asset, const fastgltf::Material& gltfMaterial, sabi::CgMaterial::ClearcoatProperties& clearcoat)
{
    if (gltfMaterial.clearcoat)
    {
        clearcoat.clearcoat = gltfMaterial.clearcoat->clearcoatFactor;
        clearcoat.clearcoatGloss = gltfMaterial.clearcoat->clearcoatRoughnessFactor;

        if (gltfMaterial.clearcoat->clearcoatTexture)
            clearcoat.clearcoatTexture = importCgTextureInfo (asset, gltfMaterial.clearcoat->clearcoatTexture.value());

        if (gltfMaterial.clearcoat->clearcoatRoughnessTexture)
            clearcoat.clearcoatRoughnessTexture = importCgTextureInfo (asset, gltfMaterial.clearcoat->clearcoatRoughnessTexture.value());

        if (gltfMaterial.clearcoat->clearcoatNormalTexture)
            clearcoat.clearcoatNormalTexture = importCgTextureInfo (asset, gltfMaterial.clearcoat->clearcoatNormalTexture.value());
    }
}

void GLTFImporter::importTransparencyProperties (const fastgltf::Asset& asset, const fastgltf::Material& gltfMaterial, sabi::CgMaterial::TransparencyProperties& transparency)
{
    if (gltfMaterial.transmission)
    {
        transparency.transparency = gltfMaterial.transmission->transmissionFactor;

        if (gltfMaterial.transmission->transmissionTexture)
            transparency.transparencyTexture = importCgTextureInfo (asset, gltfMaterial.transmission->transmissionTexture.value());
    }

    if (gltfMaterial.ior > 1.0f)
        transparency.refractionIndex = gltfMaterial.ior;

    transparency.thin = false;
    transparency.transmittance = {0.5f, 0.5f, 0.5f};
    transparency.transmittanceDistance = 1.0f;
}
void GLTFImporter::importPackedTextures (const fastgltf::Asset& asset, const fastgltf::Material& gltfMaterial, sabi::CgMaterial::PackedTextureProperties& packedTextures)
{
    if (gltfMaterial.packedOcclusionRoughnessMetallicTextures)
    {
        const auto& packedTexturesData = *gltfMaterial.packedOcclusionRoughnessMetallicTextures;

        // Handle ORM combined texture (Occlusion-Roughness-Metallic)
        if (packedTexturesData.occlusionRoughnessMetallicTexture.has_value())
        {
            packedTextures.occlusionRoughnessMetallicTexture =
                importCgTextureInfo (asset, packedTexturesData.occlusionRoughnessMetallicTexture.value());
        }
        // Handle RMO combined texture (Roughness-Metallic-Occlusion)
        if (packedTexturesData.roughnessMetallicOcclusionTexture.has_value())
        {
            packedTextures.roughnessMetallicOcclusionTexture =
                importCgTextureInfo (asset, packedTexturesData.roughnessMetallicOcclusionTexture.value());
        }
        // Handle normal texture from packed textures
        if (packedTexturesData.normalTexture.has_value())
        {
            packedTextures.normalRoughnessMetallicTexture =
                importCgTextureInfo (asset, packedTexturesData.normalTexture.value());
        }
    }
    if (gltfMaterial.packedNormalMetallicRoughnessTexture)
    {
        packedTextures.normalRoughnessMetallicTexture = importCgTextureInfo (asset,
                                                                             gltfMaterial.packedNormalMetallicRoughnessTexture.value());
    }
}

CgModelPtr GLTFImporter::forgeIntoOne (const CgModelList& models)
{
    std::unordered_set<std::string> usedSurfaceNames;

    // Initialize counters for total vertices and triangles.
    uint32_t totalVertices = 0;
    uint32_t totalTriangles = 0;

    // Reserve space for vertex offsets.
    std::vector<uint32_t> vertexOffsets;
    vertexOffsets.reserve (models.size());
    vertexOffsets.push_back (totalVertices);

    // Create a shared pointer for the flattened mesh.
    auto flattenedModel = std::make_shared<CgModel>();

    // Iterate over the input meshes.
    for (const auto& m : models)
    {
        // Update the total vertices and triangles counters.
        totalVertices += m->V.cols();
        vertexOffsets.push_back (totalVertices);

        // each mesh can have only 1 surface!
        assert (m->S.size() == 1);

        totalTriangles += m->S[0].triangleCount();

        auto& surface = m->S[0];
        surface.name = generateUniqueName (surface.name.empty() ? "Surface" : surface.name);

        // Move surfaces from input mesh to the flattened mesh.
        flattenedModel->S.emplace_back (std::move (m->S[0]));
    }

    // Resize the vertex and uv matrices of the flattened mesh.
    flattenedModel->V.resize (3, totalVertices);

    // FIXME some meshes don't have UV data (Storm Trooper for example)
    // and what about UV1?
    flattenedModel->UV0.resize (2, totalVertices);

    // Copy vertex and uv data from input meshes to the flattened mesh.
    for (uint32_t index = 0; index < models.size(); ++index)
    {
        const auto& mesh = models[index];
        std::memcpy (flattenedModel->V.data() + vertexOffsets[index] * 3, mesh->V.data(), mesh->vertexCount() * 3 * sizeof (float));

        // some meshes don't have UV data
        if (mesh->UV0.cols())
            std::memcpy (flattenedModel->UV0.data() + vertexOffsets[index] * 2, mesh->UV0.data(), mesh->vertexCount() * 2 * sizeof (float));

        // FIXME what about UV1?
    }

    // Update triangle indices in the flattened mesh with new vertex offsets.
    for (uint32_t index = 0; index < flattenedModel->S.size(); ++index)
    {
        auto& s = flattenedModel->S[index];
        uint32_t vertexOffset = vertexOffsets[index];
        auto& tris = s.indices();

        // Update each triangle's indices with the corresponding vertex offset.
        for (int i = 0; i < s.triangleCount(); i++)
        {
            Vector3u tri = tris.col (i);
            for (int j = 0; j < 3; j++)
                tri[j] += vertexOffset;
            tris.col (i) = tri;
        }
    }

    return flattenedModel;
}

std::vector<Animation> GLTFImporter::importAnimations (const fastgltf::Asset& asset)
{
    std::vector<Animation> animations;

    for (size_t i = 0; i < asset.animations.size(); ++i)
    {
        Animation animation;
        animation.name = asset.animations[i].name;
        animation.channels = animationExporter.exportAnimation (asset, i);
        animations.push_back (std::move (animation));
    }

    return animations;
}

#if 0
CgModelPtr GLTFImporter::forgeIntoOne (const CgModelList& models)
{
    // Initialize counters for total vertices and triangles.
    uint32_t totalVertices = 0;
    uint32_t totalTriangles = 0;

    // Reserve space for vertex offsets.
    std::vector<uint32_t> vertexOffsets;
    vertexOffsets.reserve (models.size());
    vertexOffsets.push_back (totalVertices);

    // Create a shared pointer for the flattened mesh.
    auto flattenedModel = std::make_shared<CgModel>();

    // Iterate over the input meshes.
    for (const auto& m : models)
    {
        // Update the total vertices and triangles counters.
        totalVertices += m->V.cols();
        vertexOffsets.push_back (totalVertices);

         // each mesh can have only 1 surface!
        if (m->S.size() != 1)
        {
            // we are done
            LOG (DBUG) << "More than 1 surface while attempted to forge into one model";
            return nullptr;
        }

       
        debug_assert (m->S.size() == 1);

        totalTriangles += m->S[0].triangleCount();

        // Move surfaces from input mesh to the flattened mesh.
        flattenedModel->S.emplace_back (std::move (m->S[0]));

        // Append images, textures, and samplers
        flattenedModel->images.insert (flattenedModel->images.end(), m->images.begin(), m->images.end());
        flattenedModel->textures.insert (flattenedModel->textures.end(), m->textures.begin(), m->textures.end());
        flattenedModel->samplers.insert (flattenedModel->samplers.end(), m->samplers.begin(), m->samplers.end());
    }

    // Resize the vertex and uv matrices of the flattened mesh.
    flattenedModel->V.resize (3, totalVertices);

    // FIXME some meshes don't have UV data (Storm Trooper for example)
    // and what about UV1?
    flattenedModel->UV0.resize (2, totalVertices);

    // Copy vertex and uv data from input meshes to the flattened mesh.
    for (uint32_t index = 0; index < models.size(); ++index)
    {
        const auto& mesh = models[index];
        std::memcpy (flattenedModel->V.data() + vertexOffsets[index] * 3, mesh->V.data(), mesh->vertexCount() * 3 * sizeof (float));

        // some meshes don't have UV data
        if (mesh->UV0.cols())
            std::memcpy (flattenedModel->UV0.data() + vertexOffsets[index] * 2, mesh->UV0.data(), mesh->vertexCount() * 2 * sizeof (float));

        // FIXME what about UV1?
    }

    // Update triangle indices in the flattened mesh with new vertex offsets.
    for (uint32_t index = 0; index < flattenedModel->S.size(); ++index)
    {
        auto& s = flattenedModel->S[index];
        uint32_t vertexOffset = vertexOffsets[index];
        auto& tris = s.indices();

        // Update each triangle's indices with the corresponding vertex offset.
        for (int i = 0; i < s.triangleCount(); i++)
        {
            Vector3u tri = tris.col (i);
            for (int j = 0; j < 3; j++)
                tri[j] += vertexOffset;
            tris.col (i) = tri;
        }
    }

    return flattenedModel;
}
#endif
#endif
</file>

<file path="io/GLTFImporter.h">
#pragma once

// A comprehensive importer for glTF (GL Transmission Format) files that converts
// them into the CgModel format. This class leverages the fastgltf library for
// parsing and provides complete support for both .gltf and .glb file formats.
//
// Features:
// - Imports geometry (vertices, indices, normals, UVs)
// - Imports PBR materials and textures
// - Handles node hierarchies and transforms
// - Supports animations
// - Can combine multiple meshes into a single model
//
// Example usage:
//   GLTFImporter importer;
//   auto [model, animations] = importer.importModel("path/to/model.gltf");

using sabi::CgMaterial;
using sabi::CgModel;
using sabi::CgModelList;
using sabi::CgModelPtr;

class GLTFImporter
{
 public:
    GLTFImporter() = default;
    ~GLTFImporter() = default;

    // Primary entry point for importing a glTF file
    // Returns a pair containing the model and its animations
    // Throws std::runtime_error if import fails
    std::pair<CgModelPtr, std::vector<Animation>> importModel (const std::string& filePath);

 private:
    // Internal state
    CgModelList models;                        // Imported models
    GltfAnimationExporter animationExporter;   // Animation export handler
    std::unordered_set<std::string> usedNames; // Name uniqueness tracking

    // Asset loading
    // Parses glTF/GLB file into fastgltf::Asset
    fastgltf::Asset loadGLTF (const std::string& filePath);

    // Scene handling
    void processScenes (const fastgltf::Asset& asset);
    void processNode (const fastgltf::Asset& asset, const fastgltf::Node& node,
                      const Eigen::Affine3f& parentTransform);

    // Geometry import
    void importPrimitive (const fastgltf::Asset& asset, const fastgltf::Mesh& mesh,
                          const fastgltf::Primitive& primitive,
                          const Eigen::Affine3f& transform, CgModel& model);
    void importVertices (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive,
                         CgModel& model);
    void importIndices (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive,
                        CgModel& model);
    void importNormals (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive,
                        CgModel& model);
    void importUVs (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive,
                    CgModel& model);

    // Material import
    void importMaterial (const fastgltf::Asset& asset, const fastgltf::Primitive& primitive,
                         CgModel& model);
    void importCoreMaterialProperties (const fastgltf::Asset& asset,
                                       const fastgltf::Material& gltfMaterial,
                                       sabi::CgMaterial::CoreProperties& core);
    void importMetallicProperties (const fastgltf::Asset& asset,
                                   const fastgltf::Material& gltfMaterial,
                                   sabi::CgMaterial::MetallicProperties& metallic);
    void importSheenProperties (const fastgltf::Asset& asset,
                                const fastgltf::Material& gltfMaterial,
                                sabi::CgMaterial::SheenProperties& sheen);
    void importTranslucencyProperties (const fastgltf::Asset& asset,
                                       const fastgltf::Material& gltfMaterial,
                                       sabi::CgMaterial::TranslucencyProperties& translucency);
    void importSubsurfaceProperties (const fastgltf::Asset& asset,
                                     const fastgltf::Material& gltfMaterial,
                                     sabi::CgMaterial::SubsurfaceProperties& subsurface);
    void importEmissionProperties (const fastgltf::Asset& asset,
                                   const fastgltf::Material& gltfMaterial,
                                   sabi::CgMaterial::EmissionProperties& emission);
    void importClearcoatProperties (const fastgltf::Asset& asset,
                                    const fastgltf::Material& gltfMaterial,
                                    sabi::CgMaterial::ClearcoatProperties& clearcoat);
    void importTransparencyProperties (const fastgltf::Asset& asset,
                                       const fastgltf::Material& gltfMaterial,
                                       sabi::CgMaterial::TransparencyProperties& transparency);
    void importPackedTextures (const fastgltf::Asset& asset,
                               const fastgltf::Material& gltfMaterial,
                               sabi::CgMaterial::PackedTextureProperties& packedTextures);

    // Texture import
    void importImages (const fastgltf::Asset& asset, CgModel& model);
    void importCgImages (const fastgltf::Asset& asset, sabi::CgModel& model);
    void importTextures (const fastgltf::Asset& asset, CgModel& model);
    void importCgTextures (const fastgltf::Asset& asset, sabi::CgModel& model);
    void importSamplers (const fastgltf::Asset& asset, CgModel& model);
    void importCgSamplers (const fastgltf::Asset& asset, CgModel& model);
    sabi::TextureInfo importTextureInfo (const fastgltf::Asset& asset,
                                         const fastgltf::TextureInfo& textureInfo);
    sabi::CgTextureInfo importCgTextureInfo (const fastgltf::Asset& asset,
                                             const fastgltf::TextureInfo& textureInfo);
    // Image data handling
    void extractImageData (const fastgltf::Asset& asset, sabi::Image& sabiImage,
                           const fastgltf::Image& image, size_t imageIndex,
                           std::vector<unsigned char>& imageBytes, std::uint32_t& width,
                           std::uint32_t& height, std::uint32_t& channels,
                           std::string& imageIdentifier);
    void extractImageData (const fastgltf::Asset& asset, sabi::CgImage& sabiImage,
                           const fastgltf::Image& image, size_t imageIndex,
                           std::vector<unsigned char>& imageBytes, std::uint32_t& width,
                           std::uint32_t& height, std::uint32_t& channels,
                           std::string& imageIdentifier);

    // Helper functions
    std::string mimeTypeToString (fastgltf::MimeType mimeType);
    std::string getImageIdentifier (const fastgltf::Asset& asset, size_t imageIndex);
    std::string generateUniqueName (const std::string& baseName);
    Eigen::Affine3f computeLocalTransform (const fastgltf::Node& node);
    std::vector<Animation> importAnimations (const fastgltf::Asset& asset);
    CgModelPtr forgeIntoOne (const CgModelList& models);

};
</file>

<file path="io/GLTFUtil.h">
#pragma once

namespace
{
    enum class GLTFComponentType
    {
        BYTE = 5120,
        UNSIGNED_BYTE = 5121,
        SHORT = 5122,
        UNSIGNED_SHORT = 5123,
        UNSIGNED_INT = 5125,
        FLOAT = 5126
    };

    size_t getComponentSize (GLTFComponentType type)
    {
        switch (type)
        {
            case GLTFComponentType::BYTE:
            case GLTFComponentType::UNSIGNED_BYTE:
                return 1;
            case GLTFComponentType::SHORT:
            case GLTFComponentType::UNSIGNED_SHORT:
                return 2;
            case GLTFComponentType::UNSIGNED_INT:
                return 4;
            case GLTFComponentType::FLOAT:
                return 4;
            default:
                throw std::runtime_error ("Unsupported component type");
        }
    }

    // Optional: Function to convert the enum to a human-readable string
    std::string componentTypeToString (GLTFComponentType type)
    {
        switch (type)
        {
            case GLTFComponentType::BYTE:
                return "BYTE";
            case GLTFComponentType::UNSIGNED_BYTE:
                return "UNSIGNED_BYTE";
            case GLTFComponentType::SHORT:
                return "SHORT";
            case GLTFComponentType::UNSIGNED_SHORT:
                return "UNSIGNED_SHORT";
            case GLTFComponentType::UNSIGNED_INT:
                return "UNSIGNED_INT";
            case GLTFComponentType::FLOAT:
                return "FLOAT";
            default:
                return "UNKNOWN";
        }
    }

    enum class GLTFAccessorType
    {
        SCALAR,
        VEC2,
        VEC3,
        VEC4,
        MAT2,
        MAT3,
        MAT4
    };

    // Optional: Function to convert the enum to a human-readable string
    std::string accessorTypeToString (GLTFAccessorType type)
    {
        switch (type)
        {
            case GLTFAccessorType::SCALAR:
                return "SCALAR";
            case GLTFAccessorType::VEC2:
                return "VEC2";
            case GLTFAccessorType::VEC3:
                return "VEC3";
            case GLTFAccessorType::VEC4:
                return "VEC4";
            case GLTFAccessorType::MAT2:
                return "MAT2";
            case GLTFAccessorType::MAT3:
                return "MAT3";
            case GLTFAccessorType::MAT4:
                return "MAT4";
            default:
                return "UNKNOWN";
        }
    }

    GLTFAccessorType stringToAccessorType (const std::string& typeString)
    {
        if (typeString == "SCALAR")
        {
            return GLTFAccessorType::SCALAR;
        }
        else if (typeString == "VEC2")
        {
            return GLTFAccessorType::VEC2;
        }
        else if (typeString == "VEC3")
        {
            return GLTFAccessorType::VEC3;
        }
        else if (typeString == "VEC4")
        {
            return GLTFAccessorType::VEC4;
        }
        else if (typeString == "MAT2")
        {
            return GLTFAccessorType::MAT2;
        }
        else if (typeString == "MAT3")
        {
            return GLTFAccessorType::MAT3;
        }
        else if (typeString == "MAT4")
        {
            return GLTFAccessorType::MAT4;
        }
        else
        {
            // Handle unknown types, maybe log an error or throw an exception
            LOG (CRITICAL) << "Unknown accessor type: " << typeString;
            return GLTFAccessorType::SCALAR; // Default or error value
        }
    }

    size_t getNumberOfComponents (GLTFAccessorType type)
    {
        switch (type)
        {
            case GLTFAccessorType::SCALAR:
                return 1;
            case GLTFAccessorType::VEC2:
                return 2;
            case GLTFAccessorType::VEC3:
                return 3;
            case GLTFAccessorType::VEC4:
                return 4;
            case GLTFAccessorType::MAT2:
                return 4;
            case GLTFAccessorType::MAT3:
                return 9;
            case GLTFAccessorType::MAT4:
                return 16;
            default:
                throw std::runtime_error ("Unsupported accessor type");
        }
    }

    enum class GLTFMeshMode
    {
        POINTS = 0,
        LINES = 1,
        LINE_LOOP = 2,
        LINE_STRIP = 3,
        TRIANGLES = 4,
        TRIANGLE_STRIP = 5,
        TRIANGLE_FAN = 6
    };

    // Optional: Function to convert the enum to a human-readable string
    std::string meshModeToString (GLTFMeshMode mode)
    {
        switch (mode)
        {
            case GLTFMeshMode::POINTS:
                return "POINTS";
            case GLTFMeshMode::LINES:
                return "LINES";
            case GLTFMeshMode::LINE_LOOP:
                return "LINE_LOOP";
            case GLTFMeshMode::LINE_STRIP:
                return "LINE_STRIP";
            case GLTFMeshMode::TRIANGLES:
                return "TRIANGLES";
            case GLTFMeshMode::TRIANGLE_STRIP:
                return "TRIANGLE_STRIP";
            case GLTFMeshMode::TRIANGLE_FAN:
                return "TRIANGLE_FAN";
            default:
                return "UNKNOWN";
        }
    }

    struct BufferView
    {
        int bufferIndex = INVALID_INDEX; // Index of the buffer
        size_t byteOffset = 0;           // Offset into the buffer in bytes
        size_t byteLength = 0;           // Total length of the bufferView in bytes
        size_t byteStride = 0;           // The stride, in bytes, between consecutive elements
        int target = 0;                  // The target that the GPU buffer should be bound to
    };

    struct Accessor
    {
        int bufferViewIndex = INVALID_INDEX;                        // Index of the bufferView
        size_t byteOffset = 0;                                      // Offset into the bufferView in bytes
        GLTFComponentType componentType = GLTFComponentType::FLOAT; // Data type of components in the accessor
        size_t count = 0;                                           // Number of elements or vertices
        GLTFAccessorType type = GLTFAccessorType::SCALAR;           // Type of the element (e.g., VEC3, SCALAR)
        bool normalized = false;                                    // Whether integer data values should be normalized

        // Optional: min and max values, used for bounding volume calculations
        std::vector<float> minValues;
        std::vector<float> maxValues;
    };

    struct MeshPrimitive
    {
        int indices = INVALID_INDEX;                 // Index of the accessor for indices (optional)
        int material = INVALID_INDEX;                // Index of the material to use (optional)
        GLTFMeshMode mode = GLTFMeshMode::TRIANGLES; // The type of primitive to render
        std::map<std::string, int> attributes;       // A dictionary object of accessor indices for each vertex attribute
    };

    struct Mesh
    {
        std::string name;                      // Optional name of the mesh
        std::vector<MeshPrimitive> primitives; // Collection of primitives to be rendered
    };

    struct Buffer
    {
        std::string uri;       // URI of the buffer data (could be a path to a file or a data URI)
        size_t byteLength = 0; // Size of the buffer in bytes

        // If you plan to load the buffer data directly into this struct:
        std::vector<char> binaryData; // The actual data of the buffer
    };

    struct Asset
    {
        std::string version = "2.0"; // Required - the version of the GLTF specification
        std::string generator;       // Optional - the tool that generated the GLTF file
        std::string minVersion;      // Optional - the minimum GLTF version that this file is compatible with
    };

    enum class TextureType
    {
        BASE_COLOR,         // For base color of the material
        NORMAL_MAP,         // For normal maps
        METALLIC_ROUGHNESS, // For metallic-roughness workflow
        OCCLUSION,          // For ambient occlusion
        EMISSIVE            // For emissive textures
    };

    struct Image
    {
        std::string name;
        std::string uri;                     // URI of the image resource
        int bufferViewIndex = INVALID_INDEX; // Index to a bufferView (for embedded image data)
        std::string mimeType;                // MIME type of the image
        // std::vector<uint8_t> data;           // Raw image data
        OIIO::ImageBuf extractedImage; // could be from BufferView in GLB or embedded
        uint32_t index = 0;            // index into the models vector of images
    };

    struct Texture
    {
        std::string name;
        int source = INVALID_INDEX;  // Index of the image used by this texture
        int sampler = INVALID_INDEX; // Index of the sampler used by this texture
    };

    struct Sampler
    {
        std::string name;
        int magFilter = INVALID_INDEX; // Magnification filter
        int minFilter = INVALID_INDEX; // Minification filter
        int wrapS = 10497;             // s-coordinate wrapping mode, default is REPEAT
        int wrapT = 10497;             // t-coordinate wrapping mode, default is REPEAT
    };

    struct TextureInfo
    {
        int textureIndex = INVALID_INDEX; // Index of the texture in the textures array
        int texCoord = 0;                 // Texture coordinate set to use
        float scale;                      // For normal textures
        float strength;                   // For occlusion textures
    };

    struct Material
    {
        struct PBRMetallicRoughness
        {
            std::optional<TextureInfo> baseColorTexture;
            std::array<float, 4> baseColorFactor = {1.0f, 1.0f, 1.0f, 1.0f};
            std::optional<TextureInfo> metallicRoughnessTexture;
            float metallicFactor = 0.0f;
            float roughnessFactor = 0.5f;

            PBRMetallicRoughness() = default;
        };

        struct DisneyBRDF
        {
            // Specular group
            float specularTint = 0.0f;
            float anisotropic = 0.0f;
            float anisotropicRotation = 0.0f;

            // Sheen group
            float sheen = 0.0f;
            float sheenTint = 0.0f;

            // Clearcoat group
            float clearcoat = 0.0f;
            float clearcoatGloss = 0.0f;

            // Subsurface group
            float subsurface = 0.0f;
            float subsurfaceDistance = 0.0f;
            Eigen::Vector3f subsurfaceColor = Eigen::Vector3f (1.0f, 1.0f, 1.0f);
            float flatness = 0.0f;
            float asymmetry = 0.0f;

            // Transmission group
            float translucency = 0.0f;          // Diffuse light transmission through thin materials
            float transparency = 0.0f;          // Direct light transmission (like glass)
            Eigen::Vector3f transmittance = {0.5f, 0.5f, 0.5f};
            float transmittanceDistance = 0.0f; // Distance over which transmittance is measured
            float ior = 1.45f;                  // Index of refraction
            bool thinWalled = false;            // Whether material is thin-walled

            // Emission group
            bool luminous = false;
            Eigen::Vector3f luminousColor = Eigen::Vector3f (1.0f, 1.0f, 1.0f);

            DisneyBRDF() = default;
        };

        std::string name;
        PBRMetallicRoughness pbrMetallicRoughness;
        DisneyBRDF disneyBRDF;
        std::optional<TextureInfo> normalTexture;
        std::optional<TextureInfo> occlusionTexture;
        std::optional<TextureInfo> emissiveTexture;
        std::array<float, 3> emissiveFactor = {0.0f, 0.0f, 0.0f};

        // New texture maps for expanded features
        std::optional<TextureInfo> subsurfaceColorTexture;
        std::optional<TextureInfo> subsurfaceRadiusTexture;
        std::optional<TextureInfo> transmissionTexture;
        std::optional<TextureInfo> sheenColorTexture;
        std::optional<TextureInfo> sheenRoughnessTexture;
        std::optional<TextureInfo> specularTexture;
        std::optional<TextureInfo> specularColorTexture;
        std::optional<TextureInfo> anisotropicTexture;
        std::optional<TextureInfo> anisotropicRotationTexture;
        std::optional<TextureInfo> clearcoatTexture;
        std::optional<TextureInfo> clearcoatRoughnessTexture;
        std::optional<TextureInfo> clearcoatNormalTexture;
        std::optional<TextureInfo> transmittanceTexture;

        void debug()
        {
            // Log basic material properties
           
            LOG (DBUG) << "  Base Color: "
                       << pbrMetallicRoughness.baseColorFactor[0] << ", "
                       << pbrMetallicRoughness.baseColorFactor[1] << ", "
                       << pbrMetallicRoughness.baseColorFactor[2];
            LOG (DBUG) << "  Metallic: " << pbrMetallicRoughness.metallicFactor;
            LOG (DBUG) << "  Roughness: " << pbrMetallicRoughness.roughnessFactor;

            // Log Disney BRDF specific properties
            LOG (DBUG) << "  Disney BRDF Properties:";
            LOG (DBUG) << "    Specular Tint: " << disneyBRDF.specularTint;
            LOG (DBUG) << "    Anisotropic: " << disneyBRDF.anisotropic;
            LOG (DBUG) << "    Sheen: " << disneyBRDF.sheen;
            LOG (DBUG) << "    Sheen Tint: " << disneyBRDF.sheenTint;
            LOG (DBUG) << "    Clearcoat: " << disneyBRDF.clearcoat;
            LOG (DBUG) << "    Clearcoat Gloss: " << disneyBRDF.clearcoatGloss;

            // Log transparency related properties
            LOG (DBUG) << "  Transparency Properties:";
            LOG (DBUG) << "    Transparency: " << disneyBRDF.transparency;
            LOG (DBUG) << "    Transmittance: " << disneyBRDF.transmittance;
            LOG (DBUG) << "    Transmittance Distance: " << disneyBRDF.transmittanceDistance;
            LOG (DBUG) << "    IOR: " << disneyBRDF.ior;
            LOG (DBUG) << "    Thin Walled: " << (disneyBRDF.thinWalled ? "true" : "false");

            // Log subsurface properties
            LOG (DBUG) << "  Subsurface Properties:";
            LOG (DBUG) << "    Subsurface: " << disneyBRDF.subsurface;
            LOG (DBUG) << "    Subsurface Distance: " << disneyBRDF.subsurfaceDistance;
            LOG (DBUG) << "    Subsurface Color: "
                       << disneyBRDF.subsurfaceColor.x() << ", "
                       << disneyBRDF.subsurfaceColor.y() << ", "
                       << disneyBRDF.subsurfaceColor.z();

            // Log emission properties
            LOG (DBUG) << "  Emission Properties:";
            LOG (DBUG) << "    Luminous: " << (disneyBRDF.luminous ? "true" : "false");
            LOG (DBUG) << "    Luminous Color: "
                       << disneyBRDF.luminousColor.x() << ", "
                       << disneyBRDF.luminousColor.y() << ", "
                       << disneyBRDF.luminousColor.z();
        }
    };

    struct Scene
    {
        std::string name;             // Optional name of the scene
        std::vector<int> nodeIndices; // Indices of root nodes in the scene
    };

    struct Node
    {
        std::string name;                                             // Optional name of the node
        Eigen::Affine3f transform = Eigen::Affine3f::Identity();      // Affine transformation matrix
        Eigen::Vector3f translation = Eigen::Vector3f::Zero();        // Translation
        Eigen::Quaternionf rotation = Eigen::Quaternionf::Identity(); // Rotation
        Eigen::Vector3f scale = Eigen::Vector3f::Ones();              // Scale
        bool isMatrixMode = false;

        std::optional<int> camera; // Optional index of the camera in this node
        std::optional<int> mesh;   // Optional index of the mesh in this node
        std::vector<int> children; // Indices of child nodes

        void updateTransform()
        {
            // Construct the transformation matrix from translation, rotation, and scale
            transform = Eigen::Translation3f (translation) * rotation * Eigen::Scaling (scale);
        }
    };

    std::string getFullPathToBinary (const std::string& gltfFilePath, const std::string& bufferUri)
    {
        // Check if the URI is a data URI (base64 encoded)
        if (bufferUri.find ("data:") == 0)
        {
            // Handle data URI (base64 encoded)
            // This might involve decoding the base64 data into a buffer
            return ""; // Returning an empty string as data URIs do not have a file path
        }

        // Construct the full path
        std::filesystem::path gltfPath (gltfFilePath);
        std::filesystem::path dirPath = gltfPath.parent_path();
        std::filesystem::path fullPath = dirPath / bufferUri;

        return fullPath.string();
    }

    std::string convertToBinPath (const std::string& gltfPath)
    {
        std::string binPath = gltfPath;
        size_t pos = binPath.rfind (".gltf");

        // Check if '.gltf' is found in the string
        if (pos != std::string::npos)
        {
            // Replace '.gltf' with '.bin'
            binPath.replace (pos, 5, ".bin");
        }

        return binPath;
    }

    std::string convertToCustomBinPath (const std::string& gltfPath, const std::string& binNameIncludingExtension)
    {
        // Create a path object from the original file path
        std::filesystem::path pathObj (gltfPath);

        // Replace the filename in the path object with the new binName
        pathObj.replace_filename (binNameIncludingExtension);

        return pathObj.string();
    }

} // namespace

struct GLTFData
{
    Asset asset;

    std::vector<Accessor> accessors;
    std::vector<BufferView> bufferViews;
    std::vector<Mesh> meshes;
    std::vector<Buffer> buffers;
    std::vector<Scene> scenes;
    std::vector<Node> nodes;
    std::vector<Material> materials;
    std::vector<Texture> textures;
    std::vector<Sampler> samplers;
    std::vector<Image> images;
};
</file>

<file path="io/LWO3Layer.cpp">
LWO3Layer::LWO3Layer (std::shared_ptr<LWO3Form> root, size_t layerIndex) :
    root_ (root), 
    index_ (layerIndex)
{
    if (!root)
    {
        LOG (INFO) << "Null root form provided to LWO3Layer";
        return;
    }

    // Find and process TAGS chunk first since other chunks may reference tags
    if (const LWO3Chunk* tagsChunk = findChunk (sabi::LWO::TAGS))
    {
        if (!processTagsChunk (tagsChunk))
        {
            LOG (WARNING) << "Failed to process TAGS chunk for layer " << index_;
        }
    }

    // Find and process LAYR chunk
    if (const LWO3Chunk* layrChunk = findChunk ( sabi::LWO::LAYR))
    {
        if (!processLayrChunk (layrChunk))
        {
            LOG (WARNING) << "Failed to process LAYR chunk for index " << index_;
            return;
        }
    }

    // Find and process PNTS chunk
    if (const LWO3Chunk* pntsChunk = findChunk (sabi::LWO::PNTS))
    {
        if (!processPntsChunk (pntsChunk))
        {
            LOG (WARNING) << "Failed to process PNTS chunk for layer " << index_;
        }
    }

    // Find and process BBOX chunk
    if (const LWO3Chunk* bboxChunk = findChunk ( sabi::LWO::BBOX))
    {
        if (!processBBoxChunk (bboxChunk))
        {
            LOG (WARNING) << "Failed to process BBOX chunk for layer " << index_;
        }
    }

    // Find and process POLS chunk
    if (const LWO3Chunk* polsChunk = findChunk (sabi::LWO::POLS))
    {
        if (!processPolsChunk (polsChunk))
        {
            LOG (WARNING) << "Failed to process POLS chunk for layer " << index_;
        }
    }

    if (!processSurfaceForms ())
    {
        LOG (WARNING) << "Failed to process SURF forms for layer " << index_;
    }

    // Process PTAG chunks after POLS and TAGS
    if (const LWO3Chunk* ptagChunk = findChunk (sabi::LWO::PTAG))
    {
        if (!processPTagChunk (ptagChunk))
        {
            LOG (WARNING) << "Failed to process PTAG chunk for layer " << index_;
        }
    }

    //  after other chunk processing
    if (const LWO3Chunk* vmapChunk = findChunk (sabi::LWO::VMAP))
    {
        if (!processVMapChunk (vmapChunk))
        {
            LOG (WARNING) << "Failed to process VMAP chunk for layer " << index_;
        }
    }
}

bool LWO3Layer::processBBoxChunk (const LWO3Chunk* chunk)
{
    // BBOX chunk contains two Vector3f (24 bytes total)
    if (chunk->getData().size() != 24)
    {
        LOG (WARNING) << "Invalid BBOX chunk size: " << chunk->getData().size();
        return false;
    }

    BinaryReader reader (
        const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
        static_cast<uint32_t> (chunk->getData().size()));

    // Read min point
    float minX = mace::swapFloat (reader.ReadFloat());
    float minY = mace::swapFloat (reader.ReadFloat());
    float minZ = mace::swapFloat (reader.ReadFloat());

    // Read max point
    float maxX = mace::swapFloat (reader.ReadFloat());
    float maxY = mace::swapFloat (reader.ReadFloat());
    float maxZ = mace::swapFloat (reader.ReadFloat());

    bbox_.min() = Vector3f (minX, minY, minZ);
    bbox_.max() = Vector3f (maxX, maxY, maxZ);

    return true;
}

bool LWO3Layer::processPolsChunk (const LWO3Chunk* chunk)
{
    BinaryReader reader (
        const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
        static_cast<uint32_t> (chunk->getData().size()));

    // Read polygon type (FACE, PTCH, etc)
    polygonType_ = mace::swap32 (reader.ReadUint32());

    // Read polygons until we reach the end of the chunk
    while (reader.Position() < reader.Length())
    {
        // Read vertex count including flags
        uint16_t vertCountAndFlags = mace::swap16 (reader.ReadUint16());

        // Extract count and flags
        uint16_t flags = vertCountAndFlags & 0xFC00;     // High 6 bits
        uint16_t vertCount = vertCountAndFlags & 0x03FF; // Low 10 bits

        // Create new polygon
        LWPolygon poly;
        poly.flags = flags;
        poly.indices.reserve (vertCount);

        // Read vertex indices
        for (uint16_t i = 0; i < vertCount; i++)
        {
            // Use readVX to handle variable-length indices
            uint32_t index = mace::readVX (reader);
            poly.indices.push_back (index);
        }

        polygons_.push_back (std::move (poly));
    }

    return true;
}
const LWO3Chunk* LWO3Layer::findChunk (uint32_t chunkId, size_t startOffset)
{
    auto results = navigator_.findElementsById (root_.get(), chunkId);

    for (const auto& result : results)
    {
        if (!result.element->isForm())
        {
            const auto* chunk = static_cast<const LWO3Chunk*> (result.element);

            // For LAYR chunks, verify it's for our layer
            if (chunkId == sabi::LWO::LAYR)
            {
                BinaryReader reader (
                    const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
                    static_cast<uint32_t> (chunk->getData().size()));

                uint16_t layerNumber = mace::swap16 (reader.ReadUint16());
                if (layerNumber == index_)
                {
                    return chunk;
                }
            }
            else
            {
                if (chunk->getFileOffset() >= startOffset)
                {
                    return chunk;
                }
            }
        }
    }
    return nullptr;
}

bool LWO3Layer::processLayrChunk (const LWO3Chunk* chunk)
{
    BinaryReader reader (
        const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
        static_cast<uint32_t> (chunk->getData().size()));

    // Skip layer number since we already verified it
    reader.Skip (2);

    // Read flags
    flags_ = mace::swap16 (reader.ReadUint16());

    // Read pivot point
    float x = mace::swapFloat (reader.ReadFloat());
    float y = mace::swapFloat (reader.ReadFloat());
    float z = mace::swapFloat (reader.ReadFloat());
    pivot_ = Vector3f (x, y, z);

    // Read name
    name_ = reader.ReadNullTerminatedString();

    // Read parent index if there are remaining bytes
    if (reader.Position() < reader.Length())
    {
        parentIndex_ = mace::swap16 (reader.ReadInt16());
    }

    return true;
}

bool LWO3Layer::processPntsChunk (const LWO3Chunk* chunk)
{
    const auto& data = chunk->getData();
    BinaryReader reader (
        const_cast<char*> (reinterpret_cast<const char*> (data.data())),
        static_cast<uint32_t> (data.size()));

    // Each point is 12 bytes (3 x 4-byte floats)
    size_t numPoints = data.size() / 12;
    points_.reserve (numPoints);

    for (size_t i = 0; i < numPoints; i++)
    {
        float x = mace::swapFloat (reader.ReadFloat());
        float y = mace::swapFloat (reader.ReadFloat());
        float z = mace::swapFloat (reader.ReadFloat());
        points_.emplace_back (x, y, z);
    }

    return true;
}

bool LWO3Layer::processTagsChunk (const LWO3Chunk* chunk)
{
    BinaryReader reader (
        const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
        static_cast<uint32_t> (chunk->getData().size()));

    // Read strings until we reach end of chunk
    while (reader.Position() < reader.Length())
    {
        // Read null-terminated string
        std::string tag = reader.ReadNullTerminatedString();
        if (!tag.empty())
        {
            tags_.push_back (tag);
        }
        else
        {
            LOG (WARNING) << "Empty tag found in TAGS chunk";
        }

        // Handle padding - strings must be aligned to 2 bytes
        if (reader.Position() % 2 != 0)
        {
            reader.Skip (1);
        }
    }

    return !tags_.empty();
}

bool LWO3Layer::processPTagChunk (const LWO3Chunk* chunk)
{
    BinaryReader reader (
        const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
        static_cast<uint32_t> (chunk->getData().size()));

    // Read tag type (SURF, PART, etc)
    uint32_t tagType = mace::swap32 (reader.ReadUint32());

    // Create or get vector of tag indices for this type
    auto& tagIndices = polyTags_[tagType];

    // Ensure vector is sized to match number of polygons
    if (tagIndices.empty() && !polygons_.empty())
    {
        tagIndices.resize (polygons_.size(), 0);
    }

    // Read polygon/tag pairs until end of chunk
    while (reader.Position() < reader.Length())
    {
        // Read polygon index using variable-length format
        uint32_t polyIndex = mace::readVX (reader);

        // Read tag index
        uint16_t tagIndex = mace::swap16 (reader.ReadUint16());

        // Validate indices
        if (polyIndex >= polygons_.size())
        {
            LOG (WARNING) << "Invalid polygon index in PTAG chunk: " << polyIndex;
            continue;
        }

        if (tagType == sabi::LWO::SURF && tagIndex >= tags_.size())
        {
            LOG (WARNING) << "Invalid tag index in PTAG chunk: " << tagIndex;
            continue;
        }

        // Store tag index for this polygon
        tagIndices[polyIndex] = tagIndex;
    }

    return true;
}

bool LWO3Layer::processVMapChunk (const LWO3Chunk* chunk)
{
    BinaryReader reader (
        const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
        static_cast<uint32_t> (chunk->getData().size()));

    // Read map type (TXUV, WGHT, etc)
    uint32_t type = mace::swap32 (reader.ReadUint32());

    // Read dimension
    uint16_t dimension = mace::swap16 (reader.ReadUint16());

    // Read name
    std::string name = reader.ReadNullTerminatedString();

    
    // Skip any padding after name string to align to next vertex index
    reader.Align (2);


    // Create new vertex map
    VertexMap vmap;
    vmap.type = type;
    vmap.dimension = dimension;
    vmap.name = name;

    // Read vertex/value pairs until end of chunk
    while (reader.Position() < reader.Length())
    {
        // Read vertex index
        uint32_t vertIndex = mace::readVX (reader);
        vmap.vertexIndices.push_back (vertIndex);

        // Read dimension number of values
        for (uint16_t i = 0; i < dimension; i++)
        {
            float value = mace::swapFloat (reader.ReadFloat());
            // flip the V to match LW
            // lost hours trying to track this
            if (i == 1)
               value = 1.0f - value;
            vmap.values.push_back (value);
        }
    }

    vertexMaps_.push_back (std::move (vmap));
   
    return true;
}

std::vector<const VertexMap*> LWO3Layer::getVertexMaps (uint32_t type) const
{
    std::vector<const VertexMap*> maps;
    for (const auto& map : vertexMaps_)
    {
        if (map.type == type)
        {
            maps.push_back (&map);
        }
    }
    return maps;
}

const VertexMap* LWO3Layer::getVertexMapByName (const std::string& name) const
{
    for (const auto& map : vertexMaps_)
    {
        if (map.name == name)
        {
            return &map;
        }
    }
    return nullptr;
}

bool LWO3Layer::getVertexUV (uint32_t vertexIndex, float& u, float& v) const
{
    // Look for TXUV maps
    for (const auto& map : vertexMaps_)
    {
        if (map.type == sabi::LWO::TXUV && map.dimension == 2)
        {
            // Find vertex in this map
            for (size_t i = 0; i < map.vertexIndices.size(); i++)
            {
                if (map.vertexIndices[i] == vertexIndex)
                {
                    // Get UV values
                    u = map.values[i * 2];
                    v = map.values[i * 2 + 1];
                    return true;
                }
            }
        }
    }
    return false;
}

bool LWO3Layer::processSurfaceForms()
{
    if (!root_)
    {
        return false;
    }

    auto results = navigator_.findElementsById (root_.get(), sabi::LWO::SURF);
    if (results.empty())
    {
        LOG (WARNING) << "No SURF forms found";
        return false;
    }

    for (const auto& result : results)
    {
        if (!result.element->isForm())
        {
            continue;
        }

        const auto* surfForm = static_cast<const LWO3Form*> (result.element);

        std::string surfaceName;
        std::string parentName;

        for (const auto& child : surfForm->getChildren())
        {
            if (!child->isForm() && child->getId() == sabi::LWO::ANON)
            {
                BinaryReader reader (
                    const_cast<char*> (reinterpret_cast<const char*> (
                        static_cast<const LWO3Chunk*> (child.get())->getData().data())),
                    static_cast<uint32_t> (static_cast<const LWO3Chunk*> (child.get())->getData().size()));

                surfaceName = reader.ReadNullTerminatedString();
                if (reader.Position() < reader.Length())
                {
                    parentName = reader.ReadNullTerminatedString();
                }
                break;
            }
        }

        if (surfaceName.empty())
        {
            LOG (WARNING) << "Invalid SURF form - missing name";
            continue;
        }

        // Create surface
        auto surface = std::make_shared<LWO3Surface> (surfaceName);

        // Pass shared root form to node graph
        surface->setNodeGraph (std::make_unique<LWO3NodeGraph> (root_));

        surfaces_.push_back (surface);
    }

    return !surfaces_.empty();
}


LWO3Surface* LWO3Layer::getSurfaceByName (const std::string& name)
{
    for (auto& surf : surfaces_)
    {
        if (surf->getName() == name)
        {
            return surf.get();
        }
    }
    return nullptr;
}

const LWO3Surface* LWO3Layer::getSurfaceByName (const std::string& name) const
{
    for (const auto& surf : surfaces_)
    {
        if (surf->getName() == name)
        {
            return surf.get();
        }
    }
    return nullptr;
}

LWO3Surface* LWO3Layer::getPolygonSurface (size_t polyIndex)
{
    // Get surface tag index for this polygon
    int tagIndex = getPolygonTagIndex (polyIndex, sabi::LWO::SURF);
    if (tagIndex < 0 || tagIndex >= tags_.size())
    {
        return nullptr;
    }

    // Get surface name from tag
    const std::string& surfaceName = tags_[tagIndex];
    return getSurfaceByName (surfaceName);
}

const LWO3Surface* LWO3Layer::getPolygonSurface (size_t polyIndex) const
{
    // Get surface tag index for this polygon
    int tagIndex = getPolygonTagIndex (polyIndex, sabi::LWO::SURF);
    if (tagIndex < 0 || tagIndex >= tags_.size())
    {
        return nullptr;
    }

    // Get surface name from tag
    const std::string& surfaceName = tags_[tagIndex];
    return getSurfaceByName (surfaceName);
}
</file>

<file path="io/LWO3Layer.h">
#pragma once

// LWO3Layer: Represents a layer within a LightWave Object
// Layers are the primary organizational structure in LWO3 files containing
// geometry, surfaces, and transformational data. Each layer has its own
// coordinate space defined by its pivot point and can contain multiple
// surfaces with associated vertices and polygons.

using Eigen::Affine3f;
using Eigen::AlignedBox3f;
using Eigen::Quaternionf;
using Eigen::Vector3f;

using sabi::BSDFInput;
using sabi::LWO3Navigator;
using sabi::LWO3NodeGraph;
using sabi::LWO3Surface;
using sabi::NodeConnection;

// Structure to represent a polygon
struct LWPolygon
{
    std::vector<uint32_t> indices; // Vertex indices
    uint16_t flags = 0;            // High 6 bits from vertex count
};

// Structure to hold vertex map data
struct VertexMap
{
    uint32_t type;                       // TXUV, WGHT, etc
    uint16_t dimension;                  // Number of values per vertex
    std::string name;                    // Map name
    std::vector<uint32_t> vertexIndices; // Indices of mapped vertices
    std::vector<float> values;           // Dimension * vertexIndices.size() values
};

class LWO3Layer
{
 public:
    // Constructs a layer from a LAYR chunk in the LWO3 form
    LWO3Layer (std::shared_ptr<LWO3Form> root, size_t layerIndex);

    // Gets the layer's index number
    size_t getIndex() const { return index_; }

    // Gets the layer's flags (bit 0 = visibility)
    uint16_t getFlags() const { return flags_; }

    // Gets the layer's pivot point
    const Vector3f& getPivot() const { return pivot_; }

    // Gets the layer's name
    const std::string& getName() const { return name_; }

    // Gets the parent layer index (-1 if no parent)
    int16_t getParentIndex() const { return parentIndex_; }

    // Should return false if bit 0 is set (hidden), true otherwise
    bool isVisible() const { return (flags_ & 1) == 0; }

    // Gets the layer's points/vertices
    const std::vector<Vector3f>& getPoints() const { return points_; }

    // Get the layer's bounding box
    const AlignedBox3f& getBoundingBox() const { return bbox_; }

    // Get polygon type (FACE, PTCH, etc)
    uint32_t getPolygonType() const { return polygonType_; }

    // Get all polygons
    const std::vector<LWPolygon>& getPolygons() const { return polygons_; }

    // Check if polygons are of specific type
    bool isType (uint32_t type) const { return polygonType_ == type; }

    // Get all surface tags
    const std::vector<std::string>& getTags() const { return tags_; }

    // Get tag at specific index
    const std::string& getTag (size_t index) const
    {
        return index < tags_.size() ? tags_[index] : emptyTag_;
    }

    // Get surface tag index for a polygon
    int getPolygonTagIndex (uint32_t polyIndex, uint32_t tagType) const
    {
        auto it = polyTags_.find (tagType);
        if (it != polyTags_.end() && polyIndex < it->second.size())
        {
            return it->second[polyIndex];
        }
        return -1;
    }

    // Get surface tag name for a polygon
    std::string getPolygonTag (uint32_t polyIndex, uint32_t tagType) const
    {
        int tagIndex = getPolygonTagIndex (polyIndex, tagType);
        if (tagIndex >= 0 && tagIndex < tags_.size())
        {
            return tags_[tagIndex];
        }
        return "";
    }

    // Gets all vertex maps of a specific type
    std::vector<const VertexMap*> getVertexMaps (uint32_t type) const;

    // Gets a vertex map by name
    const VertexMap* getVertexMapByName (const std::string& name) const;

    // Gets UV coordinates for a vertex if they exist
    bool getVertexUV (uint32_t vertexIndex, float& u, float& v) const;

    // Get all surfaces used by this layer
    const std::vector<std::shared_ptr<LWO3Surface>>& getSurfaces() const { return surfaces_; }

    // Get surface by name
    LWO3Surface* getSurfaceByName (const std::string& name);
    const LWO3Surface* getSurfaceByName (const std::string& name) const;

    // Get surface used by a specific polygon
    LWO3Surface* getPolygonSurface (size_t polyIndex);
    const LWO3Surface* getPolygonSurface (size_t polyIndex) const;

 private:
    LWO3Navigator navigator_;
    std::shared_ptr<LWO3Form> root_;

    size_t index_ = 0;
    uint16_t flags_ = 0;
    Vector3f pivot_ = Vector3f::Zero();
    std::string name_;
    int16_t parentIndex_ = -1;

    uint32_t polygonType_ = 0;        // Type of polygons (FACE, PTCH, etc)
    std::vector<LWPolygon> polygons_; // List of polygons

    std::vector<std::string> tags_; // List of surface tags
    const std::string emptyTag_;    // Empty string for invalid indices

    // Map of tag type to vector of tag indices
    // Key is tag type (SURF, PART, etc)
    // Value is vector of indices into tags_ array, one per polygon
    std::map<uint32_t, std::vector<uint16_t>> polyTags_;

    std::vector<Vector3f> points_;
    AlignedBox3f bbox_; // Stores min/max corners of bounding box

    std::vector<VertexMap> vertexMaps_;

    std::vector<std::shared_ptr<LWO3Surface>> surfaces_;

    // Chunk processing functions
    bool processLayrChunk (const LWO3Chunk* chunk);
    bool processPntsChunk (const LWO3Chunk* chunk);
    bool processBBoxChunk (const LWO3Chunk* chunk);
    bool processPolsChunk (const LWO3Chunk* chunk);
    bool processTagsChunk (const LWO3Chunk* chunk);
    bool processPTagChunk (const LWO3Chunk* chunk);
    bool processVMapChunk (const LWO3Chunk* chunk);
    bool processSurfaceForms();

    // Helper to find specific chunk
    const LWO3Chunk* findChunk (uint32_t chunkId, size_t startOffset = 0);
};
</file>

<file path="io/LWO3Material.cpp">
LWO3Material::LWO3Material (const std::string& name, std::shared_ptr<LWO3Form> root, const LWO3Form* surfForm) :
    name_ (name),
    surfForm_ (surfForm)
{
    if (!root || !surfForm)
    {
        LOG (WARNING) << "Null form provided to LWO3Material: " << name;
        return;
    }

    // Create temporary node graph to extract node data
    LWO3NodeGraph nodeGraph (root, surfForm);

    // Extract image nodes
    imageNodes_ = nodeGraph.getImageNodes();

    // Extract BSDF nodes
    bsdfNodes_ = nodeGraph.getPrincipledBSDFNodes();

    // Extract Standard nodes
    standardNodes_ = nodeGraph.getStandardNodes();

    // Get all node connections
    for (const auto& node : nodeGraph.getNodesByType())
    {
        for (const auto& nodeName : node.second)
        {
            auto connections = nodeGraph.getNodeConnections (nodeName);
            nodeConnections_.insert (nodeConnections_.end(),
                                     connections.begin(),
                                     connections.end());
        }
    }

    //LOG (DBUG) << "Created material " << name
    //           << " with " << imageNodes_.size() << " image nodes, "
    //           << bsdfNodes_.size() << " BSDF nodes, "
    //           << standardNodes_.size() << " Standard nodes";
}

// Gets image node connected to specific BSDF input socket if one exists
std::optional<ImageNodeInfo> LWO3Material::getBSDFImageNode (BSDFInput input) const
{
    std::string inputName = getBSDFInputName (input);

    // Search all image nodes for connection to this BSDF input
    for (const auto& img : imageNodes_)
    {
        for (const auto& conn : img.connections)
        {
            if (conn.targetNode.find ("Principled BSDF") != std::string::npos &&
                conn.inputName == inputName)
            {
                return img;
            }
        }
    }
    return std::nullopt;
}

float LWO3Material::getMaxSmoothingAngle() const
{
    if (!surfForm_)
    {
        return 0.0f;
    }

    for (const auto& child : surfForm_->getChildren())
    {
        if (!child->isForm() && child->getId() == LWO::SMAN)
        {
            const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
            if (chunk->getData().size() >= 4)
            {
                BinaryReader reader (
                    const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
                    static_cast<uint32_t> (chunk->getData().size()));

                float angle = mace::swapFloat (reader.ReadFloat());
               /* LOG (DBUG) << "Found max smoothing angle for material '" << name_
                           << "': " << angle << " radians";*/
                return angle;
            }
        }
    }

    //LOG (DBUG) << "No smoothing angle found for material '" << name_ << "', using default of 0.0";
    return 0.0f;
}
</file>

<file path="io/LWO3Material.h">
// LWO3Material: Represents a single material from an LWO3 file including its node network
// Extracts and manages material properties from both Standard and Principled BSDF nodes
// Provides access to connected texture maps and material parameters
// Supports both legacy Standard material nodes and modern physically-based BSDF nodes

#pragma once

class LWO3Material
{
 public:
    // Initialize material with surface name
    LWO3Material (const std::string& name, std::shared_ptr<LWO3Form> root, const LWO3Form* surfForm);

    const std::string& getName() const { return name_; }
    const std::vector<ImageNodeInfo>& getImageNodes() const { return imageNodes_; }
    const std::vector<PrincipledBSDFInfo>& getBSDFNodes() const { return bsdfNodes_; }
    const std::vector<StandardNodeInfo>& getStandardNodes() const { return standardNodes_; }

    // Gets image node connected to specific BSDF input
    std::optional<ImageNodeInfo> getBSDFImageNode (BSDFInput input) const;

    // Gets whether this material uses Standard or BSDF nodes
    bool usesStandardNodes() const { return !standardNodes_.empty(); }
    bool usesBSDFNodes() const { return !bsdfNodes_.empty(); }

    const LWO3Form* getSurfaceForm() const { return surfForm_; }
    float getMaxSmoothingAngle() const;

 private:
    std::string name_;
    const LWO3Form* surfForm_;
    std::vector<ImageNodeInfo> imageNodes_;
    std::vector<PrincipledBSDFInfo> bsdfNodes_;
    std::vector<StandardNodeInfo> standardNodes_;
    std::vector<NodeConnection> nodeConnections_;
};
</file>

<file path="io/LWO3MaterialManager.cpp">
//#include "LWO3Navigator.h"
//#include "LWO3MaterialManager.h"

LWO3MaterialManager::LWO3MaterialManager (std::shared_ptr<LWO3Form> root)
{
    if (root)
    {
        extractMaterials (root);
    }
    else
    {
        LOG (WARNING) << "Null root form provided to LWO3MaterialManager";
    }
}
void LWO3MaterialManager::extractMaterials (std::shared_ptr<LWO3Form> root)
{
    LWO3Navigator nav;
    auto results = nav.findElementsById (root.get(), LWO::SURF);

    for (const auto& result : results)
    {
        if (!result.element->isForm()) continue;

        const auto* surfForm = static_cast<const LWO3Form*> (result.element);

        // Find surface name in ANON chunk
        for (const auto& child : surfForm->getChildren())
        {
            if (!child->isForm() && child->getId() == LWO::ANON)
            {
                const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                BinaryReader reader (
                    const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
                    static_cast<uint32_t> (chunk->getData().size()));

                std::string surfaceName = reader.ReadNullTerminatedString();
                if (!surfaceName.empty())
                {
                    materials_.push_back (std::make_shared<LWO3Material> (surfaceName, root, surfForm));
                }
            }
        }
    }
}

const LWO3Material* LWO3MaterialManager::getMaterial (const std::string& surfaceName) const
{
    auto it = std::find_if (materials_.begin(), materials_.end(),
                            [&] (const auto& mat)
                            { return mat->getName() == surfaceName; });
    return it != materials_.end() ? it->get() : nullptr;
}
</file>

<file path="io/LWO3MaterialManager.h">
#pragma once

//#include "LWO3Material.h"

// Manages extraction and access to all materials from an LWO3 file
class LWO3MaterialManager
{
 public:
    explicit LWO3MaterialManager (std::shared_ptr<LWO3Form> root);

    // Get material by surface name
    const LWO3Material* getMaterial (const std::string& surfaceName) const;

    // Get all materials
    const std::vector<std::shared_ptr<LWO3Material>>& getMaterials() const
    {
        return materials_;
    }

 private:
    std::vector<std::shared_ptr<LWO3Material>> materials_;
    void extractMaterials (std::shared_ptr<LWO3Form> root);
};
</file>

<file path="io/LWO3Navigator.h">
#pragma once

// LWO3Navigator: Utility class for navigating and debugging LWO3 file structures
// Provides methods to find, validate and inspect forms/chunks using their file offsets


class LWO3Navigator
{
 public:
    // Search modes for findElementsById
    enum class SearchMode
    {
        ALL,          // Find all matching elements
        FIRST,        // Find first match only
        WITHIN_OFFSET // Find elements within offset range
    };

    struct SearchResult
    {
        const LWO3Element* element;
        std::vector<const LWO3Element*> path; // Path from root to element
    };

    // Find elements by ID with optional offset constraints
    std::vector<SearchResult> findElementsById (
        const LWO3Form* root,
        uint32_t targetId,
        SearchMode mode = SearchMode::ALL,
        size_t startOffset = 0,
        size_t endOffset = std::numeric_limits<size_t>::max())
    {
        std::vector<SearchResult> results;
        std::vector<const LWO3Element*> currentPath;
        findElementsByIdImpl (root, targetId, mode, startOffset, endOffset, currentPath, results);
        return results;
    }

    // Get element at specific file offset
    const LWO3Element* findElementAtOffset (const LWO3Form* root, size_t targetOffset)
    {
        if (!root || root->getFileOffset() > targetOffset)
        {
            return nullptr;
        }

        // Check each child
        for (const auto& child : root->getChildren())
        {
            if (child->getFileOffset() == targetOffset)
            {
                return child.get();
            }

            // If child is a form and target is within its range, recurse
            if (child->isForm())
            {
                if (auto* found = findElementAtOffset (
                        static_cast<const LWO3Form*> (child.get()),
                        targetOffset))
                {
                    return found;
                }
            }
        }
        return nullptr;
    }

    // Print hierarchy with offsets for debugging
    void dumpHierarchy (const LWO3Form* root, std::ostream& out = std::cout)
    {
        dumpHierarchyImpl (root, 0, out);
    }

    // Get parent element of a given offset
    const LWO3Form* findParentOfOffset (
        const LWO3Form* root,
        size_t childOffset,
        std::vector<const LWO3Form*>* path = nullptr)
    {
        if (!root || childOffset < root->getFileOffset())
        {
            return nullptr;
        }

        for (const auto& child : root->getChildren())
        {
            if (child->getFileOffset() == childOffset)
            {
                if (path)
                {
                    path->push_back (root);
                }
                return root;
            }

            if (child->isForm())
            {
                const LWO3Form* found = findParentOfOffset (
                    static_cast<const LWO3Form*> (child.get()),
                    childOffset,
                    path);
                if (found)
                {
                    if (path)
                    {
                        path->push_back (root);
                    }
                    return found;
                }
            }
        }
        return nullptr;
    }

    // Validate offset ordering
    bool validateOffsetOrdering (const LWO3Form* root, std::ostream& errors = std::cerr)
    {
        bool valid = true;
        size_t lastOffset = root->getFileOffset();

        for (const auto& child : root->getChildren())
        {
            if (child->getFileOffset() <= lastOffset)
            {
                errors << "Invalid offset ordering at 0x"
                       << std::hex << child->getFileOffset()
                       << " (previous: 0x" << lastOffset << ")\n";
                valid = false;
            }
            lastOffset = child->getFileOffset();

            if (child->isForm())
            {
                valid &= validateOffsetOrdering (
                    static_cast<const LWO3Form*> (child.get()),
                    errors);
            }
        }
        return valid;
    }

 private:
    void findElementsByIdImpl (
        const LWO3Form* form,
        uint32_t targetId,
        SearchMode mode,
        size_t startOffset,
        size_t endOffset,
        std::vector<const LWO3Element*>& currentPath,
        std::vector<SearchResult>& results)
    {
        currentPath.push_back (form);

        for (const auto& child : form->getChildren())
        {
            size_t offset = child->getFileOffset();

            // Check offset range
            if (offset < startOffset || offset > endOffset)
            {
                continue;
            }

            // Check for match
            if (child->getId() == targetId)
            {
                results.push_back ({child.get(), currentPath});
                if (mode == SearchMode::FIRST)
                {
                    return;
                }
            }

            // Recurse into forms
            if (child->isForm())
            {
                findElementsByIdImpl (
                    static_cast<const LWO3Form*> (child.get()),
                    targetId,
                    mode,
                    startOffset,
                    endOffset,
                    currentPath,
                    results);
            }
        }

        currentPath.pop_back();
    }

    void dumpHierarchyImpl (
        const LWO3Element* element,
        int depth,
        std::ostream& out)
    {
        std::string indent (depth * 2, ' ');
        out << indent << "0x" << std::hex << element->getFileOffset()
            << ": " << idToString (element->getId());

        if (!element->isForm())
        {
            const auto* chunk = static_cast<const LWO3Chunk*> (element);
            out << " (size: " << std::dec << chunk->getData().size() << ")";
        }
        out << "\n";

        if (element->isForm())
        {
            const auto* form = static_cast<const LWO3Form*> (element);
            for (const auto& child : form->getChildren())
            {
                dumpHierarchyImpl (child.get(), depth + 1, out);
            }
        }
    }
};
</file>

<file path="io/LWO3NodeData.h">
#pragma once




// Node connection information
struct NodeConnection
{
    std::string sourceNode;
    std::string targetNode;
    std::string outputName;
    std::string inputName;
};

// Image node information
struct ImageNodeInfo
{
    std::string nodeName;
    std::string imagePath;
    size_t nodeOffset;
    bool enabled = true;
    std::string uvMapName;
    std::vector<NodeConnection> connections;
};

struct ImageConnection
{
    ImageNodeInfo imageNode;
    std::string bsdfInputSocket; // Which BSDF input it connects to
};

struct StandardNodeInfo
{
    std::string nodeName;
    size_t nodeOffset;
    bool enabled = true;

    // Material properties
    Eigen::Vector3f color = Eigen::Vector3f (0.5f, 0.5f, 0.5f);
    float luminosity = 0.0f;
    float diffuse = 1.0f;
    float specular = 0.75f;
    float glossiness = 0.21f;
    float reflection = 0.0f;
    float transparency = 0.0f;
    float refractionIndex = 1.0f;
    float refractionBlur = 0.0f;
    float translucency = 0.0f;
    float colorHighlight = 0.0f;
    float colorFilter = 0.0f;
    float diffuseSharpness = 0.0f;
    float bumpHeight = 1.0f;

    std::vector<NodeConnection> connections;
};

struct PrincipledBSDFInfo
{
    std::string nodeName;
    size_t nodeOffset;
    bool enabled = true;

    // Base properties
    Eigen::Vector3f baseColor = Eigen::Vector3f (1.0f, 1.0f, 1.0f);
    float roughness = 0.5f;
    float metallic = 0.0f;
    float specular = 0.0f;
    float specularTint = 0.0f;

    // Sheen properties
    float sheen = 0.0f;
    float sheenTint = 0.0f;

    // Transparency & Transmission
    float transparency = 0.0f;
    float translucency = 0.0f;
   // float transmission = 0.0f;
    Eigen::Vector3f transmittance = Eigen::Vector3f (1.0f, 1.0f, 1.0f);
    float transmittanceDistance = 0.0f;

    // Subsurface properties
    float subsurface = 0.0f;
    float subsurfaceDistance = 0.0f;
    float flatness = 0.0f;
    Eigen::Vector3f subsurfaceColor = Eigen::Vector3f (1.0f, 1.0f, 1.0f);

    // Clearcoat
    float clearcoat = 0.0f;
    float clearcoatGloss = 0.0f;

    // Special effects
    float anisotropic = 0.0f;
    float anisotropicRotation = 0.0f;
    bool thinWalled = false;
    float asymmetry = 0.0f;

    // Emission
    float luminous = 0.0f;
    Eigen::Vector3f luminousColor = Eigen::Vector3f (0.0f, 0.0f, 0.0f);

    // Index of refraction
    float ior = 1.52f;

    std::vector<NodeConnection> connections;
};

struct NodeSocketDef
{
    std::string name;
    std::string type; // e.g., "Color", "Float", "Vector"
    bool isInput;     // true for input socket, false for output
    bool isConnected; // true if socket has a connection
};

struct NodeSocketInfo
{
    std::string nodeName;
    std::string nodeType;
    std::vector<NodeSocketDef> sockets;
};

// BSDFInput: Represents possible input sockets on a Principled BSDF node
enum class BSDFInput
{
    Color,
    Roughness,
    Normal,
    Metallic,
    Specular,
    SpecularTint,
    Sheen,
    SheenTint,
    Clearcoat,
    ClearcoatRoughness,
    Transparency,
    Translucency,
    Flatness,
    SubsurfaceDistance,
    SubsurfaceScattering,
    Distance,
    Asymmetry,
    Luminous,
    LuminousColor,
    Transmittance,
    TransmittanceDistance,
    Anisotropic,
    AnisotropicRotation,
    Projection
};

// Helper to convert BSDFInput enum to the actual input name used in LightWave
inline std::string getBSDFInputName (BSDFInput input)
{
    switch (input)
    {
        case BSDFInput::Color:
            return "Color";
        case BSDFInput::Roughness:
            return "Roughness";
        case BSDFInput::Normal:
            return "Normal";
        case BSDFInput::Metallic:
            return "Metallic";
        case BSDFInput::Specular:
            return "Specular";
        case BSDFInput::SpecularTint:
            return "Specular Tint";
        case BSDFInput::Sheen:
            return "Sheen";
        case BSDFInput::SheenTint:
            return "Sheen Tint";
        case BSDFInput::Clearcoat:
            return "Clearcoat";
        case BSDFInput::ClearcoatRoughness:
            return "Clearcoat Gloss";
        case BSDFInput::Transparency:
            return "Transparency";
        case BSDFInput::Translucency:
            return "Translucency";
        case BSDFInput::Flatness:
            return "Flatness";
        case BSDFInput::SubsurfaceDistance:
            return "Distance";
        case BSDFInput::SubsurfaceScattering:
            return "Subsurface Scattering";
        case BSDFInput::Distance:
            return "Distance";
        case BSDFInput::Asymmetry:
            return "Asymmetry";
        case BSDFInput::Luminous:
            return "Luminous";
        case BSDFInput::LuminousColor:
            return "Luminous Color";
        case BSDFInput::Transmittance:
            return "Transmittance";
        case BSDFInput::TransmittanceDistance:
            return "Transmittance Distance";
        case BSDFInput::Anisotropic:
            return "Anisotropic";
        case BSDFInput::AnisotropicRotation:
            return "Rotation";
        case BSDFInput::Projection:
            return "Projection";
        default:
            return "";
    }
}
</file>

<file path="io/LWO3NodeGraph.cpp">
//#include "LWO3NodeGraph.h" 
//#include "LWO3Navigator.h"

LWO3NodeGraph::LWO3NodeGraph (std::shared_ptr<LWO3Form> root, const LWO3Form* surfForm) :
    root_ (root),
    surfForm_ (surfForm),
    surfaceName_()
{
    if (!root_ || !surfForm_)
    {
        // LOG (WARNING) << "Null form provided to LWO3NodeGraph";
        return;
    }
    extractSurfaceName();
    extractNodeNames();
}



void LWO3NodeGraph::extractSurfaceName()
{
    // Surface name is in the ANON chunk of the surfForm
    for (const auto& child : surfForm_->getChildren())
    {
        if (!child->isForm() && child->getId() == LWO::ANON)
        {
            const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
            BinaryReader reader (
                const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
                static_cast<uint32_t> (chunk->getData().size()));
            surfaceName_ = reader.ReadNullTerminatedString();
            return;
        }
    }
}

void LWO3NodeGraph::extractNodeNames()
{
    // First find the NODS form within our surface
    const LWO3Form* nodsForm = nullptr;
    for (const auto& child : surfForm_->getChildren())
    {
        if (child->isForm() && child->getId() == LWO::NODS)
        {
            nodsForm = static_cast<const LWO3Form*> (child.get());
            break;
        }
    }

    if (!nodsForm)
    {
        // LOG (WARNING) << "No NODS form found in surface: " << surfaceName_;
        return;
    }

    // Now find all NSRV chunks within this NODS form's hierarchy
    LWO3Navigator nav;
    auto results = nav.findElementsById (nodsForm, LWO::NSRV);

    for (const auto& result : results)
    {
        const auto* nsrvChunk = static_cast<const LWO3Chunk*> (result.element);
        std::string nodeType = std::string (reinterpret_cast<const char*> (nsrvChunk->getData().data()));

        // Find associated NTAG form
        const LWO3Form* parent = static_cast<const LWO3Form*> (result.path.back());
        const LWO3Form* ntagForm = nullptr;

        bool foundNsrv = false;
        for (const auto& child : parent->getChildren())
        {
            if (foundNsrv && child->getId() == LWO::NTAG)
            {
                ntagForm = static_cast<const LWO3Form*> (child.get());
                break;
            }
            if (child.get() == nsrvChunk)
            {
                foundNsrv = true;
            }
        }

        if (!ntagForm)
        {
            // LOG (WARNING) << "Could not find NTAG form after NSRV in surface: " << surfaceName_;
            continue;
        }

        std::string refName;

        // Get node name from NNME chunk
        for (const auto& child : ntagForm->getChildren())
        {
            if (!child->isForm() && child->getId() == LWO::NNME)
            {
                const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                refName = std::string (reinterpret_cast<const char*> (chunk->getData().data()));
                break;
            }
        }

        if (!refName.empty())
        {
            nodeNames_.emplace_back (refName, nsrvChunk->getFileOffset());
            nodesByType_[nodeType].push_back (refName);
            // LOG (DBUG) << "Found node: " << refName << " of type: " << nodeType
                    //    << " in surface: " << surfaceName_;
        }
    }
}

std::vector<ImageNodeInfo> LWO3NodeGraph::getImageNodes() const
{
    std::vector<ImageNodeInfo> imageNodes;
    auto it = nodesByType_.find ("Image");
    if (it == nodesByType_.end())
    {
        return imageNodes;
    }

    LWO3Navigator nav;
    for (const std::string& nodeName : it->second)
    {
        ImageNodeInfo info;
        info.nodeName = nodeName;
        info.enabled = true;

        // Find this node's NTAG form
        auto nodeResults = nav.findElementsById (surfForm_, LWO::NTAG);
        for (const auto& result : nodeResults)
        {
            const auto* ntagForm = static_cast<const LWO3Form*> (result.element);

            // Verify this is our target node
            bool found = false;
            for (const auto& child : ntagForm->getChildren())
            {
                if (!child->isForm() && child->getId() == LWO::NNME)
                {
                    const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                    if (std::string (reinterpret_cast<const char*> (chunk->getData().data())) == nodeName)
                    {
                        found = true;
                        break;
                    }
                }
            }

            if (!found) continue;

            // Extract image data
            for (const auto& child : ntagForm->getChildren())
            {
                if (!child->isForm() && child->getId() == LWO::NSTA)
                {
                    const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                    if (!chunk->getData().empty())
                    {
                        info.enabled = chunk->getData()[0] != 0;
                    }
                }
                else if (child->isForm() && child->getId() == LWO::NDTA)
                {
                    const auto* ndtaForm = static_cast<const LWO3Form*> (child.get());
                    info.imagePath = extractImagePathFromNDTA (ndtaForm);
                    // LOG (DBUG) << "--------------------" <<  info.imagePath;
                    // Get UV map name
                    auto iuviResults = nav.findElementsById (ndtaForm, LWO::IUVI);
                    if (!iuviResults.empty())
                    {
                        const auto* iuviChunk = static_cast<const LWO3Chunk*> (iuviResults[0].element);
                        info.uvMapName = std::string (reinterpret_cast<const char*> (iuviChunk->getData().data()));
                    }

                    if (!info.imagePath.empty())
                    {
                        info.connections = getNodeConnections (nodeName);
                        // LOG (DBUG) << "Found image node: " << info.nodeName
                            //        << " using " << info.imagePath
                            //        << " in surface: " << surfaceName_;
                        imageNodes.push_back (info);
                        break;
                    }
                }
            }
        }
    }

    return imageNodes;
}

// Extract image path from NDTA form ensuring proper path formatting
std::string LWO3NodeGraph::extractImagePathFromNDTA (const LWO3Form* ndtaForm) const
{
    // Find IIMG form first
    LWO3Navigator nav;
    auto iimgResults = nav.findElementsById (ndtaForm, LWO::IIMG);
    if (!iimgResults.empty())
    {
        const auto* iimgForm = static_cast<const LWO3Form*> (iimgResults[0].element);

        // Find CLIP form
        auto clipResults = nav.findElementsById (iimgForm, LWO::CLIP);
        if (!clipResults.empty())
        {
            const auto* clipForm = static_cast<const LWO3Form*> (clipResults[0].element);

            // Find STIL form
            auto stilResults = nav.findElementsById (clipForm, LWO::STIL);
            if (!stilResults.empty())
            {
                const auto* stilForm = static_cast<const LWO3Form*> (stilResults[0].element);

                // Get path from anonymous chunk
                for (const auto& child : stilForm->getChildren())
                {
                    if (!child->isForm() &&
                        static_cast<const LWO3Chunk*> (child.get())->getId() == LWO::ANON)
                    {
                        const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                        std::string path = std::string (reinterpret_cast<const char*> (chunk->getData().data()));

                        // Fix path formatting - add slash after drive letter if missing
                        if (path.length() >= 2 && path[1] == ':' &&
                            (path.length() == 2 || (path[2] != '/' && path[2] != '\\')))
                        {
                            path.insert (2, 1, '/');
                            // LOG (DBUG) << "Fixed path formatting: " << path;
                        }

                        return path;
                    }
                }
            }
        }
    }
    return "";
}

std::vector<StandardNodeInfo> LWO3NodeGraph::getStandardNodes() const
{
    std::vector<StandardNodeInfo> standardNodes;
    auto it = nodesByType_.find ("Standard");
    if (it == nodesByType_.end())
    {
        return standardNodes;
    }

    LWO3Navigator nav;
    for (const std::string& nodeName : it->second)
    {
        StandardNodeInfo info;
        info.nodeName = nodeName;
        info.enabled = true; // Default to enabled

        // Find this node's NTAG form within surfForm_
        auto nodeResults = nav.findElementsById (surfForm_, LWO::NTAG);
        for (const auto& result : nodeResults)
        {
            const auto* ntagForm = static_cast<const LWO3Form*> (result.element);

            // Verify this is our target node by matching NNME
            bool found = false;
            for (const auto& child : ntagForm->getChildren())
            {
                if (!child->isForm() && child->getId() == LWO::NNME)
                {
                    const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                    if (std::string (reinterpret_cast<const char*> (chunk->getData().data())) == nodeName)
                    {
                        found = true;
                        break;
                    }
                }
            }

            if (!found) continue;

            // Process node data
            for (const auto& child : ntagForm->getChildren())
            {
                if (!child->isForm())
                {
                    if (child->getId() == LWO::NSTA)
                    {
                        const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                        if (!chunk->getData().empty())
                        {
                            info.enabled = chunk->getData()[0] != 0;
                        }
                    }
                }
                else if (child->getId() == LWO::NDTA)
                {
                    extractStandardValues (static_cast<const LWO3Form*> (child.get()), info);
                }
            }

            info.connections = getNodeConnections (nodeName);
            // LOG (DBUG) << "Found Standard node: " << info.nodeName
                     //   << " in surface: " << surfaceName_
                    //    << " enabled: " << info.enabled;

            standardNodes.push_back (info);
            break; // Found and processed our node
        }
    }

    return standardNodes;
}
std::vector<PrincipledBSDFInfo> LWO3NodeGraph::getPrincipledBSDFNodes() const
{
    std::vector<PrincipledBSDFInfo> bsdfNodes;
    auto it = nodesByType_.find ("Principled BSDF");
    if (it == nodesByType_.end())
    {
        return bsdfNodes;
    }

    LWO3Navigator nav;
    for (const std::string& nodeName : it->second)
    {
        PrincipledBSDFInfo info;
        info.nodeName = nodeName;
        info.enabled = true; // Default to enabled

        // Find this node's NTAG form
        auto nodeResults = nav.findElementsById (surfForm_, LWO::NTAG);
        for (const auto& result : nodeResults)
        {
            const auto* ntagForm = static_cast<const LWO3Form*> (result.element);

            // Verify this is our target node
            bool found = false;
            for (const auto& child : ntagForm->getChildren())
            {
                if (!child->isForm() && child->getId() == LWO::NNME)
                {
                    const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                    if (std::string (reinterpret_cast<const char*> (chunk->getData().data())) == nodeName)
                    {
                        found = true;
                        break;
                    }
                }
            }

            if (!found) continue;

            // Process node data
            for (const auto& child : ntagForm->getChildren())
            {
                if (!child->isForm())
                {
                    if (child->getId() == LWO::NSTA)
                    {
                        const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                        if (!chunk->getData().empty())
                        {
                            info.enabled = chunk->getData()[0] != 0;
                        }
                    }
                }
                else if (child->getId() == LWO::NDTA)
                {
                    extractPrincipledBSDFValues (static_cast<const LWO3Form*> (child.get()), info);
                }
            }

            info.connections = getNodeConnections (nodeName);
            // LOG (DBUG) << "Found Principled BSDF node: " << info.nodeName
                    //    << " in surface: " << surfaceName_
                      //  << " enabled: " << info.enabled;

            bsdfNodes.push_back (info);
            break; // Found and processed our node
        }
    }

    return bsdfNodes;
}

void LWO3NodeGraph::extractPrincipledBSDFValues (const LWO3Form* ndtaForm, PrincipledBSDFInfo& info) const
{
    // Helper lambda to find inner VALU form
    auto findInnerValu = [] (const LWO3Form* valuForm) -> const LWO3Form*
    {
        for (const auto& child : valuForm->getChildren())
        {
            if (child->isForm() && child->getId() == LWO::VALU)
            {
                return static_cast<const LWO3Form*> (child.get());
            }
        }
        return nullptr;
    };

    // Helper lambda to extract float value with proper nesting
    auto extractFloat = [&findInnerValu] (const LWO3Form* valuForm) -> float
    {
        const LWO3Form* innerValuForm = findInnerValu (valuForm);
        if (!innerValuForm) return 0.0f;

        for (const auto& child : innerValuForm->getChildren())
        {
            if (!child->isForm() &&
                static_cast<const LWO3Chunk*> (child.get())->getId() == LWO::ANON)
            {
                const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                if (chunk->getData().size() >= 12)
                { // Count (4) + double value (8)
                    BinaryReader reader (
                        const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
                        static_cast<uint32_t> (chunk->getData().size()));

                    uint32_t count = mace::swap32 (reader.ReadUint32());
                    if (count == 1)
                    {
                        return static_cast<float> (mace::swapDouble (reader.ReadDouble()));
                    }
                }
            }
        }
        return 0.0f;
    };

    // Helper lambda to extract vector value with proper nesting
    auto extractVector3f = [&findInnerValu] (const LWO3Form* valuForm) -> Vector3f
    {
        const LWO3Form* innerValuForm = findInnerValu (valuForm);
        if (!innerValuForm) return Vector3f::Zero();

        for (const auto& child : innerValuForm->getChildren())
        {
            if (!child->isForm() &&
                static_cast<const LWO3Chunk*> (child.get())->getId() == LWO::ANON)
            {
                const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                if (chunk->getData().size() >= 28)
                { // Count (4) + 3 doubles (24)
                    BinaryReader reader (
                        const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
                        static_cast<uint32_t> (chunk->getData().size()));

                    uint32_t count = mace::swap32 (reader.ReadUint32());
                    if (count == 3)
                    {
                        return Vector3f (
                            static_cast<float> (mace::swapDouble (reader.ReadDouble())),
                            static_cast<float> (mace::swapDouble (reader.ReadDouble())),
                            static_cast<float> (mace::swapDouble (reader.ReadDouble())));
                    }
                }
            }
        }
        return Vector3f::Zero();
    };

    // Find ATTR -> META -> ADAT path
    for (const auto& child : ndtaForm->getChildren())
    {
        if (child->isForm() && child->getId() == LWO::ATTR)
        {
            const auto* attrForm = static_cast<const LWO3Form*> (child.get());

            for (const auto& attrChild : attrForm->getChildren())
            {
                if (attrChild->isForm() && attrChild->getId() == LWO::META)
                {
                    const auto* metaForm = static_cast<const LWO3Form*> (attrChild.get());

                    for (const auto& metaChild : metaForm->getChildren())
                    {
                        if (metaChild->isForm() && metaChild->getId() == LWO::ADAT)
                        {
                            const auto* adatForm = static_cast<const LWO3Form*> (metaChild.get());

                            // Process each ENTR form for material properties
                            for (const auto& entrChild : adatForm->getChildren())
                            {
                                if (!entrChild->isForm() || entrChild->getId() != LWO::ENTR) continue;

                                const auto* entrForm = static_cast<const LWO3Form*> (entrChild.get());
                                std::string propName;
                                const LWO3Form* valuForm = nullptr;

                                // Get property name and VALU form
                                for (const auto& entry : entrForm->getChildren())
                                {
                                    if (!entry->isForm())
                                    {
                                        if (entry->getId() == LWO::NAME)
                                        {
                                            const auto* chunk = static_cast<const LWO3Chunk*> (entry.get());
                                            propName = std::string (reinterpret_cast<const char*> (chunk->getData().data()));
                                        }
                                    }
                                    else if (entry->getId() == LWO::VALU)
                                    {
                                        valuForm = static_cast<const LWO3Form*> (entry.get());
                                    }
                                }

                                if (!valuForm) continue;

                                // Map property names to PrincipledBSDFInfo fields
                                if (propName == "Color")
                                {
                                    info.baseColor = extractVector3f (valuForm);

                                    // for some reason R and B components are flipped so we have to swap
                                    std::swap (info.baseColor[0], info.baseColor[2]);

                                  //  mace::vecStr3f (info.baseColor, DBUG, "Base color");
                                }
                                else if (propName == "Luminous Color")
                                {
                                    info.luminousColor = extractVector3f (valuForm);
                                   // mace::vecStr3f (info.luminousColor, DBUG, "Luminous Color");
                                }
                                else if (propName == "Subsurface Color")
                                {
                                    info.subsurfaceColor = extractVector3f (valuForm);
                                   // mace::vecStr3f (info.subsurfaceColor, DBUG, "Subsurface Color");
                                }
                                else if (propName == "Transmittance")
                                {
                                    info.transmittance = extractVector3f (valuForm);
                                   // mace::vecStr3f (info.subsurfaceColor, DBUG, "Subsurface Color");
                                }
                                else
                                {
                                    float value = extractFloat (valuForm);
                                    if (propName == "Roughness")
                                        info.roughness = value;
                                    else if (propName == "Metallic")
                                        info.metallic = value;
                                    else if (propName == "Specular")
                                        info.specular = value;
                                    else if (propName == "Specular Tint")
                                        info.specularTint = value;
                                    else if (propName == "Sheen")
                                        info.sheen = value;
                                    else if (propName == "Sheen Tint")
                                        info.sheenTint = value;
                                    else if (propName == "Clearcoat")
                                        info.clearcoat = value;
                                    else if (propName == "Clearcoat Gloss")
                                        info.clearcoatGloss = value;
                                   // else if (propName == "Transmission")
                                    //    info.transmission = value;
                                    else if (propName == "Transparency")
                                        info.transparency = value;
                                    else if (propName == "Translucency")
                                        info.subsurface = value; // Maps to subsurface in the PBR model
                                    else if (propName == "Flatness")
                                        info.flatness = value;
                                    else if (propName == "Distance")
                                        info.subsurfaceDistance = value;
                                  /*  else if (propName == "Transmittance")
                                        info.transmittance = value;*/
                                    else if (propName == "Transmittance Distance")
                                        info.transmittanceDistance = value;
                                    else if (propName == "Anisotropic")
                                        info.anisotropic = value;
                                    else if (propName == "Rotation")
                                        info.anisotropicRotation = value;
                                    else if (propName == "Asymmetry")
                                        info.asymmetry = value;
                                    else if (propName == "Luminous")
                                        info.luminous = value;
                                    else if (propName == "Thin")
                                        info.thinWalled = value > 0.0f;
                                    else if (propName == "Refraction Index")
                                        info.ior = value;

                                    // LOG (DBUG) << "BSDF property " << propName << ": " << value;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

std::vector<NodeConnection> LWO3NodeGraph::getNodeConnections (const std::string& nodeName) const
{
    std::vector<NodeConnection> connections;

    // First find the NODS form
    const LWO3Form* nodsForm = nullptr;
    for (const auto& child : surfForm_->getChildren())
    {
        if (child->isForm() && child->getId() == LWO::NODS)
        {
            nodsForm = static_cast<const LWO3Form*> (child.get());
            break;
        }
    }

    if (!nodsForm)
    {
        return connections;
    }

    // Find NCON form in NODS
    LWO3Navigator nav;
    auto nconResults = nav.findElementsById (nodsForm, LWO::NCON);
    if (nconResults.empty())
    {
        return connections;
    }

    const auto* nconForm = static_cast<const LWO3Form*> (nconResults[0].element);

    // Process each connection in sequence
    NodeConnection currentConnection;
    bool processingConnection = false;

    for (const auto& child : nconForm->getChildren())
    {
        if (child->isForm()) continue;

        const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
        std::string_view data (reinterpret_cast<const char*> (chunk->getData().data()));

        switch (chunk->getId())
        {
            case LWO::INME: // Target node name
                currentConnection = NodeConnection();
                processingConnection = true;
                currentConnection.targetNode = std::string (data);
                break;

            case LWO::IINM: // Input name
                if (processingConnection)
                {
                    currentConnection.inputName = std::string (data);
                }
                break;

            case LWO::IINN: // Source node name
                if (processingConnection)
                {
                    currentConnection.sourceNode = std::string (data);
                }
                break;

            case LWO::IONM: // Output name
                if (processingConnection)
                {
                    currentConnection.outputName = std::string (data);

                    // Only add the connection if it involves our target node
                    if (!currentConnection.sourceNode.empty() &&
                        !currentConnection.targetNode.empty() &&
                        !currentConnection.inputName.empty() &&
                        !currentConnection.outputName.empty() &&
                        (currentConnection.sourceNode == nodeName ||
                         currentConnection.targetNode == nodeName))
                    {
                        // Check for duplicates
                        bool isDuplicate = false;
                        for (const auto& existing : connections)
                        {
                            if (existing.sourceNode == currentConnection.sourceNode &&
                                existing.targetNode == currentConnection.targetNode &&
                                existing.inputName == currentConnection.inputName &&
                                existing.outputName == currentConnection.outputName)
                            {
                                isDuplicate = true;
                                break;
                            }
                        }

                        if (!isDuplicate)
                        {
                            // LOG (DBUG) << "Found connection: " << currentConnection.sourceNode
                                     //   << "." << currentConnection.outputName << " -> "
                                    //    << currentConnection.targetNode << "."
                                     //   << currentConnection.inputName;
                            connections.push_back (currentConnection);
                        }
                    }

                    processingConnection = false;
                }
                break;
        }
    }

    return connections;
}

std::vector<ImageConnection> LWO3NodeGraph::getConnectedImageNodes() const
{
    std::vector<ImageConnection> connections;
    auto images = getImageNodes();

    // For each image node
    for (const auto& img : images)
    {
        // Look at each connection from this image
        for (const auto& conn : img.connections)
        {
            // Check if this connects to a Principled BSDF node
            if (conn.targetNode.find ("Principled BSDF") != std::string::npos)
            {
                ImageConnection imgConn;
                imgConn.imageNode = img;
                imgConn.bsdfInputSocket = conn.inputName;
                connections.push_back (imgConn);

                // LOG (DBUG) << "Found image connection: " << img.nodeName
                          //  << " -> " << conn.targetNode
                          //  << " (" << conn.inputName << ")";
            }
        }
    }

    return connections;
}

bool LWO3NodeGraph::hasNode (const std::string& nodeName) const
{
    // Search nodeNames_ vector for a pair with matching node name
    return std::any_of (nodeNames_.begin(), nodeNames_.end(),
                        [&nodeName] (const auto& pair)
                        { return pair.first == nodeName; });
}

std::vector<NodeConnection> LWO3NodeGraph::processNodeConnections (const LWO3Form* nconForm,
                                                                   const std::string& nodeName) const
{
    std::vector<NodeConnection> connections;
    NodeConnection currentConnection;
    bool processingConnection = false;

    for (const auto& child : nconForm->getChildren())
    {
        if (child->isForm()) continue;

        const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
        const auto& data = chunk->getData();

        switch (chunk->getId())
        {
            case LWO::INME: // Target node
                currentConnection = NodeConnection();
                processingConnection = true;
                currentConnection.targetNode = std::string (reinterpret_cast<const char*> (data.data()));
                break;

            case LWO::IINM: // Input name
                if (processingConnection)
                {
                    currentConnection.inputName = std::string (reinterpret_cast<const char*> (data.data()));
                }
                break;

            case LWO::IINN: // Source node name
                if (processingConnection)
                {
                    currentConnection.sourceNode = std::string (reinterpret_cast<const char*> (data.data()));
                }
                break;

            case LWO::IONM: // Output name
                if (processingConnection)
                {
                    currentConnection.outputName = std::string (reinterpret_cast<const char*> (data.data()));

                    // Add connection if:
                    // 1. All fields are populated
                    // 2. The connection involves our target node
                    // 3. Source and target are different nodes
                    if (!currentConnection.sourceNode.empty() &&
                        !currentConnection.targetNode.empty() &&
                        !currentConnection.inputName.empty() &&
                        !currentConnection.outputName.empty() &&
                        currentConnection.sourceNode != currentConnection.targetNode &&
                        (currentConnection.sourceNode == nodeName ||
                         currentConnection.targetNode == nodeName))
                    {
                        // Check for duplicates
                        bool isDuplicate = false;
                        for (const auto& existing : connections)
                        {
                            if (existing.sourceNode == currentConnection.sourceNode &&
                                existing.targetNode == currentConnection.targetNode &&
                                existing.inputName == currentConnection.inputName &&
                                existing.outputName == currentConnection.outputName)
                            {
                                isDuplicate = true;
                                break;
                            }
                        }

                        if (!isDuplicate)
                        {
                            // LOG (DBUG) << "Adding connection: " << currentConnection.sourceNode
                                //       << "." << currentConnection.outputName << " -> "
                                //       << currentConnection.targetNode << "."
                                 //      << currentConnection.inputName;
                            connections.push_back (currentConnection);
                        }
                    }

                    processingConnection = false;
                }
                break;
        }
    }

    return connections;
}

void LWO3NodeGraph::extractStandardValues (const LWO3Form* ndtaForm, StandardNodeInfo& info) const
{
    // Find SATR -> META -> ADAT path
    for (const auto& child : ndtaForm->getChildren())
    {
        if (child->isForm() && child->getId() == LWO::SATR)
        {
            const auto* satrForm = static_cast<const LWO3Form*> (child.get());

            for (const auto& satrChild : satrForm->getChildren())
            {
                if (satrChild->isForm() && satrChild->getId() == LWO::META)
                {
                    const auto* metaForm = static_cast<const LWO3Form*> (satrChild.get());

                    for (const auto& metaChild : metaForm->getChildren())
                    {
                        if (metaChild->isForm() && metaChild->getId() == LWO::ADAT)
                        {
                            const auto* adatForm = static_cast<const LWO3Form*> (metaChild.get());

                            // Helper lambda to find inner VALU form
                            auto findInnerValu = [] (const LWO3Form* valuForm) -> const LWO3Form*
                            {
                                for (const auto& child : valuForm->getChildren())
                                {
                                    if (child->isForm() && child->getId() == LWO::VALU)
                                    {
                                        return static_cast<const LWO3Form*> (child.get());
                                    }
                                }
                                return nullptr;
                            };

                            // Helper lambda to extract float value from inner VALU form
                            auto extractFloat = [&findInnerValu] (const LWO3Form* valuForm) -> float
                            {
                                const LWO3Form* innerValuForm = findInnerValu (valuForm);
                                if (!innerValuForm) return 0.0f;

                                for (const auto& child : innerValuForm->getChildren())
                                {
                                    if (!child->isForm() &&
                                        static_cast<const LWO3Chunk*> (child.get())->getId() == LWO::ANON)
                                    {
                                        const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                                        if (chunk->getData().size() >= 12)
                                        { // Count(4) + double(8)
                                            BinaryReader reader (
                                                const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
                                                static_cast<uint32_t> (chunk->getData().size()));

                                            uint32_t count = mace::swap32 (reader.ReadUint32());
                                            if (count == 1)
                                            {
                                                return static_cast<float> (mace::swapDouble (reader.ReadDouble()));
                                            }
                                        }
                                    }
                                }
                                return 0.0f;
                            };

                            // Helper lambda to extract Vector3f value from inner VALU form
                            auto extractVector3f = [&findInnerValu] (const LWO3Form* valuForm) -> Vector3f
                            {
                                const LWO3Form* innerValuForm = findInnerValu (valuForm);
                                if (!innerValuForm) return Vector3f::Zero();

                                for (const auto& child : innerValuForm->getChildren())
                                {
                                    if (!child->isForm() &&
                                        static_cast<const LWO3Chunk*> (child.get())->getId() == LWO::ANON)
                                    {
                                        const auto* chunk = static_cast<const LWO3Chunk*> (child.get());
                                        if (chunk->getData().size() >= 28)
                                        { // Count(4) + 3*double(24)
                                            BinaryReader reader (
                                                const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
                                                static_cast<uint32_t> (chunk->getData().size()));

                                            uint32_t count = mace::swap32 (reader.ReadUint32());
                                            if (count == 3)
                                            {
                                               return Vector3f (
                                                    static_cast<float> (mace::swapDouble (reader.ReadDouble())),
                                                    static_cast<float> (mace::swapDouble (reader.ReadDouble())),
                                                    static_cast<float> (mace::swapDouble (reader.ReadDouble())));
                                              
                                            }
                                        }
                                    }
                                }
                                return Vector3f::Zero();
                            };

                            // Process each ENTR form for material properties
                            for (const auto& entrChild : adatForm->getChildren())
                            {
                                if (!entrChild->isForm() || entrChild->getId() != LWO::ENTR) continue;

                                const auto* entrForm = static_cast<const LWO3Form*> (entrChild.get());
                                std::string propName;
                                const LWO3Form* valuForm = nullptr;

                                // Get property name and VALU form
                                for (const auto& entry : entrForm->getChildren())
                                {
                                    if (!entry->isForm())
                                    {
                                        if (entry->getId() == LWO::NAME)
                                        {
                                            const auto* chunk = static_cast<const LWO3Chunk*> (entry.get());
                                            propName = std::string (reinterpret_cast<const char*> (chunk->getData().data()));
                                        }
                                    }
                                    else if (entry->getId() == LWO::VALU)
                                    {
                                        valuForm = static_cast<const LWO3Form*> (entry.get());
                                    }
                                }

                                if (!valuForm) continue;

                                // Map property names to StandardNodeInfo fields
                                if (propName == "Color")
                                {
                                    Vector3f c = extractVector3f (valuForm);

                                    // NB.  for some unknown to me reason, it appears that
                                    // LW is saving color in BGR instead of RGB
                                    // Swap x and z components
                                    std::swap (c.x(),c.z());
                                    
                                    info.color = c;
                                    // LOG (DBUG) << info.color.x() << ", " << info.color.y() << ", " << info.color.z();
                                    // LOG (DBUG) << "Standard Color: " << info.color.transpose();

                                    
                                }
                                else
                                {
                                    float value = extractFloat (valuForm);
                                    if (propName == "Luminosity")
                                        info.luminosity = value;
                                    else if (propName == "Diffuse")
                                        info.diffuse = value;
                                    else if (propName == "Specular")
                                        info.specular = value;
                                    else if (propName == "Glossiness")
                                        info.glossiness = value;
                                    else if (propName == "Reflection")
                                        info.reflection = value;
                                    else if (propName == "Transparency")
                                        info.transparency = value;
                                    else if (propName == "Refraction Index")
                                        info.refractionIndex = value;
                                    else if (propName == "Translucency")
                                        info.translucency = value;
                                    else if (propName == "Color Highlight")
                                        info.colorHighlight = value;
                                    else if (propName == "Color Filter")
                                        info.colorFilter = value;
                                    else if (propName == "Diffuse Sharpness")
                                        info.diffuseSharpness = value;
                                    else if (propName == "Bump Height")
                                        info.bumpHeight = value;

                                    // LOG (DBUG) << "Standard property " << propName << ": " << value;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
</file>

<file path="io/LWO3NodeGraph.h">
#pragma once

class LWO3NodeGraph
{
 public:
    // Initialize with root form and specific surface form
    LWO3NodeGraph (std::shared_ptr<LWO3Form> root, const LWO3Form* surfForm = nullptr);

   
    // Get all nodes grouped by type
    std::map<std::string, std::vector<std::string>> getNodesByType() const { return nodesByType_; }

    // Get info about all nodes including their connections
    std::vector<ImageNodeInfo> getImageNodes() const;
    std::vector<StandardNodeInfo> getStandardNodes() const;
    std::vector<PrincipledBSDFInfo> getPrincipledBSDFNodes() const;

    // Get connections for a specific node
    std::vector<NodeConnection> getNodeConnections (const std::string& nodeName) const;

    // Get all connected image nodes with their BSDF inputs
    std::vector<ImageConnection> getConnectedImageNodes() const;

    // Utility functions
    size_t getNodeCount() const { return nodeNames_.size(); }
    bool hasNode (const std::string& nodeName) const;
    const std::string& getSurfaceName() const { return surfaceName_; }
    const LWO3Form* getRootForm() const { return root_.get(); }

 private:
    std::shared_ptr<LWO3Form> root_;
    const LWO3Form* surfForm_; // The specific surface form we're working with
    std::string surfaceName_;
    std::vector<std::pair<std::string, size_t>> nodeNames_;
    std::map<std::string, std::vector<std::string>> nodesByType_;

    void extractSurfaceName();
    void extractNodeNames();

    // Helper functions for node data extraction
    std::string extractImagePathFromNDTA (const LWO3Form* ndtaForm) const;
    std::vector<NodeConnection> processNodeConnections (const LWO3Form* nconForm,
                                                        const std::string& nodeName) const;
    
    void extractStandardValues (const LWO3Form* ndtaForm,
                                StandardNodeInfo& info) const;

    void extractPrincipledBSDFValues (const LWO3Form* ndtaForm,
                                      PrincipledBSDFInfo& info) const;
};
</file>

<file path="io/LWO3Reader.cpp">
// Attempts to read and parse the LWO3 file at the given path
bool LWO3Reader::read (const fs::path& filepath)
{
    // Clear any existing data
    root_.reset();
    layers_.clear();
    errorMessage_.clear();

    try
    {
        // Parse file into form structure
        LWO3Tree parser;
        root_ = parser.read (filepath);

        if (!root_)
        {
            errorMessage_ = "Failed to parse LWO3 file";
            return false;
        }

        // Parse layers from form structure
        if (!parseLayers())
        {
            return false;
        }

        return true;
    }
    catch (const std::exception& e)
    {
        errorMessage_ = "Exception while reading LWO3 file: " + std::string (e.what());
        return false;
    }
}

// Returns layer at specified index or nullptr if invalid
std::shared_ptr<LWO3Layer> LWO3Reader::getLayerByIndex (size_t index) const
{
    if (index < layers_.size())
    {
        return layers_[index];
    }
    return nullptr;
}

// Returns first layer matching name or nullptr if not found
std::shared_ptr<LWO3Layer> LWO3Reader::getLayerByName (const std::string& name) const
{
    for (const auto& layer : layers_)
    {
        if (layer->getName() == name)
        {
            return layer;
        }
    }
    return nullptr;
}

// Creates layer objects from the parsed form structure
bool LWO3Reader::parseLayers()
{
    if (!root_)
    {
        errorMessage_ = "No root form available";
        return false;
    }

    LWO3Navigator navigator;
    auto results = navigator.findElementsById (root_.get(), sabi::LWO::LAYR);

    if (results.empty())
    {
        errorMessage_ = "No layers found in LWO3 file";
        return false;
    }

    // Create layers in order of their indices
    size_t maxLayerIndex = 0;

    // First pass to find highest layer index
    for (const auto& result : results)
    {
        if (!result.element->isForm())
        {
            const auto* chunk = static_cast<const LWO3Chunk*> (result.element);
            BinaryReader reader (
                const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
                static_cast<uint32_t> (chunk->getData().size()));

            uint16_t layerIndex = mace::swap16 (reader.ReadUint16());
            maxLayerIndex = std::max (maxLayerIndex, static_cast<size_t> (layerIndex));
        }
    }

    // Resize layers vector to accommodate all indices
    layers_.resize (maxLayerIndex + 1);

    // Create layers
    for (const auto& result : results)
    {
        if (!result.element->isForm())
        {
            const auto* chunk = static_cast<const LWO3Chunk*> (result.element);
            BinaryReader reader (
                const_cast<char*> (reinterpret_cast<const char*> (chunk->getData().data())),
                static_cast<uint32_t> (chunk->getData().size()));

            uint16_t layerIndex = mace::swap16 (reader.ReadUint16());

            try
            {
                auto layer = std::make_shared<LWO3Layer> (root_, layerIndex);
                layers_[layerIndex] = layer;
            }
            catch (const std::exception& e)
            {
                LOG (WARNING) << "Failed to create layer " << layerIndex << ": " << e.what();
                return false;
            }
        }
    }

    // Remove any null layers from gaps in indices
    layers_.erase (
        std::remove_if (layers_.begin(), layers_.end(),
                        [] (const auto& layer)
                        { return layer == nullptr; }),
        layers_.end());

    return !layers_.empty();
}
</file>

<file path="io/LWO3Reader.h">
#pragma once

// LWO3Reader: Primary class for reading LightWave Object 3 (LWO3) files
// Handles file parsing and layer management while individual LWO3Layer instances
// manage their own geometry and surface data. Provides access to the loaded
// layers and maintains the root form structure.

class LWO3Reader
{
 public:
    // Reads and parses an LWO3 file at the given path
    bool read (const fs::path& filepath);

    // Returns all layers in the LWO3 file
    const std::vector<std::shared_ptr<LWO3Layer>>& getLayers() const { return layers_; }

    // Returns layer at specified index or nullptr if index is invalid
    std::shared_ptr<LWO3Layer> getLayerByIndex (size_t index) const;

    // Returns first layer matching the given name or nullptr if not found
    std::shared_ptr<LWO3Layer> getLayerByName (const std::string& name) const;

    // Returns true if file was successfully loaded and parsed
    bool isValid() const { return !layers_.empty() && root_ != nullptr; }

    // Returns last error message if any operation failed
    const std::string& getError() const { return errorMessage_; }

 private:
    // Creates layer objects from the parsed form structure
    bool parseLayers();

    std::shared_ptr<LWO3Form> root_;
    std::vector<std::shared_ptr<LWO3Layer>> layers_;
    std::string errorMessage_;
};
</file>

<file path="io/LWO3Surface.cpp">
// Retrieves image node connected to specified BSDF input socket
// Returns nullopt if no connection found
std::optional<ImageNodeInfo> LWO3Surface::getBSDFImageNode (BSDFInput input) const
{
    if (!nodeGraph) return std::nullopt;

    std::string inputName = getBSDFInputName (input);
    for (const auto& img : nodeGraph->getImageNodes())
    {
        for (const auto& conn : img.connections)
        {
            if (conn.targetNode.find ("Principled BSDF") != std::string::npos &&
                conn.inputName == inputName)
            {
                return img;
            }
        }
    }
    return std::nullopt;
}
</file>

<file path="io/LWO3Surface.h">
#pragma once

// LWO3Surface: Encapsulates a LightWave Object surface, including geometry and material properties.
// - Maps surface data between LWO3 and CgModel formats
// - Manages material properties via an internal node graph
// - Provides access to texture maps through the material node connections
// - Handles both geometry (indices) and material properties in a unified way


using sabi::BSDFInput;
using sabi::ImageNodeInfo;
using sabi::LWO3NodeGraph;

class LWO3Surface
{
 public:
    // Constructs a surface with the given name
    LWO3Surface (const std::string& surfaceName) :
        name (surfaceName) {}
    ~LWO3Surface() = default;

    // Returns the surface name
    [[nodiscard]] const std::string& getName() const { return name; }

    // Access to triangle indices matrix
    [[nodiscard]] MatrixXu& indices() { return F; }
    [[nodiscard]] const MatrixXu& indices() const { return F; }

    // Returns the material node graph
    [[nodiscard]] const LWO3NodeGraph* getNodeGraph() const { return nodeGraph.get(); }

    // Returns total number of triangles
    [[nodiscard]] size_t triangleCount() const { return F.cols(); }

    // Updates the surface name
    void setName (const std::string& surfaceName) { name = surfaceName; }

    // Takes ownership of a new node graph
    void setNodeGraph (std::unique_ptr<LWO3NodeGraph> graph) { nodeGraph = std::move (graph); }

    // Finds the image node connected to a specific BSDF input socket
    std::optional<ImageNodeInfo> getBSDFImageNode (BSDFInput input) const;

 private:
    std::string name;
    MatrixXu F; // Triangle indices
    std::unique_ptr<LWO3NodeGraph> nodeGraph;
};
</file>

<file path="io/LWO3ToCgModelConverter.cpp">
LWO3ToCgModelConverter::LWO3ToCgModelConverter (ConversionFlags flags) :
    flags_ (flags)
{
}

CgModelPtr LWO3ToCgModelConverter::convert (const LWO3Layer* layer)
{
    if (!validateLayer (layer))
    {
        return nullptr;
    }

    auto model = CgModel::create();
    model->contentDirectory = contentDir_;

    // Clear tracking state at start of conversion
    processedImages_.clear();
    processedSurfaces_.clear();
    imageTextureMap_.clear();

    // Convert geometry
    if ((flags_ & ConversionFlags::StandardGeometry) != ConversionFlags::None)
    {
        if (!convertVertices (layer, model))
        {
            LOG (WARNING) << "Failed to convert vertices: " << errorMsg_;
            return nullptr;
        }

        if (!convertTriangles (layer, model))
        {
            LOG (WARNING) << "Failed to convert triangles: " << errorMsg_;
            return nullptr;
        }

        if (!convertUVs (layer, model))
        {
            LOG (WARNING) << "Failed to convert UVs: " << errorMsg_;
            return nullptr;
        }
    }

    // Convert materials (which includes images and textures)
    if ((flags_ & ConversionFlags::Materials) == ConversionFlags::Materials)
    {
        // Get initial image count for allocation
        auto imageNodes = layer->getSurfaces()[0]->getNodeGraph()->getImageNodes();
        model->images.reserve (imageNodes.size());
        model->textures.reserve (imageNodes.size());

        if (!convertImages (layer, model))
        {
            LOG (WARNING) << "Failed to convert images: " << errorMsg_;
            return nullptr;
        }

        if (!convertMaterials (layer, model))
        {
            LOG (WARNING) << "Failed to convert materials: " << errorMsg_;
            return nullptr;
        }
    }

    return model;
}

bool LWO3ToCgModelConverter::validateLayer (const LWO3Layer* layer)
{
    if (!layer)
    {
        errorMsg_ = "Null layer provided";
        return false;
    }

    // Check polygon type is FACE
    if (layer->getPolygonType() != sabi::LWO::FACE)
    {
        errorMsg_ = "Only FACE polygon type is supported";
        return false;
    }

    // Basic geometry checks
    if (layer->getPoints().empty())
    {
        errorMsg_ = "Layer contains no vertices";
        return false;
    }

    if (layer->getPolygons().empty())
    {
        errorMsg_ = "Layer contains no polygons";
        return false;
    }

    // Verify all polygons are triangles
    for (const auto& poly : layer->getPolygons())
    {
        if (poly.indices.size() != 3)
        {
            errorMsg_ = "Non-triangle polygon found";
            return false;
        }
    }

    return true;
}

bool LWO3ToCgModelConverter::convertVertices (const LWO3Layer* layer, CgModelPtr model)
{
    const auto& points = layer->getPoints();

    // Resize vertex matrix
    model->V.resize (3, points.size());

    // Copy vertices to matrix
    for (size_t i = 0; i < points.size(); ++i)
    {
        model->V.col (i) = points[i];
    }

    return true;
}

bool LWO3ToCgModelConverter::convertTriangles (const LWO3Layer* layer, CgModelPtr model)
{
    const auto& polygons = layer->getPolygons();

    // Create a single surface for all triangles initially
    CgModelSurface surface;
    surface.F.resize (3, polygons.size());

    // Copy triangle indices
    for (size_t i = 0; i < polygons.size(); ++i)
    {
        const auto& poly = polygons[i];
        surface.F.col (i) = Vector3u (
            poly.indices[0],
            poly.indices[1],
            poly.indices[2]);
    }

    // Add surface to model
    model->S.push_back (surface);
    model->triCount = polygons.size();

    return true;
}

bool LWO3ToCgModelConverter::convertUVs (const LWO3Layer* layer, CgModelPtr model)
{

    auto uvMaps = layer->getVertexMaps (sabi::LWO::TXUV);
    if (uvMaps.empty())
    {
        errorMsg_ = "No UV maps found";
        return false;
    }

    const VertexMap* primaryUVMap = uvMaps[0];
    if (!primaryUVMap || primaryUVMap->dimension != 2)
    {
        errorMsg_ = "Invalid UV map dimension";
        return false;
    }

    // Initialize UV matrix
    model->UV0.resize (2, model->V.cols());
    model->UV0.setZero();

    // Copy UV data - values are already properly parsed
    for (size_t i = 0; i < primaryUVMap->vertexIndices.size(); ++i)
    {
        uint32_t vertIndex = primaryUVMap->vertexIndices[i];
        if (vertIndex >= static_cast<uint32_t> (model->V.cols()))
        {
            LOG (WARNING) << "UV vertex index out of bounds: " << vertIndex;
            continue;
        }

        model->UV0.col (vertIndex) = Eigen::Vector2f (
            primaryUVMap->values[i * 2],    // U coordinate
            primaryUVMap->values[i * 2 + 1] // V coordinate
        );
    }

    // Handle UV1 similarly if present
    if (uvMaps.size() > 1)
    {
        const VertexMap* secondaryUVMap = uvMaps[1];
        if (secondaryUVMap && secondaryUVMap->dimension == 2)
        {
            model->UV1.resize (2, model->V.cols());
            model->UV1.setZero();

            for (size_t i = 0; i < secondaryUVMap->vertexIndices.size(); ++i)
            {
                uint32_t vertIndex = secondaryUVMap->vertexIndices[i];
                if (vertIndex >= static_cast<uint32_t> (model->V.cols()))
                {
                    continue;
                }

                model->UV1.col (vertIndex) = Eigen::Vector2f (
                    secondaryUVMap->values[i * 2],
                    secondaryUVMap->values[i * 2 + 1]);
            }
        }
    }

    return true;
}

// Pre-allocate vectors to avoid reallocation:
bool LWO3ToCgModelConverter::convertImages (const LWO3Layer* layer, CgModelPtr model)
{
    auto imageNodes = layer->getSurfaces()[0]->getNodeGraph()->getImageNodes();
    model->images.reserve (imageNodes.size());
    model->textures.reserve (imageNodes.size());
    processedImages_.reserve (imageNodes.size());

    // Process each surface's node graph
    for (const auto& surface : layer->getSurfaces())
    {
        if (!surface || !surface->getNodeGraph())
        {
            continue;
        }

        const auto* nodeGraph = surface->getNodeGraph();
        auto connectedImages = nodeGraph->getConnectedImageNodes();

        for (const auto& conn : connectedImages)
        {
            const auto& imageNode = conn.imageNode;
            if (imageNode.imagePath.empty() || !imageNode.enabled)
            {
                continue;
            }

            // Add image if not already processed
            if (processedImages_.find (imageNode.imagePath) == processedImages_.end())
            {
                Image image;
                image.uri = imageNode.imagePath;

                if (!contentDir_.empty())
                {
                    fs::path fullPath = contentDir_ / image.uri;
                    if (fs::exists (fullPath))
                    {
                        image.uri = fullPath.string();
                    }
                }

                model->images.push_back (image);
                size_t imageIndex = model->images.size() - 1;
                processedImages_[imageNode.imagePath] = imageIndex;

                // Create corresponding texture
                Texture texture;
                texture.name = imageNode.nodeName;
                texture.source = static_cast<int> (imageIndex);
                model->textures.push_back (texture);

                // Store mapping between image path and texture index
                imageTextureMap_[imageNode.imagePath] = model->textures.size() - 1;
            }
        }
    }

    return true;
}
bool LWO3ToCgModelConverter::convertMaterials (const LWO3Layer* layer, CgModelPtr model)
{
    if (!model->S.empty())
    { // Model must have a surface
        for (const auto& surface : layer->getSurfaces())
        {
            if (!surface || !surface->getNodeGraph())
            {
                continue;
            }

            if (processedSurfaces_.find (surface->getName()) != processedSurfaces_.end())
            {
                continue;
            }
            processedSurfaces_.insert (surface->getName());

            auto bsdfNodes = surface->getNodeGraph()->getPrincipledBSDFNodes();
            if (bsdfNodes.empty())
            {
                LOG (WARNING) << "No BSDF nodes found for surface: " << surface->getName();
                continue; // Skip this surface but continue processing others
            }

            Material material;
            material.name = surface->getName();
            const auto& bsdf = bsdfNodes[0];
            material.pbrMetallicRoughness.baseColorFactor = {
                bsdf.baseColor (0), bsdf.baseColor (1), bsdf.baseColor (2), 1.0f};
            material.pbrMetallicRoughness.metallicFactor = bsdf.metallic;
            material.pbrMetallicRoughness.roughnessFactor = bsdf.roughness;

            auto imageNodes = surface->getNodeGraph()->getConnectedImageNodes();

            for (const auto& conn : imageNodes)
            {
                const auto& imageNode = conn.imageNode;
                if (imageNode.imagePath.empty() || !imageNode.enabled)
                {
                    continue;
                }

                // Use existing texture index from convertImages
                auto it = imageTextureMap_.find (imageNode.imagePath);
                if (it == imageTextureMap_.end())
                {
                    LOG (WARNING) << "Missing texture for image: " << imageNode.imagePath;
                    continue;
                }

                // Create texture info using existing texture index
                TextureInfo texInfo;
                texInfo.textureIndex = static_cast<int> (it->second);
                texInfo.texCoord = 0;

                if (conn.bsdfInputSocket == "Color")
                {
                    material.pbrMetallicRoughness.baseColorTexture = texInfo;
                }
                // Handle other texture types...
            }
            model->S[0].material = material;
        }
        return true;
    }

    errorMsg_ = "No surfaces present in model";
    return false;
}

#if 0
bool LWO3ToCgModelConverter::convertMaterials (const LWO3Layer* layer, CgModelPtr model)
{
    if ((flags_ & ConversionFlags::Materials) != ConversionFlags::Materials)
    {
        return true;
    }

    for (const auto& surface : layer->getSurfaces())
    {
        if (!surface || !surface->getNodeGraph())
        {
            continue;
        }

        if (processedSurfaces_.find (surface->getName()) != processedSurfaces_.end())
        {
            continue;
        }
        processedSurfaces_.insert (surface->getName());

        auto bsdfNodes = surface->getNodeGraph()->getPrincipledBSDFNodes();
        if (bsdfNodes.empty())
        {
            continue;
        }

        Material material;
        material.name = surface->getName();

        const auto& bsdf = bsdfNodes[0];
        material.pbrMetallicRoughness.baseColorFactor = {
            bsdf.baseColor (0), bsdf.baseColor (1), bsdf.baseColor (2), 1.0f};
        material.pbrMetallicRoughness.metallicFactor = bsdf.metallic;
        material.pbrMetallicRoughness.roughnessFactor = bsdf.roughness;

        auto imageNodes = surface->getNodeGraph()->getConnectedImageNodes();

        for (const auto& conn : imageNodes)
        {
            const auto& imageNode = conn.imageNode;
            if (imageNode.imagePath.empty() || !imageNode.enabled)
            {
                continue;
            }

            // Use existing texture index from convertImages
            auto it = imageTextureMap_.find (imageNode.imagePath);
            if (it == imageTextureMap_.end())
            {
                LOG (WARNING) << "Missing texture for image: " << imageNode.imagePath;
                continue;
            }

            // Create texture info using existing texture index
            TextureInfo texInfo;
            texInfo.textureIndex = static_cast<int> (it->second);
            texInfo.texCoord = 0;

            if (conn.bsdfInputSocket == "Color")
            {
                material.pbrMetallicRoughness.baseColorTexture = texInfo;
            }
            // Handle other texture types...
        }
        if (!model->S.empty() && !bsdfNodes.empty())
        {
            model->S[0].material = material;
        }
       
    }

    return true;
}
#endif
</file>

<file path="io/LWO3ToCgModelConverter.h">
#pragma once

// Converts LightWave Object (LWO3) layers to CgModel format with support for
// geometry, materials, textures and other attributes. Implements a flexible
// flag-based system for controlling which features are converted.

class LWO3ToCgModelConverter
{
 public:
    // Controls which features are included in the conversion
    enum class ConversionFlags
    {
        None = 0,
        Vertices = 1 << 0,  // Convert vertex positions
        Triangles = 1 << 1, // Convert triangle indices
        UVs = 1 << 2,       // Convert UV coordinates
        Materials = 1 << 3, // Convert materials including images/textures

        BasicGeometry = Vertices | Triangles,
        StandardGeometry = BasicGeometry | UVs,
        Complete = StandardGeometry | Materials
    };

    // Creates converter with specified feature flags
    explicit LWO3ToCgModelConverter (ConversionFlags flags = ConversionFlags::BasicGeometry);

    // Converts a single LWO3 layer to CgModel format
    CgModelPtr convert (const LWO3Layer* layer);

    // Gets the currently enabled conversion flags
    ConversionFlags getFlags() const { return flags_; }

    // Gets the last error message if conversion failed
    const std::string& getError() const { return errorMsg_; }

    // Sets the content directory for resolving relative paths
    void setContentDirectory (const fs::path& dir) { contentDir_ = dir; }
    const fs::path getContentDirectory() const { return contentDir_; }

    // Updates enabled conversion flags
    void setFlags (ConversionFlags flags) { flags_ = flags; }

    // Adds additional conversion flags while preserving existing ones
    void addFlags (ConversionFlags flags)
    {
        flags_ = static_cast<ConversionFlags> (
            static_cast<uint32_t> (flags_) | static_cast<uint32_t> (flags));
    }

 private:
    fs::path contentDir_;
    ConversionFlags flags_;
    std::string errorMsg_;

    std::unordered_map<std::string, size_t> imageTextureMap_;
    std::unordered_map<std::string, size_t> processedImages_;
    std::set<std::string> processedSurfaces_;

    // Validates layer data before conversion
    bool validateLayer (const LWO3Layer* layer);

    // Converts vertex positions to CgModel format
    bool convertVertices (const LWO3Layer* layer, CgModelPtr model);

    // Converts triangle indices to CgModel format
    bool convertTriangles (const LWO3Layer* layer, CgModelPtr model);

    // Converts UV coordinates to CgModel format
    bool convertUVs (const LWO3Layer* layer, CgModelPtr model);

    // Converts images and textures to CgModel format
    bool convertImages (const LWO3Layer* layer, CgModelPtr model);

    // Converts material properties and node graphs to CgModel format
    bool convertMaterials (const LWO3Layer* layer, CgModelPtr model);
};

// Enable bitwise operations on ConversionFlags
inline LWO3ToCgModelConverter::ConversionFlags operator| (
    LWO3ToCgModelConverter::ConversionFlags a,
    LWO3ToCgModelConverter::ConversionFlags b)
{
    return static_cast<LWO3ToCgModelConverter::ConversionFlags> (
        static_cast<uint32_t> (a) | static_cast<uint32_t> (b));
}

inline LWO3ToCgModelConverter::ConversionFlags operator& (
    LWO3ToCgModelConverter::ConversionFlags a,
    LWO3ToCgModelConverter::ConversionFlags b)
{
    return static_cast<LWO3ToCgModelConverter::ConversionFlags> (
        static_cast<uint32_t> (a) & static_cast<uint32_t> (b));
}
</file>

<file path="io/LWO3Tree.cpp">
//#include "LWO3Tree.h"

std::shared_ptr<LWO3Form> LWO3Tree::read (const fs::path& lwoPath)
{
    BinaryReader reader (lwoPath.string().c_str());

    // Read the FORM identifier
    uint32_t formId = reader.ReadUint32();
    if (formId != mace::swap32 (LWO::FORM))
    {
        LOG (WARNING) << "Invalid LWO3 file: FORM identifier not found";
        return nullptr;
    }

    // Read the file size (we don't need to use this, but we need to skip it)
    reader.Skip (4);

    // Read the LWO3 identifier
    uint32_t lwo3Id = reader.ReadUint32();
    if (lwo3Id != mace::swap32 (LWO::LWO3))
    {
        LOG (WARNING) << "Invalid LWO3 file: LWO3 identifier not found";
        return nullptr;
    }

    auto rootForm = std::make_shared<LWO3Form> (LWO::LWO3);

    while (reader.Position() < reader.Length())
    {
        readElement (reader, rootForm.get());
    }

    return rootForm;
}

// Reads a chunk or form element at the current position and populates the parent
void LWO3Tree::readElement (BinaryReader& reader, LWO3Form* parent)
{
    size_t elementOffset = reader.Position();
    uint32_t id = reader.ReadUint32();
    uint32_t size = mace::swap32 (reader.ReadUint32());

    if (id == mace::swap32 (LWO::FORM))
    {
        uint32_t formType = reader.ReadUint32();
        auto form = std::make_unique<LWO3Form> (mace::swap32 (formType), elementOffset);

        size_t endPosition = reader.Position() + size - 4;
        while (reader.Position() < endPosition)
        {
            readElement (reader, form.get());
        }

        parent->addChild (std::move (form));
    }
    else
    {
        auto chunk = std::make_unique<LWO3Chunk> (mace::swap32 (id), elementOffset);
        std::vector<uint8_t> data (size);
        reader.ReadToMemory (data.data(), size);
        chunk->setData (std::move (data));
        parent->addChild (std::move (chunk));

        if (size % 2 != 0)
        {
            reader.Skip (1);
        }
    }
}
</file>

<file path="io/LWO3Tree.h">
#pragma once

// LWO3Tree: A class for reading LightWave Object (LWO) files in the LWO3 format.
//
// This class provides functionality to parse LWO3 files and construct a hierarchical
// representation of the file's structure using LWO3Form and LWO3Chunk objects.
// It handles the reading of FORM and chunk elements, properly interpreting their
// identifiers and sizes, and organizes them into a tree-like structure.
//
// Key features:
// - Reads and validates LWO3 file headers
// - Parses nested FORM structures and individual chunks
// - Constructs a hierarchical representation of the LWO3 file content
// - Handles byte-swapping for cross-platform compatibility
// - Ensures proper alignment by skipping padding bytes when necessary
//
// Usage:
//   LWO3Tree reader;
//   std::unique_ptr<LWO3Form> rootForm = reader.read("path/to/file.lwo");
//
// Note: This class assumes that the input file is a valid LWO3 file. It performs
// basic validation on the file header but relies on correct internal structure
// for successful parsing.


class LWO3Tree
{
 public:
    // Default constructor
    LWO3Tree() = default;

    // Default destructor
    ~LWO3Tree() = default;

    // Reads an LWO3 file and returns the root LWO3Form
    // Parameters:
    //   lwoPath: The file system path to the LWO3 file
    // Returns:
    //   A shared_ptr to the root LWO3Form containing the entire file structure,
    //   or nullptr if the file is invalid or cannot be read
    std::shared_ptr<LWO3Form> read (const fs::path& lwoPath);

 private:
    // Recursively reads and constructs the hierarchical structure of FORM and chunk elements
    // Parameters:
    //   reader: The BinaryReader object positioned at the start of an element
    //   parent: Pointer to the parent LWO3Form to which the read element will be added
    // This method handles both FORM (which may contain nested elements) and chunk elements
    void readElement (BinaryReader& reader, LWO3Form* parent);
};
</file>

<file path="lwo3/LWO3Chunk.h">
#pragma once

// LWO3Chunk: Represents a chunk in the LWO3 file structure
//
// Chunks are leaf nodes in the LWO3 file structure tree. They contain actual data.
// This class is part of the Composite Pattern, representing the "Leaf" role.

//#include "LWO3Element.h"
//#include "LWO3Visitor.h"

class LWO3Chunk : public LWO3Element
{
 public:
    LWO3Chunk (uint32_t id, size_t offset = 0) :
        LWO3Element (id, offset) {}

    void accept (LWO3Visitor& visitor) const override
    {
        visitor.visitChunk (*this);
    }

    bool isForm() const override { return false; }

    const std::vector<uint8_t>& getData() const { return data_; }
    void setData (const std::vector<uint8_t>& data) { data_ = data; }

 private:
    std::vector<uint8_t> data_;
};
</file>

<file path="lwo3/LWO3Defs.h">
#pragma once

// LWO3Defs: Contains definitions and utility functions for LWO3 file format
//
// This file typically includes:
// - Enum or constexpr definitions for various LWO3 chunk and form IDs
// - Utility functions for working with LWO3 data
// - Any other constants or types specific to the LWO3 format

// #include <mace_core/mace_core.h>

using mace::swap16;
using mace::swap32;
using mace::swap64;
using mace::swapDouble;
using mace::swapFloat;

namespace LWO
{
    // make IDs
    constexpr uint32_t make_id (char a, char b, char c, char d)
    {
        return (static_cast<uint32_t> (a) << 24) |
               (static_cast<uint32_t> (b) << 16) |
               (static_cast<uint32_t> (c) << 8) |
               static_cast<uint32_t> (d);
    }

    // Forms
    constexpr uint32_t FORM = make_id ('F', 'O', 'R', 'M'); // IFF container form
    constexpr uint32_t LWO3 = make_id ('L', 'W', 'O', '3'); // LightWave Object 2018 form
    constexpr uint32_t CLIP = make_id ('C', 'L', 'I', 'P'); // Image/sequence reference
    constexpr uint32_t STIL = make_id ('S', 'T', 'I', 'L'); // Still image
    constexpr uint32_t SURF = make_id ('S', 'U', 'R', 'F'); // Surface definition
    constexpr uint32_t PART = make_id ('P', 'A', 'R', 'T'); // Part definition
    constexpr uint32_t NODS = make_id ('N', 'O', 'D', 'S'); // Node definitions
    constexpr uint32_t NROT = make_id ('N', 'R', 'O', 'T'); // Node root
    constexpr uint32_t NNDS = make_id ('N', 'N', 'D', 'S'); // Node list
    constexpr uint32_t NTAG = make_id ('N', 'T', 'A', 'G'); // Node tag
    constexpr uint32_t NDTA = make_id ('N', 'D', 'T', 'A'); // Node data
    constexpr uint32_t IBGC = make_id ('I', 'B', 'G', 'C'); // Image background color
    constexpr uint32_t IOPC = make_id ('I', 'O', 'P', 'C'); // Image opacity
    constexpr uint32_t IMST = make_id ('I', 'M', 'S', 'T'); // Image state
    constexpr uint32_t IIMG = make_id ('I', 'I', 'M', 'G'); // Image image
    constexpr uint32_t IBMP = make_id ('I', 'B', 'M', 'P'); // Image bitmap
    constexpr uint32_t IUTD = make_id ('I', 'U', 'T', 'D'); // Image U translation
    constexpr uint32_t IVTD = make_id ('I', 'V', 'T', 'D'); // Image V translation
    constexpr uint32_t ISCL = make_id ('I', 'S', 'C', 'L'); // Image scale
    constexpr uint32_t IPOS = make_id ('I', 'P', 'O', 'S'); // Image position
    constexpr uint32_t IROT = make_id ('I', 'R', 'O', 'T'); // Image rotation
    constexpr uint32_t IFAL = make_id ('I', 'F', 'A', 'L'); // Image falloff
    constexpr uint32_t NCON = make_id ('N', 'C', 'O', 'N'); // Node connections
    constexpr uint32_t SSHA = make_id ('S', 'S', 'H', 'A'); // Surface shader
    constexpr uint32_t SSHD = make_id ('S', 'S', 'H', 'D'); // Surface shader data
    constexpr uint32_t ATTR = make_id ('A', 'T', 'T', 'R'); // Attributes
    constexpr uint32_t META = make_id ('M', 'E', 'T', 'A'); // Metadata
    constexpr uint32_t ADAT = make_id ('A', 'D', 'A', 'T'); // Attribute data
    constexpr uint32_t ENTR = make_id ('E', 'N', 'T', 'R'); // Entry
    constexpr uint32_t VALU = make_id ('V', 'A', 'L', 'U'); // Value
    constexpr uint32_t VPRM = make_id ('V', 'P', 'R', 'M'); // Vertex parameters
    constexpr uint32_t VPVL = make_id ('V', 'P', 'V', 'L'); // Vertex parameter value

    // normal map
    constexpr uint32_t IINX = make_id ('I', 'I', 'N', 'X');
    constexpr uint32_t IINY = make_id ('I', 'I', 'N', 'Y');
    constexpr uint32_t IINZ = make_id ('I', 'I', 'N', 'Z');

    // Geometry
    constexpr uint32_t TAGS = make_id ('T', 'A', 'G', 'S'); // Surface tags
    constexpr uint32_t LAYR = make_id ('L', 'A', 'Y', 'R'); // Layer
    constexpr uint32_t PNTS = make_id ('P', 'N', 'T', 'S'); // Points
    constexpr uint32_t BBOX = make_id ('B', 'B', 'O', 'X'); // Bounding box
    constexpr uint32_t VMPA = make_id ('V', 'M', 'P', 'A'); // Vertex map parameters
    constexpr uint32_t VMAP = make_id ('V', 'M', 'A', 'P'); // Vertex map
    constexpr uint32_t POLS = make_id ('P', 'O', 'L', 'S'); // Polygons
    constexpr uint32_t OTAG = make_id ('O', 'T', 'A', 'G'); // Object tag

    // Polygon types
    constexpr uint32_t FACE = make_id ('F', 'A', 'C', 'E'); // Face type polygons
    constexpr uint32_t CURV = make_id ('C', 'U', 'R', 'V'); // Curve type polygons
    constexpr uint32_t PTCH = make_id ('P', 'T', 'C', 'H'); // Patch type polygons
    constexpr uint32_t MBAL = make_id ('M', 'B', 'A', 'L'); // Metaball type polygons
    constexpr uint32_t BONE = make_id ('B', 'O', 'N', 'E'); // Bone type polygons

    // Vertex map types
    constexpr uint32_t PICK = make_id ('P', 'I', 'C', 'K'); // Selection set
    constexpr uint32_t WGHT = make_id ('W', 'G', 'H', 'T'); // Weight maps
    constexpr uint32_t MNVW = make_id ('M', 'N', 'V', 'W'); // Subpatch weight maps
    constexpr uint32_t TXUV = make_id ('T', 'X', 'U', 'V'); // UV texture coordinates
    constexpr uint32_t MORF = make_id ('M', 'O', 'R', 'F'); // Morph target maps
    constexpr uint32_t SPOT = make_id ('S', 'P', 'O', 'T'); // Spot maps
    constexpr uint32_t RGB = make_id ('R', 'G', 'B', ' ');  // RGB color maps
    constexpr uint32_t RGBA = make_id ('R', 'G', 'B', 'A'); // RGBA color maps

    // Surfaces
    constexpr uint32_t COLR = make_id ('C', 'O', 'L', 'R'); // Base color
    constexpr uint32_t LUMI = make_id ('L', 'U', 'M', 'I'); // Luminosity
    constexpr uint32_t DIFF = make_id ('D', 'I', 'F', 'F'); // Diffuse
    constexpr uint32_t SPEC = make_id ('S', 'P', 'E', 'C'); // Specularity
    constexpr uint32_t GLOS = make_id ('G', 'L', 'O', 'S'); // Glossiness
    constexpr uint32_t REFL = make_id ('R', 'E', 'F', 'L'); // Reflection
    constexpr uint32_t RFOP = make_id ('R', 'F', 'O', 'P'); // Reflection options
    constexpr uint32_t RIMG = make_id ('R', 'I', 'M', 'G'); // Reflection image
    constexpr uint32_t RSAN = make_id ('R', 'S', 'A', 'N'); // Reflection seam angle
    constexpr uint32_t TRAN = make_id ('T', 'R', 'A', 'N'); // Transparency
    constexpr uint32_t TROP = make_id ('T', 'R', 'O', 'P'); // Transparency options
    constexpr uint32_t TIMG = make_id ('T', 'I', 'M', 'G'); // Transparency image
    constexpr uint32_t RIND = make_id ('R', 'I', 'N', 'D'); // Refraction index
    constexpr uint32_t TRNL = make_id ('T', 'R', 'N', 'L'); // Translucency
    constexpr uint32_t BUMP = make_id ('B', 'U', 'M', 'P'); // Bump
    constexpr uint32_t SMAN = make_id ('S', 'M', 'A', 'N'); // Max smoothing angle
    constexpr uint32_t SIDE = make_id ('S', 'I', 'D', 'E'); // Sidedness
    constexpr uint32_t CLRH = make_id ('C', 'L', 'R', 'H'); // Color highlights
    constexpr uint32_t CLRF = make_id ('C', 'L', 'R', 'F'); // Color filter
    constexpr uint32_t ADTR = make_id ('A', 'D', 'T', 'R'); // Additive transparency
    constexpr uint32_t SHRP = make_id ('S', 'H', 'R', 'P'); // Diffuse sharpness
    constexpr uint32_t LSIZ = make_id ('L', 'S', 'I', 'Z'); // Line size
    constexpr uint32_t ALPH = make_id ('A', 'L', 'P', 'H'); // Alpha mode
    constexpr uint32_t AVAL = make_id ('A', 'V', 'A', 'L'); // Alpha value
    constexpr uint32_t GVAL = make_id ('G', 'V', 'A', 'L'); // Glow value
    constexpr uint32_t BLOK = make_id ('B', 'L', 'O', 'K'); // Render block
    constexpr uint32_t TMAP = make_id ('T', 'M', 'A', 'P'); // Texture map

    constexpr uint32_t PTAG = make_id ('P', 'T', 'A', 'G'); // Polygon tags
    constexpr uint32_t VMAD = make_id ('V', 'M', 'A', 'D'); // Discontinuous vertex mapping
    constexpr uint32_t FLAG = make_id ('F', 'L', 'A', 'G'); // Flags

    constexpr uint32_t VERS = make_id ('V', 'E', 'R', 'S'); // Version
    constexpr uint32_t NLOC = make_id ('N', 'L', 'O', 'C'); // Node location
    constexpr uint32_t NZOM = make_id ('N', 'Z', 'O', 'M'); // Node zoom
    constexpr uint32_t NSEL = make_id ('N', 'S', 'E', 'L'); // Node selection state
    constexpr uint32_t NCOL = make_id ('N', 'C', 'O', 'L'); // Node column
    constexpr uint32_t NFRS = make_id ('N', 'F', 'R', 'S'); // Node plugin name
    constexpr uint32_t NSTA = make_id ('N', 'S', 'T', 'A'); // Node state
    constexpr uint32_t NVER = make_id ('N', 'V', 'E', 'R'); // Node version
    constexpr uint32_t NSRV = make_id ('N', 'S', 'R', 'V'); // Node server
    constexpr uint32_t NRNM = make_id ('N', 'R', 'N', 'M'); // Node real name
    constexpr uint32_t NNME = make_id ('N', 'N', 'M', 'E'); // Node name
    constexpr uint32_t NCRD = make_id ('N', 'C', 'R', 'D'); // Node coordinates
    constexpr uint32_t NMOD = make_id ('N', 'M', 'O', 'D'); // Node mode
    constexpr uint32_t NPRW = make_id ('N', 'P', 'R', 'W'); // Node preview
    constexpr uint32_t NCOM = make_id ('N', 'C', 'O', 'M'); // Node comment
    constexpr uint32_t IPIX = make_id ('I', 'P', 'I', 'X'); // Image pixel filter
    constexpr uint32_t IMIP = make_id ('I', 'M', 'I', 'P'); // Image mipmap
    constexpr uint32_t IMOD = make_id ('I', 'M', 'O', 'D'); // Image edit mode
    constexpr uint32_t IINV = make_id ('I', 'I', 'N', 'V'); // Image invert
    constexpr uint32_t INCR = make_id ('I', 'N', 'C', 'R'); // Image normal correction
    constexpr uint32_t IMAP = make_id ('I', 'M', 'A', 'P'); // Image mapping
    constexpr uint32_t IAXS = make_id ('I', 'A', 'X', 'S'); // Image axis
    constexpr uint32_t IFOT = make_id ('I', 'F', 'O', 'T'); // Image falloff type
    constexpr uint32_t IWRL = make_id ('I', 'W', 'R', 'L'); // Image wrap layers
    constexpr uint32_t IREF = make_id ('I', 'R', 'E', 'F'); // Image reference
    constexpr uint32_t IUVI = make_id ('I', 'U', 'V', 'I'); // Image UV index
    constexpr uint32_t IUTI = make_id ('I', 'U', 'T', 'I'); // Image U tile
    constexpr uint32_t ITIM = make_id ('I', 'T', 'I', 'M'); // Image time
    constexpr uint32_t IUTL = make_id ('I', 'U', 'T', 'L'); // Image U tile loop
    constexpr uint32_t IVTL = make_id ('I', 'V', 'T', 'L'); // Image V tile loop
    constexpr uint32_t INME = make_id ('I', 'N', 'M', 'E'); // Input node name
    constexpr uint32_t IINM = make_id ('I', 'I', 'N', 'M'); // Input name
    constexpr uint32_t IINN = make_id ('I', 'I', 'N', 'N'); // Input node name
    constexpr uint32_t IONM = make_id ('I', 'O', 'N', 'M'); // Input output name
    constexpr uint32_t SSHN = make_id ('S', 'S', 'H', 'N'); // Surface shader name
    constexpr uint32_t NAME = make_id ('N', 'A', 'M', 'E'); // Name
    constexpr uint32_t ENUM = make_id ('E', 'N', 'U', 'M'); // Enumeration
    constexpr uint32_t TAG = make_id ('T', 'A', 'G', ' ');  // Tag
    constexpr uint32_t NPLA = make_id ('N', 'P', 'L', 'A'); // Node placement
    constexpr uint32_t AOVS = make_id ('A', 'O', 'V', 'S'); // Arbitrary Output Variables.
    constexpr uint32_t SATR = make_id ('S', 'A', 'T', 'R'); // Standard Material Attribute maybe??
    // Anonymous chunk (four spaces)
    constexpr uint32_t ANON = 0x20202020;

    // these are temporary ANON replacements, they will still be written is 4 spaces
    constexpr uint32_t SNAM = make_id ('S', 'N', 'A', 'M'); // Surface Name
    constexpr uint32_t CIDX = make_id ('C', 'I', 'D', 'X'); // Clip Index
    constexpr uint32_t SFNM = make_id ('S', 'F', 'N', 'M'); // Still File Name
    constexpr uint32_t VTYP = make_id ('V', 'T', 'Y', 'P'); // Value Type
    constexpr uint32_t VVAL = make_id ('V', 'V', 'A', 'L'); // Value Value
    constexpr uint32_t IVAL = make_id ('I', 'V', 'A', 'L'); // Image Value
    constexpr uint32_t VDAT = make_id ('V', 'D', 'A', 'T'); // Value Data

    // temp standin for PTAGs
    constexpr uint32_t PTAG_SURF = make_id ('P', 'T', 'G', 'S'); // PTAG for Surface
    constexpr uint32_t PTAG_COLR = make_id ('P', 'T', 'G', 'C'); // PTAG for Color

    constexpr uint32_t CLRS = make_id ('C', 'L', 'R', 'S');
    constexpr uint32_t CLRA = make_id ('C', 'L', 'R', 'A');
} // namespace LWO

inline std::string idToString (uint32_t id)
{
    std::array<char, 5> str;
    str[0] = static_cast<char> ((id >> 24) & 0xFF);
    str[1] = static_cast<char> ((id >> 16) & 0xFF);
    str[2] = static_cast<char> ((id >> 8) & 0xFF);
    str[3] = static_cast<char> (id & 0xFF);
    str[4] = '\0';
    return std::string (str.data());
}
</file>

<file path="lwo3/LWO3Element.h">
#pragma once

// Composite Pattern Explanation:
//
// The Composite Pattern is a structural design pattern that allows composing objects into tree
// structures to represent part-whole hierarchies. It enables clients to treat individual objects
// and compositions of objects uniformly.
//
// In the context of the LWO3 file structure:
//
// 1. LWO3Element is the component interface, declaring operations common to both simple and
//    complex elements of the composition.
//
// 2. LWO3Chunk is the leaf, representing end objects of the composition. A leaf has no children.
//
// 3. LWO3Form is the composite, representing complex elements that may have children. It stores
//    child components and implements child-related operations.
//
// This pattern is particularly useful for the LWO3 format because:
// - It reflects the natural structure of the LWO3 file format, which consists of nested forms
//   and chunks.
// - It allows for recursive processing of the file structure, as each form can contain other
//   forms or chunks.
// - It provides a uniform interface for working with both simple (chunks) and complex (forms)
//   elements, simplifying client code that processes the LWO3 structure.
//
// The Visitor Pattern is often used in conjunction with the Composite Pattern to perform
// operations on the composite structure, as seen in the `accept` methods and the LWO3Visitor class.

// LWO3Element: Abstract base class for LWO3 file structure elements
//
// This class represents the common interface for both LWO3 chunks and forms.
// It's part of the Composite Pattern implementation for LWO3 file structure.
//#include "LWO3Defs.h"

class LWO3Visitor;

class LWO3Element
{
 public:
    LWO3Element (uint32_t id, size_t offset = 0) :
        id_ (id),
        fileOffset_ (offset) {}
    virtual ~LWO3Element() = default;

    virtual void accept (LWO3Visitor& visitor) const = 0;
    virtual bool isForm() const = 0;

    uint32_t getId() const { return id_; }
    size_t getFileOffset() const { return fileOffset_; }

 protected:
    uint32_t id_;
    size_t fileOffset_;
};
</file>

<file path="lwo3/LWO3Form.h">
#pragma once

// LWO3Form: Represents a container element in the LWO3 file structure
// Forms can contain other forms or chunks and track their file offset for debugging
// Serves as the "Composite" component in the Composite Pattern

class LWO3Form : public LWO3Element
{
 public:
    LWO3Form (uint32_t id, size_t offset = 0) :
        LWO3Element (id, offset) {}

    void accept (LWO3Visitor& visitor) const override
    {
        visitor.visitForm (*this);
        for (const auto& child : children_)
        {
            child->accept (visitor);
        }
    }

    bool isForm() const override { return true; }

    void addChild (std::unique_ptr<LWO3Element> child)
    {
        children_.push_back (std::move (child));
    }

    const std::vector<std::unique_ptr<LWO3Element>>& getChildren() const
    {
        return children_;
    }

 private:
    std::vector<std::unique_ptr<LWO3Element>> children_;
};
</file>

<file path="lwo3/LWO3Visitor.h">
#pragma once

// LWO3Visitor: Abstract base class for visitors of the LWO3 structure
//
// This class defines the interface for concrete visitors that can traverse
// and operate on the LWO3 file structure. It's part of the Visitor Pattern implementation.

//#include <wabi_core/wabi_core.h>

class LWO3Form;
class LWO3Chunk;

class LWO3Visitor
{
 public:
    virtual ~LWO3Visitor() = default;
    virtual void visitForm (const LWO3Form& form) = 0;
    virtual void visitChunk (const LWO3Chunk& chunk) = 0;
};
</file>

<file path="scene/RayIntersectionInfo.h">
// This header file was auto-generated by ClassMate++
// Created: 22 Nov 2021 6:51:08 pm
// Copyright (c) 2021, HurleyWorks

#pragma once

struct RayIntersectionInfo
{
    Eigen::Vector3f rayOrigin = Eigen::Vector3f::Zero();
    Eigen::Vector3f rayDirection = Eigen::Vector3f::Zero();
    Eigen::Vector3f rayHitPoint = Eigen::Vector3f::Constant (std::numeric_limits<float>::max());
    Eigen::Vector3f hitSurfaceNormal = Eigen::Vector3f::Zero();
    ItemID hitItem = INVALID_ID;
};
</file>

<file path="scene/Renderable.h">
// This header file was auto-generated by ClassMate++
// Created: 29 Dec 2018 1:52:03 pm
// Copyright (c) 2018, HurleyWorks

#pragma once

// From Design Patterns book:

// The choice of internal representation for the scene affects nearly
// every aspect of the framework's design. All editing, formatting, displaying
// and analysis will require traversing this representation. The way we organize
// this information will impact the design of the rest of the application

// Composite Pattern
//   Compose objects into tree structures to represent part - whole hierarchies.
//   Composite lets clients treat individual objecta and compositions of objects uniformily

using RenderableNode = std::shared_ptr<class Renderable>;
using RenderableWeakRef = std::weak_ptr<class Renderable>;
using RenderableMap = std::unordered_map<ItemID, RenderableNode>;
using WeakRenderableMap = std::unordered_map<ItemID, RenderableWeakRef>;
using RenderableList = std::vector<RenderableNode>;
using WeakRenderableList = std::vector<RenderableWeakRef>;
using RenderableSet = std::unordered_set<RenderableNode>;
using RenderableQueue = std::deque<RenderableNode>;
using RenderableStack = moodycamel::ConcurrentQueue<sabi::RenderableNode>;
using RenderableWeakStack = moodycamel::ConcurrentQueue<sabi::RenderableWeakRef>;
using sabi::BodyType;
using sabi::CollisionShape;

// inspired by Paul Houx's cinder version
// https://github.com/paulhoux/Cinder-Samples/tree/master/SimpleSceneGraph

class Renderable : public std::enable_shared_from_this<Renderable>,
                   protected Noncopyable,
                   public HasId
{
 public:
    RenderableNode getPtr() { return shared_from_this(); }

 public:
    virtual ~Renderable()
    {
        LOG (DBUG) << getName() << "::" << getID();
    }

    const ItemID getID() const { return id(); }
    const BodyID getClientID() const { return clientID; }
    void setClientID (BodyID bodyID) { clientID = bodyID; }

    const std::string& getName() const { return name; }
    void setName (const std::string& name) { this->name = name; }

    const RenderableDesc& description() const { return desc; }
    RenderableDesc& description() { return desc; }
    void setDescription (const RenderableDesc& description) { desc = description; }

    // physics
    BodyType getBodyType() { return desc.bodyType; }
    CollisionShape getCollisionShape() const { return desc.shape; }

    const RenderableState& getState() const { return state; }
    RenderableState& getState() { return state; }
    void setState (RenderableState state) { this->state = state; }

    CgModelPtr getModel() const { return cgModel; }
    void setModel (CgModelPtr cgModel) { this->cgModel = cgModel; }
    size_t getTriangleCount() const { return cgModel ? cgModel->triangleCount() : 0; }

    SpaceTime& getSpaceTime() { return spacetime; }
    const SpaceTime& getSpaceTime() const { return spacetime; }
    void setSpacetime (const SpaceTime& spacetime) { this->spacetime = spacetime; }

    void debug (const std::string& msg)
    {
        LOG (DBUG) << msg << "::" << getName() << "::" << getID() << "::" << getPtr().use_count();
    }

    virtual const RenderableData getData() const
    {
        RenderableData d;
        d.clientID = clientID;
        d.desc = desc;
        d.cgModel = cgModel;
        d.name = name;
        d.sceneID = id();
        d.spacetime = spacetime;
        d.state = state;
        // d.pose = const_cast<float*>(spacetime.worldTransform.data());
        const float* m = spacetime.worldTransform.matrix().data();
        for (int i = 0; i < 16; i++)
        {
            d.pose[i] = m[i];
        }
        return d;
    }

    virtual void addChild (RenderableNode node) {}
    virtual bool hasChild (RenderableNode node) const { return false; }
    virtual RenderableNode findChild (ItemID key) { return nullptr; }
    virtual RenderableNode createClone (RenderableNode source) { return nullptr; }

    virtual RenderableNode createInstance() { return nullptr; }
    virtual void setInstancedFrom (RenderableNode node) {}
    virtual RenderableNode getInstancedFrom() { return nullptr; }
    virtual bool isInstance() const { return false; }
    virtual size_t getNumberOfInstances() const { return 0; }

    virtual RenderableNode createPhysicsPhantom() { return nullptr; }
    virtual void setPhantomFrom (RenderableNode node) {}
    virtual RenderableNode getPhantomFrom() { return nullptr; }
    virtual bool isPhantom() const { return false; }

    virtual RenderableNode getRestingOn() { return nullptr; }
    virtual void setRestingOn (RenderableNode node) {}

    virtual void removeChild (RenderableNode node) {}
    virtual void removeChildren() {}

    void setParent (RenderableNode node) { parent = RenderableWeakRef (node); }
    RenderableNode getParent() const { return parent.lock(); }

    const RenderableMap& getChildren() const { return children; }
    RenderableMap& getChildren() { return children; }

    template <class T>
    std::shared_ptr<T> getParent() const
    {
        return std::dynamic_pointer_cast<T> (parent.lock());
    }

    void* getUserdata() { return userdata; }
    void setUserData (void* data) { userdata = data; }
    void* getUserdata2() { return userdata2; }
    void setUserData2 (void* data) { userdata2 = data; }

 protected:
    Renderable() {}

    RenderableWeakRef parent;

    RenderableMap children;

    // a renderable item has a location in spacetime
    SpaceTime spacetime;

    // a renderable might have a cgModel(geometry and materials)
    CgModelPtr cgModel = nullptr;

    // a renderable has a description
    RenderableDesc desc;

    // a renderable has a state
    RenderableState state;

    // might have a client side id
    BodyID clientID = INVALID_ID;

    // a renderable has a name
    std::string name = "unnamed";

    // can I do this with templates somewhow?
    void* userdata = nullptr;
    void* userdata2 = nullptr;
};
</file>

<file path="scene/RenderableData.h">
#pragma once

// state of the engine here so all can see
static const char* PhysicsEngineStateTable[] =
    {
        "Start",
        "Step",
        "Pause",
        "Reset",
        "Invalid"};

struct PhysicsEngineState
{
    enum EPhysicsEngineState
    {
        Start,
        Step,
        Pause,
        Reset,
        Count,
        Invalid = Count
    };

    union
    {
        EPhysicsEngineState name;
        unsigned int value;
    };

    PhysicsEngineState (EPhysicsEngineState name) :
        name (name) {}
    PhysicsEngineState (unsigned int value) :
        value (value) {}
    PhysicsEngineState() :
        value (Invalid) {}
    operator EPhysicsEngineState() const { return name; }
    const char* toString() const { return PhysicsEngineStateTable[value]; }
};

static const char* BodyTypeTable[] =
    {
        "None",
        "Static",
        "Dynamic",
        "Fluid",
        "Invalid"};

struct BodyType
{
    enum EBodyType
    {
        None,
        Static,
        Dynamic,
        Fluid,
        Count,
        Invalid = Count
    };

    union
    {
        EBodyType name;
        unsigned int value;
    };

    BodyType (EBodyType name) :
        name (name) {}
    BodyType (unsigned int value) :
        value (value) {}
    BodyType() :
        value (Invalid) {}
    operator EBodyType() const { return name; }
    const char* toString() const { return BodyTypeTable[value]; }
    static BodyType FromString (const char* str) { return mace::TableLookup (str, BodyTypeTable, Count); }
};

static const char* CollisionShapeTable[] =
    {   
        "None",
        "Ball",
        "Box",
        "Convex hull",
        "Mesh",
        "Composite",
        "Compound",
        "Invalid"};

struct CollisionShape
{
    enum ECollisionShape
    {
        None,
        Ball,
        Box,
        ConvexHull,
        Mesh,
        Composite,
        Compound,
        Count,
        Invalid = Count
    };

    union
    {
        ECollisionShape name;
        unsigned int value;
    };

    CollisionShape (ECollisionShape name) :
        name (name) {}
    CollisionShape (unsigned int value) :
        value (value) {}
    CollisionShape() :
        value (Invalid) {}
    operator ECollisionShape() const { return name; }
    const char* toString() const { return CollisionShapeTable[value]; }
    static CollisionShape FromString (const char* str) { return mace::TableLookup (str, CollisionShapeTable, Count); }
};

static const char* EmitterTypeTable[] =
    {
        "Zaxis",
        "Vertices",
        "None",
        "Invalid"};

struct EmitterType
{
    enum EEmitterType
    {
        Zaxis,
        Vertices,
        None,
        Count,
        Invalid = Count
    };

    union
    {
        EEmitterType name;
        unsigned int value;
    };

    EmitterType (EEmitterType name) :
        name (name) {}
    EmitterType (unsigned int value) :
        value (value) {}
    EmitterType() :
        value (Invalid) {}
    operator EEmitterType() const { return name; }
    const char* ToString() const { return EmitterTypeTable[value]; }
};

static const char* EmitModeTable[] =
    {
        "Mouse",
        "Item",
        "Invalid"};

struct EmitMode
{
    enum EEmitMode
    {
        Mouse,
        Item,
        Count,
        Invalid = Count
    };

    union
    {
        EEmitMode name;
        unsigned int value;
    };

    EmitMode (EEmitMode name) :
        name (name) {}
    EmitMode (unsigned int value) :
        value (value) {}
    EmitMode() :
        value (Invalid) {}
    operator EEmitMode() const { return name; }
    const char* ToString() const { return EmitModeTable[value]; }
    static EmitMode FromString (const char* str) { return mace::TableLookup (str, EmitModeTable, Count); }
};

const EmitterType DEFAULT_EMITTER_TYPE = EmitterType::Zaxis;

static const char* PrimitiveTypeTable[] =
    {
        "Tetrahedron",
        "Hexahedron",
        "Octahedron",
        "Dodecahedron",
        "Icosahedron",
        "Icosphere",
        "Sphere",
        "Plane",
        "Cone",
        "Cylinder",
        "Capsule",
        "Torus",
        "Bowl"
        "Invalid"};

struct PrimitiveType
{
    enum EPrimitiveType
    {
        Tetrahedron,
        Hexahedron,
        Octahedron,
        Dodecahedron,
        Icosahedron,
        Icosphere,
        Sphere,
        Plane,
        Cone,
        Cylinder,
        Capsule,
        Torus,
        Bowl,
        Count,
        Invalid = Count
    };

    union
    {
        EPrimitiveType name;
        unsigned int value;
    };

    PrimitiveType (EPrimitiveType name) :
        name (name) {}
    PrimitiveType (unsigned int value) :
        value (value) {}
    PrimitiveType() :
        value (Invalid) {}
    operator EPrimitiveType() const { return name; }
    const char* toString() const { return PrimitiveTypeTable[value]; }
    static PrimitiveType FromString (const char* str) { return mace::TableLookup (str, PrimitiveTypeTable, Count); }
};


const BodyType DEFAULT_BODY_TYPE = BodyType::None;
const CollisionShape DEFAULT_COLLISION_SHAPE = CollisionShape::None;
constexpr double DEFAULT_ADHESION = 0.0;
constexpr double DEFAULT_STATIC_MASS = 0.0;
constexpr double DEFAULT_DYNAMIC_MASS = 2.0;
constexpr double DEFAULT_STATIC_FRICTION = 0.8;
constexpr double DEFAULT_DYNAMIC_FRICTION = 0.4;
constexpr double DEFAULT_BOUNCINESS = 0.0;
const Eigen::Vector3d DEFAULT_FORCE = Eigen::Vector3d (0.0f, -10.0f, 0.0f);
constexpr double DEFAULT_IMPULSE_SPEED = 0.0;
const Eigen::Vector3d DEFAULT_IMPULSE_DIRECTION = Eigen::Vector3d (0.0f, 0.0f, 0.0f);
constexpr uint32_t DEFAULT_SLEEP_STATE = 0;
</file>

<file path="scene/RenderableDesc.h">
// This header file was auto-generated by ClassMate++
// Created: 16 Sep 2017 5:37:16 pm
// Copyright (c) 2017, HurleyWorks

#pragma once

using Eigen::Matrix4f;
using Eigen::Vector3d;

// have to change floats to doubles to accomodate dear old LW
struct RenderableDesc
{
	// full path to file containing cgModel, materials etc
    std::filesystem::path modelPath = std::filesystem::path();
  
	BodyType bodyType = DEFAULT_BODY_TYPE;

	CollisionShape shape = DEFAULT_COLLISION_SHAPE;
    double mass = DEFAULT_DYNAMIC_MASS;
	//double adhesion = DEFAULT_ADHESION;
	double bounciness = DEFAULT_BOUNCINESS;
	double staticFriction = DEFAULT_STATIC_FRICTION;
	double dynamicFriction = DEFAULT_DYNAMIC_FRICTION;
	uint32_t sleepState = DEFAULT_SLEEP_STATE;
	Eigen::Vector3d force = DEFAULT_FORCE;
	double impulseSpeed = DEFAULT_IMPULSE_SPEED;
    Eigen::Vector3d impulseDirection = DEFAULT_IMPULSE_DIRECTION;

	void resetToDefault()
	{
        modelPath = std::filesystem::path();
		bodyType = DEFAULT_BODY_TYPE;
		shape = DEFAULT_COLLISION_SHAPE;
        mass = DEFAULT_DYNAMIC_MASS;
		sleepState = DEFAULT_SLEEP_STATE;
		//adhesion = DEFAULT_ADHESION;
		staticFriction = DEFAULT_STATIC_FRICTION;
		dynamicFriction = DEFAULT_DYNAMIC_FRICTION;
		bounciness = DEFAULT_BOUNCINESS;
		force = DEFAULT_FORCE;
        impulseSpeed = DEFAULT_IMPULSE_SPEED;
        impulseDirection = DEFAULT_IMPULSE_DIRECTION;
	}

	void debug()
	{
		LOG(DBUG) << "FullFilePath: " << modelPath.generic_string();
		LOG(DBUG) << "Body type: " << bodyType.toString();
		LOG(DBUG) << "CollisionShape: " << shape.toString();
		//LOG(DBUG) << "Adhesion" << adhesion;
		LOG(DBUG) << "Mass: " << mass;
		LOG(DBUG) << "Static friction: " << staticFriction;
		LOG(DBUG) << "Dynamic friction: " << dynamicFriction;
		LOG(DBUG) << "Bounciness: " << bounciness;
		LOG(DBUG) << "Force: " << force.x() << ", " << force.y() << ", " << force.z();
        LOG (DBUG) << "Impulse Speed: " << impulseSpeed;
        LOG (DBUG) << "Impulse Direction: " << impulseDirection.x() << ", " << impulseDirection.y() << ", " << impulseDirection.z();
	}
};

using RenderableDataHandle = std::shared_ptr<struct RenderableData>;

struct RenderableData
{
	RenderableData()
	{
	}
	sabi::CgModelPtr cgModel = nullptr;
	std::string name = "unnamed";
	ItemID sceneID = INVALID_ID;
	BodyID clientID = INVALID_ID;
	ItemID sourceID = INVALID_ID; // for instances

	sabi::SpaceTime spacetime;
	sabi::RenderableDesc desc;
	sabi::RenderableState state;
	sabi::MeshOptions meshOptions;
	std::array<float, 16> pose;

	void debug()
	{
		LOG(DBUG) << "name: " << name;
		LOG(DBUG) << "sceneID: " << sceneID;
		LOG(DBUG) << "clientID: " << clientID;
		LOG(DBUG) << "instanaced from ID: " << sourceID;
		LOG(DBUG) << "state: " << state.toString();
		LOG(DBUG) << "cgModel options: " << meshOptions.toString();

		desc.debug();

		mace::matStr4f(spacetime.worldTransform, DBUG, "World transform");
		mace::vecStr3f(spacetime.scale, DBUG, "Scale");

		if (cgModel)
		{
			LOG(DBUG) << "Mesh has " << cgModel->vertexCount() << " vertices";
			LOG(DBUG) << "Mesh has " << cgModel->triangleCount() << " triangles";
			// LOG (DBUG) << "Mesh has " << cgModel->P.size() << " particles";
		}
	}
};

using LoadData = std::vector<RenderableData>;
</file>

<file path="scene/RenderableState.h">
// This header file was auto-generated by ClassMate++
// Created: 16 Sep 2017 5:37:16 pm
// Copyright (c) 2017, HurleyWorks

#pragma once

static const char* PRenderableStateTable[] =
    {
        "Pickable",
        "Selected",
        "SelectionChanged",
        "Deletable",
        "Visible",
        "Emitter",
        "Target",
        "UserAnimated",
        "FluidMesh",
        "SplashMesh",
        "SplashInstanceMesh",
        "MeshIsDirty",
        "Breakable",
        "UnseenByPickRay",
        "BeingPainted",
        "ImpulseApplied", 
        "LoadedFromScene",
        "ProcessedByRenderer",
        "Invalid"};

struct PRenderableState
{
    enum EPRenderableState
    {
        Pickable = 1 << 0,
        Selected = 1 << 1,
        SelectionChanged = 1 << 2,
        Deletable = 1 << 3,
        Visible = 1 << 4,
        Emitter = 1 << 5,
        Target = 1 << 6,
        UserAnimated = 1 << 7,
        FluidMesh = 1 << 8,
        SplashMesh = 1 << 9,
        SplashInstanceMesh = 1 << 10,
        MeshIsDirty = 1 << 11,
        Breakable = 1 << 12,
        UnseenByPickRay = 1 << 13,
        BeingPainted = 1 << 14,
        ImpulseApplied = 1 << 15,
        LoadedFromScene = 1 << 16,
        ProcessedByRenderer = 1 << 17,
        StoredInSceneHandler = 1 << 18,
        Invalid = 1 << 19 
    };

    union
    {
        EPRenderableState name;
        unsigned long value;
    };

    PRenderableState (EPRenderableState name) :
        name (name) {}
    PRenderableState (unsigned long value) :
        value (value) {}
    PRenderableState() :
        value (0) {}
    void clear() { value = 0; }
    operator EPRenderableState() const { return name; }
    unsigned long operator|= (PRenderableState m) { return value |= m; }
    unsigned long operator&= (PRenderableState m) { return value &= m; }
    unsigned long operator^= (PRenderableState m) { return value ^= m; }

    std::string toString()
    {
        std::ostringstream ostr;
        ostr << "  PRenderableState::";

        if (value & Pickable)
            ostr << "Pickable:";

        if (value & Selected)
            ostr << "Selected:";

        if (value & SelectionChanged)
            ostr << "SelectionChanged:";

        if (value & Deletable)
            ostr << "Deletable:";

        if (value & Visible)
            ostr << "Visible:";

        if (value & Emitter)
            ostr << "Emitter:";

        if (value & Target)
            ostr << "Target:";

        if (value & UserAnimated)
            ostr << "UserAnimated:";

        if (value & FluidMesh)
            ostr << "FluidMesh:";

        if (value & SplashMesh)
            ostr << "SplashMesh:";

        if (value & SplashInstanceMesh)
            ostr << "SplashInstanceMesh:";

        if (value & MeshIsDirty)
            ostr << "MeshIsDirty:";

        if (value & Breakable)
            ostr << "Breakable:";

        if (value & UnseenByPickRay)
            ostr << "UnseenByPickRay:";

        if (value & BeingPainted)
            ostr << "BeingPainted:";

        if (value & ImpulseApplied)
            ostr << "ImpulseApplied:";

        if (value & LoadedFromScene)
            ostr << "LoadedFromScene:";

        if (value & ProcessedByRenderer)
            ostr << "ProcessedByRenderer:";

         if (value & StoredInSceneHandler)
            ostr << "StoredInSceneHandler:";


        if (value & Invalid)
            ostr << "Invalid:";

        return ostr.str();
    }
};

// the state of a RenderableNode
struct RenderableState
{
    bool isBreakable() const { return (state & PRenderableState::Breakable) == PRenderableState::Breakable; }
    bool isSelected() const { return (state & PRenderableState::Selected) == PRenderableState::Selected; }
    bool hasSelectionChanged() const { return (state & PRenderableState::SelectionChanged) == PRenderableState::SelectionChanged; }
    bool isPickable() const { return (state & PRenderableState::Pickable) == PRenderableState::Pickable; }
    bool isDeletable() const { return (state & PRenderableState::Deletable) == PRenderableState::Deletable; }
    bool isVisible() const { return (state & PRenderableState::Visible) == PRenderableState::Visible; }
    bool isEmitter() const { return (state & PRenderableState::Emitter) == PRenderableState::Emitter; }
    bool isTarget() const { return (state & PRenderableState::Target) == PRenderableState::Target; }
    bool isFluidMesh() const { return (state & PRenderableState::FluidMesh) == PRenderableState::FluidMesh; }
    bool isSplashMesh() const { return (state & PRenderableState::SplashMesh) == PRenderableState::SplashMesh; }
    bool isSplashInstanceMesh() const { return (state & PRenderableState::SplashInstanceMesh) == PRenderableState::SplashInstanceMesh; }
    bool isMeshIsDirty() const { return (state & PRenderableState::MeshIsDirty) == PRenderableState::MeshIsDirty; }
    bool IsUserAnimated() const { return (state & PRenderableState::UserAnimated) == PRenderableState::UserAnimated; }
    bool IsUnseenByPickRay() const { return (state & PRenderableState::UnseenByPickRay) == PRenderableState::UnseenByPickRay; }
    bool IsBeingPainted() const { return (state & PRenderableState::BeingPainted) == PRenderableState::BeingPainted; }
    bool hasImpulseApplied() const { return (state & PRenderableState::ImpulseApplied) == PRenderableState::ImpulseApplied; }
    bool isLoadedFromScene() const { return (state & PRenderableState::LoadedFromScene) == PRenderableState::LoadedFromScene; }
    bool isProcessedByRenderer() const { return (state & PRenderableState::ProcessedByRenderer) == PRenderableState::ProcessedByRenderer; }
    bool isStoredInSceneHandler() const { return (state & PRenderableState::StoredInSceneHandler) == PRenderableState::StoredInSceneHandler; }
    std::string toString() { return state.toString(); }

    PRenderableState state = 0;
};
</file>

<file path="scene/SceneOptions.h">
// This header file was auto-generated by ClassMate++
// Created: 16 Sep 2017 5:37:16 pm
// Copyright (c) 2017, HurleyWorks

#pragma once

static const char* LoadOptionsTable[] =
    {
        "MeshesOnly",
        "ImagesOnly",
        "MeshesAndImages",
        "Invalid"};

struct LoadOptions
{
    enum ELoadOptions
    {
        MeshesOnly = 1 << 0,
        ImagesOnly = 1 << 1,
        MeshesAndImages = 1 << 2,
        Invalid = 1 << 3
    };

    union
    {
        ELoadOptions name;
        unsigned value;
    };

    LoadOptions (ELoadOptions name) :
        name (name) {}
    LoadOptions (unsigned value) :
        value (value) {}
    LoadOptions() :
        value (0) {}
    void clear() { value = 0; }
    operator ELoadOptions() const { return name; }
    unsigned operator|= (LoadOptions m) { return value |= m; }
    unsigned operator&= (LoadOptions m) { return value &= m; }
    unsigned operator^= (LoadOptions m) { return value ^= m; }

    std::string toString()
    {
        std::ostringstream ostr;
        ostr << "  LoadOptions";

        if (value & MeshesOnly)
            ostr << "::MeshesOnly";

        if (value & ImagesOnly)
            ostr << "::ImagesOnly:";

        if (value & MeshesAndImages)
            ostr << "::MeshesAndImages:";

        if (value & Invalid)
            ostr << "::Invalid:";

        return ostr.str();
    }
};

static const char* SelectionOptionsTable[] =
    {
        "None",
        "All",
        "Invert",
        "StaticBodies",
        "DynamicBodies",
        "Invalid"};

struct SelectionOptions
{
    enum ESelectionOptions
    {
        None = 1 << 0,
        All = 1 << 1,
        Invert = 1 << 2,
        StaticBodies = 1 << 3,
        DynamicBodies = 1 << 4,
        Invalid = 1 << 5
    };

    union
    {
        ESelectionOptions name;
        unsigned value;
    };

    SelectionOptions (ESelectionOptions name) :
        name (name) {}
    SelectionOptions (unsigned value) :
        value (value) {}
    SelectionOptions() :
        value (0) {}
    void clear() { value = 0; }
    operator ESelectionOptions() const { return name; }
    unsigned operator|= (SelectionOptions m) { return value |= m; }
    unsigned operator&= (SelectionOptions m) { return value &= m; }
    unsigned operator^= (SelectionOptions m) { return value ^= m; }

    std::string toString()
    {
        std::ostringstream ostr;
        ostr << "  SelectionOptions";

        if (value & All)
            ostr << "::All";

        if (value & None)
            ostr << "::None:";

        if (value & Invert)
            ostr << "::Invert:";

        if (value & StaticBodies)
            ostr << "::StaticBodies:";

        if (value & DynamicBodies)
            ostr << "::DynamicBodies:";

        if (value & Invalid)
            ostr << "::Invalid:";

        return ostr.str();
    }
};
</file>

<file path="scene/SpaceTime.cpp">
// This source file was auto-generated by ClassMate++
// Created: 16 Sep 2017 5:37:16 pm
// Copyright (c) 2017, HurleyWorks


// ctor
SpaceTime::SpaceTime()
{
	reset();
}

// reset
void SpaceTime::reset()
{
	birth = std::chrono::system_clock::now();

	startTransform.setIdentity();
	localTransform.setIdentity();
	worldTransform.setIdentity();
	previousWorldTransform.setIdentity();

	modelBound.setEmpty();
	worldBound.setEmpty();

	scale = Vector3f::Ones();
    startScale = scale;
	previousScale = scale;

	modeledOffset = Vector3f::Zero();
	centerOfVertexMass = modeledOffset;
}

// getLifeSpan
std::chrono::duration<double> SpaceTime::getLifeSpan()
{
	auto now = std::chrono::system_clock::now();
	return now - birth;
}

// updateWorldBounds
void SpaceTime::updateWorldBounds(bool includeScale)
{
	AlignedBox3f b = modelBound;
	if(includeScale)
	{ 
		for (int i = 0; i < 3; i++)
		{
			b.max()[i] *= scale[i];
			b.min()[i] *= scale[i];
		}
	}
	b.translate(worldTransform.translation());

	worldBound = b;
}

// updateLocalBounds
void SpaceTime::updateLocalBounds(bool includeScale)
{
	if (includeScale)
	{
		Vector3f min, max;
		for (int i = 0; i < 3; i++)
		{
			min[i] = modelBound.min()[i] * scale[i];
			max[i] = modelBound.max()[i] * scale[i];
		}

		modelBound.min() = localTransform.translation() + min;
		modelBound.max() = localTransform.translation() + max;

		return;
	}

	// we don't want to apply the rotation here since this is an AABB, right?
	modelBound.min() = localTransform.translation() + modelBound.min();
	modelBound.max() = localTransform.translation() + modelBound.max();
}

// is2D
bool SpaceTime::is2D() const
{
	Vector3f dimensions = modelBound.sizes();
	int dim = 0;
	for (int i = 0; i < 3; i++)
	{
		if (dimensions[i] >= std::numeric_limits<float>::epsilon())
		{
			++dim;
		}
	}
	return dim == 2;
}
</file>

<file path="scene/SpaceTime.h">
// This header file was auto-generated by ClassMate++
// Created: 16 Sep 2017 5:37:16 pm
// Copyright (c) 2017, HurleyWorks

#pragma once

using Eigen::Affine3f;
using Eigen::AlignedBox3f;
using Eigen::Vector3f;

class SpaceTime //: public SerializableT<SpaceTime>
{
 public:
    SpaceTime();
    ~SpaceTime() = default;

    void reset();

    Affine3f startTransform;
    Affine3f localTransform;
    Affine3f worldTransform;
    Affine3f previousWorldTransform;

    AlignedBox3f modelBound;
    AlignedBox3f worldBound;

    Vector3f scale;
    Vector3f startScale;
    Vector3f previousScale;

    Vector3f modeledOffset;
    Vector3f centerOfVertexMass;

    std::chrono::time_point<std::chrono::system_clock> birth;
    std::chrono::duration<double> getLifeSpan();

    // FIXME experiment
    std::vector<AnimationChannel> animation;

    bool is2D() const;
    bool hasModeledOffset() const { return modeledOffset.norm() > std::numeric_limits<float>::epsilon(); }
    void updateWorldBounds (bool includeScale = false);
    void updateLocalBounds (bool includeScale = false);
    void makeCurrentPoseStartPose() { startTransform = worldTransform; }
    void resetToStartPose() { worldTransform = startTransform; }
    void createDefaultModelBound()
    {
        // Create a cube centered at the origin with side length 1
        Vector3f halfExtent (0.5f, 0.5f, 0.5f);
        modelBound.min() = -halfExtent;
        modelBound.max() = halfExtent;
    }
    void debug()
    {
        mace::matStr4f (startTransform, DBUG, "Start transform");
        mace::matStr4f (localTransform, DBUG, "Local transform");
        mace::matStr4f (worldTransform, DBUG, "World transform");
        mace::matStr4f (previousWorldTransform, DBUG, "Previous world transform");

        mace::vecStr3f (scale, DBUG, "Scale");
        mace::vecStr3f (startScale, DBUG, "Start scale");
        mace::vecStr3f (previousScale, DBUG, "Previous scale");

        mace::vecStr3f (modelBound.min(), DBUG, "ModelBound min");
        mace::vecStr3f (modelBound.max(), DBUG, "ModelBound max");

        mace::vecStr3f (worldBound.min(), DBUG, "WorldBound min");
        mace::vecStr3f (worldBound.max(), DBUG, "WorlddBound max");

        mace::vecStr3f (modeledOffset, DBUG, "Modeled offset");
        mace::vecStr3f (centerOfVertexMass, DBUG, "Center of vertex mass");
    }

}; // end class SpaceTime
</file>

<file path="scene/WorldComposite.cpp">
using namespace sabi;

// dtor
WorldComposite::~WorldComposite()
{
    removeChildren();
}

void WorldComposite::addChild (RenderableNode node)
{
    if (node)
    {
        if (node && !hasChild (node))
        {
            // maybe remove node from current parent
            RenderableNode parent = node->getParent();
            if (parent)
                parent->removeChild (node);

            children.insert (std::make_pair (node->getID(), node));

            // set parent
            node->setParent (shared_from_this());
        }
        else
        {
            LOG (CRITICAL) << node->getName() << " is already in the scene";
        }
    }
    else
    {
        LOG (DBUG) << "FAILED TO ADD CHILD";
    }
}

RenderableNode WorldComposite::createClone (RenderableNode source)
{
    RenderableNode clone = WorldItem::create();

    clone->setDescription (source->description());
    clone->setSpacetime (source->getSpaceTime());
    clone->setModel (source->getModel());
    clone->setState (source->getState());

    return clone;
}

void WorldComposite::removeChild (RenderableNode node)
{
    auto it = children.find (node->getID());
    if (it != children.end())
    {
        RenderableNode node = it->second;

        // raise the deleteable flag
        node->getState().state |= PRenderableState::Deletable;

        // reset parent
        node->setParent (nullptr);

        children.erase (it);
    }
}

bool WorldComposite::hasChild (RenderableNode node) const
{
    auto it = children.find (node->getID());
    return it != children.end();
}

RenderableNode WorldComposite::findChild (ItemID itemID)
{
    auto it = children.find (itemID);
    return it == children.end() ? nullptr : it->second;
}

void WorldComposite::removeChildren()
{
    for (auto it : children)
    {
        RenderableNode node = it.second;
        if (!node) continue;

        // raise the deleteable flag
        node->getState().state |= PRenderableState::Deletable;

        // reset parent
        node->setParent (nullptr);

        node->debug (node->getName());
    }

    children.clear();

    // reset the unique id counter
    staticReset();
}
</file>

<file path="scene/WorldComposite.h">
// This header file was auto-generated by ClassMate++
// Created: 29 Dec 2018 1:52:03 pm
// Copyright (c) 2018, HurleyWorks

#pragma  once

class WorldComposite : public Renderable
{
	// a world composite has children who may 
	// be items or other composites

 public:
	static RenderableNode create() { return std::make_shared<WorldComposite>(); }

 public:
    WorldComposite() = default;
	~WorldComposite();

	void addChild(RenderableNode node) override;
	RenderableNode createClone (RenderableNode source) override;
	void removeChild(RenderableNode node) override;
	bool hasChild(RenderableNode node) const override;
	RenderableNode findChild(ItemID itemID) override;
	void removeChildren() override;

 private:
	

}; // end class WorldComposite
</file>

<file path="scene/WorldItem.cpp">
#include "WorldItem.h"


RenderableNode WorldItem::createInstance()
{
    RenderableNode instance = WorldItem::create();

    instance->setDescription (Renderable::description());
    instance->setSpacetime (Renderable::getSpaceTime());
    instance->setState (Renderable::getState());

    // instances have no mesh!
    instance->setModel(nullptr);
    instance->setInstancedFrom (getPtr());

    ++instanceCount;
    instance->setName (getName() + "_instance_" + std::to_string (instanceCount));

    return instance;
}

RenderableNode WorldItem::createPhysicsPhantom()
{
    RenderableNode phantom = WorldItem::create();

    phantom->setDescription (Renderable::description());
    phantom->setSpacetime (Renderable::getSpaceTime());
    phantom->setState (Renderable::getState());
    // phantoms can use their phantom from geometry
    phantom->setModel (nullptr);
    phantom->setPhantomFrom (getPtr());
    phantom->setName (getName() + "_phantom");

    return phantom;
}
</file>

<file path="scene/WorldItem.h">
#pragma once

#include "../../sabi_core.h"

using sabi::Renderable;
using sabi::RenderableData;
using sabi::RenderableNode;
using sabi::RenderableWeakRef;

class WorldItem : public Renderable
{
 public:
    static RenderableNode create() { return std::make_shared<WorldItem>(); }

 public:
    WorldItem() = default;
    ~WorldItem() = default;

    // geometry instances
    RenderableNode createInstance() override;
    bool isInstance() const override { return instancedFrom.lock() != nullptr; }
    void setInstancedFrom (RenderableNode node) override { instancedFrom = node; }
    RenderableNode getInstancedFrom() override { return instancedFrom.expired() ? nullptr : instancedFrom.lock(); }
    size_t getNumberOfInstances() const override { return instanceCount; }

    // physics phantom for collision free painting
    RenderableNode createPhysicsPhantom() override;
    void setPhantomFrom (RenderableNode node) override { phantomFrom = node; }
    RenderableNode getPhantomFrom() override { return phantomFrom.expired() ? nullptr : phantomFrom.lock(); }
    bool isPhantom() const override { return phantomFrom.lock() != nullptr; }

    RenderableNode getRestingOn() override { return restingOn.expired() ? nullptr : restingOn.lock(); }
    void setRestingOn (RenderableNode node) override { restingOn = node; }
   
    const RenderableData getData() const override
    {
        RenderableData d;
        d.clientID = clientID;
        d.sourceID = instancedFrom.expired() ? INVALID_ID : instancedFrom.lock()->getID();
        d.desc = desc;
        d.cgModel = cgModel;
        d.name = name;
        d.sceneID = id();
        d.spacetime = spacetime;
        d.state = state;
        const float* m = spacetime.worldTransform.matrix().data();
        for (int i = 0; i < 16; i++)
        {
            d.pose[i] = m[i];
        }
        return d;
    }

 private:
    RenderableWeakRef instancedFrom;
    size_t instanceCount = 0;

    RenderableWeakRef phantomFrom;

    RenderableWeakRef restingOn;
}; // end class WorldItem
</file>

<file path="tools/LoadStrategy.h">
#pragma once

using LoadStrategyPtr = std::shared_ptr<class LoadStrategy>;
using sabi::SpaceTime;

class LoadStrategy
{

 public:
	virtual ~LoadStrategy() {}

	LoadStrategy & operator=(const LoadStrategy&) = delete;
	LoadStrategy(const LoadStrategy&) = delete;

	virtual void addNextItem(SpaceTime& spacetime) = 0;
	virtual void reset() = 0;
    virtual void incrementCount() = 0;
		
 protected:
	 LoadStrategy() {}

}; // end class AbstractLoadStrategy
</file>

<file path="tools/MeshOps.cpp">
#include "MeshOps.h"

/*
    normal.cpp: Helper routines for computing vertex normals

    This file is part of the implementation of

        Instant Field-Aligned Meshes
        Wenzel Jakob, Daniele Panozzo, Marco Tarini, and Olga Sorkine-Hornung
        In ACM Transactions on Graphics (Proc. SIGGRAPH Asia 2015)

    All rights reserved. Use of this source code is governed by a
    BSD-style license that can be found in the LICENSE.txt file.
*/

#// Define constants for multi-threading and floating point operations
#define GRAIN_SIZE 1024
#if defined(_WIN32)
#define RCPOVERFLOW_FLT 2.93873587705571876e-39f
#define RCPOVERFLOW_DBL 5.56268464626800345e-309
#else
#define RCPOVERFLOW_FLT 0x1p-128f
#define RCPOVERFLOW_DBL 0x1p-1024
#endif

#if defined(SINGLE_PRECISION)
#define RCPOVERFLOW RCPOVERFLOW_FLT
#else
#define RCPOVERFLOW RCPOVERFLOW_DBL
#endif

using Eigen::Vector3f;
using sabi::SpaceTime;

constexpr float epsilon = 1e-6;

// Prepare mesh for flat shading by duplicating vertices at edges
// Prepare mesh for flat shading by duplicating vertices at edges
void MeshOps::prepareForFlatShading (CgModelPtr& model)
{
    MatrixXf originalV = model->V;
    MatrixXf newV;
    MatrixXf originalUV0;
    bool hasUVs = model->UV0.cols() > 0;

    if (hasUVs)
    {
        originalUV0 = model->UV0;
    }

    // Count total number of triangles across all surfaces
    size_t totalTriangles = 0;
    for (const auto& surface : model->S)
    {
        totalTriangles += surface.triangleCount();
    }

    // Each triangle will have its own unique vertices
    newV.resize (3, totalTriangles * 3);
    if (hasUVs)
    {
        model->UV0.resize (2, totalTriangles * 3);
    }

    size_t currentVertex = 0;

    // Process each surface
    for (auto& surface : model->S)
    {
        MatrixXu& F = surface.F;
        MatrixXu newSurfaceF;
        newSurfaceF.resize (3, F.cols());

        // For each triangle
        for (int i = 0; i < F.cols(); i++)
        {
            // Copy vertices and UVs
            for (int j = 0; j < 3; j++)
            {
                newV.col (currentVertex + j) = originalV.col (F (j, i));
                if (hasUVs)
                {
                    model->UV0.col (currentVertex + j) = originalUV0.col (F (j, i));
                }
                newSurfaceF (j, i) = currentVertex + j;
            }
            currentVertex += 3;
        }

        surface.F = newSurfaceF;
        surface.vertexCount = newSurfaceF.cols() * 3;
    }

    model->V = newV;
}
#if 0
// Prepare mesh for flat shading by duplicating vertices at edges
void MeshOps::prepareForFlatShading (CgModelPtr& model)
{
    MatrixXf originalV = model->V;
    MatrixXf newV;
    MatrixXu newF;

    // Count total number of triangles across all surfaces
    size_t totalTriangles = 0;
    for (const auto& surface : model->S)
    {
        totalTriangles += surface.triangleCount();
    }

    // Each triangle will have its own unique vertices
    newV.resize (3, totalTriangles * 3);

    size_t currentVertex = 0;

    // Process each surface
    for (auto& surface : model->S)
    {
        MatrixXu& F = surface.F;
        MatrixXu newSurfaceF;
        newSurfaceF.resize (3, F.cols());

        // For each triangle
        for (int i = 0; i < F.cols(); i++)
        {
            // Copy vertices
            for (int j = 0; j < 3; j++)
            {
                newV.col (currentVertex + j) = originalV.col (F (j, i));
                newSurfaceF (j, i) = currentVertex + j;
            }
            currentVertex += 3;
        }

        surface.F = newSurfaceF;
        surface.vertexCount = newSurfaceF.cols() * 3;
    }

    model->V = newV;
}
#endif
// Generates vertex and face normals for a mesh
// If flatShaded is true, assigns face normals to vertices instead of computing smooth vertex normals
// Generates vertex and face normals for a mesh
// If flatShaded is true, duplicates vertices at shared edges to achieve flat shading
void MeshOps::generate_normals (const MatrixXu& F, const MatrixXf& V, MatrixXf& N, MatrixXf& FN,
                                bool deterministic, bool flatShaded)
{
    std::atomic<uint32_t> badFaces (0);

    N.resize (V.rows(), V.cols());
    N.setZero();

    FN.resize (F.rows(), F.cols());
    FN.setZero();

    BS::thread_pool pool;

    // First compute face normals
    auto computeFaceNormals = [&] (const uint32_t start, const uint32_t end)
    {
        for (uint32_t f = start; f < end; ++f)
        {
            Vector3f v0 = V.col (F (0, f));
            Vector3f v1 = V.col (F (1, f));
            Vector3f v2 = V.col (F (2, f));

            Vector3f d0 = v1 - v0;
            Vector3f d1 = v2 - v0;
            Vector3f fn = d0.cross (d1);

            Float norm = fn.norm();
            if (norm < RCPOVERFLOW)
            {
                badFaces++;
                continue;
            }

            fn /= norm;
            FN.col (f) = fn;

            if (flatShaded)
            {
                // For flat shading, assign the exact same face normal to all vertices
                // This ensures no normal interpolation across face boundaries
                N.col (F (0, f)) = fn;
                N.col (F (1, f)) = fn;
                N.col (F (2, f)) = fn;
            }
        }
    };

    pool.detach_blocks (0u, (uint32_t)F.cols(), computeFaceNormals, GRAIN_SIZE);
    pool.wait();

    if (!flatShaded)
    {
        // Clear vertex normals before computing smooth normals
        N.setZero();

        // Standard angle-weighted vertex normal computation for smooth shading
        auto computeSmoothNormals = [&] (const uint32_t start, const uint32_t end)
        {
            for (uint32_t f = start; f < end; ++f)
            {
                for (int i = 0; i < 3; ++i)
                {
                    Vector3f d0 = V.col (F ((i + 1) % 3, f)) - V.col (F (i, f));
                    Vector3f d1 = V.col (F ((i + 2) % 3, f)) - V.col (F (i, f));
                    Float angle = wabi::fast_acos (d0.dot (d1) / std::sqrt (d0.squaredNorm() * d1.squaredNorm()));
                    Vector3f fn = FN.col (f) * angle;

                    for (uint32_t k = 0; k < 3; ++k)
                    {
                        mace::atomicAdd (&N.coeffRef (k, F (i, f)), fn[k]);
                    }
                }
            }
        };

        pool.detach_blocks (0u, (uint32_t)F.cols(), computeSmoothNormals, GRAIN_SIZE);
        pool.wait();

        // Normalize smooth vertex normals
        auto normalizeNormals = [&] (const uint32_t start, const uint32_t end)
        {
            for (uint32_t i = start; i < end; ++i)
            {
                Float norm = N.col (i).norm();
                if (norm < RCPOVERFLOW)
                {
                    N.col (i) = Vector3f::UnitX();
                }
                else
                {
                    N.col (i) /= norm;
                }
            }
        };

        pool.detach_blocks (0u, (uint32_t)V.cols(), normalizeNormals);
        pool.wait();
    }
}
#if 0

void MeshOps::generate_normals (const MatrixXu& F, const MatrixXf& V, MatrixXf& N, MatrixXf& FN, bool deterministic, bool flatShaded)
{
    // ScopedStopWatch sw("GENERATE NORMALS"); // Start timer

    std::atomic<uint32_t> badFaces (0); // Counter for degenerate faces

    N.resize (V.rows(), V.cols()); // Prepare vertex normal matrix
    N.setZero();

    FN.resize (F.rows(), F.cols()); // Prepare face normal matrix
    FN.setZero();

    BS::thread_pool pool; // Initialize thread pool

    // Multi-threaded computation of face and vertex normals
    auto map = [&] (const uint32_t start, const uint32_t end)
    {
        for (uint32_t f = start; f < end; ++f)
        {
            Vector3f fn = Vector3f::Zero();
            for (int i = 0; i < 3; ++i)
            {
                Vector3f v0 = V.col (F (i, f)),
                         v1 = V.col (F ((i + 1) % 3, f)),
                         v2 = V.col (F ((i + 2) % 3, f)),
                         d0 = v1 - v0,
                         d1 = v2 - v0;

                if (i == 0)
                {
                    fn = d0.cross (d1);
                    Float norm = fn.norm();
                    if (norm < RCPOVERFLOW)
                    {
                        badFaces++;
                        break;
                    }
                    FN.col (f) = fn.normalized();
                    fn /= norm;
                }

                Float angle = wabi::fast_acos (d0.dot (d1) / std::sqrt (d0.squaredNorm() * d1.squaredNorm()));
                for (uint32_t k = 0; k < 3; ++k)
                    mace::atomicAdd (&N.coeffRef (k, F (i, f)), fn[k] * angle);
            }
        }
    };

    pool.detach_blocks (0u, (uint32_t)F.cols(), map, GRAIN_SIZE); // Execute in parallel

    // must wait here because the normalize task depends on this task being completed
    pool.wait();

    // Normalize the vertex normals
    pool.detach_blocks (0u, (uint32_t)V.cols(),
                        [&] (const uint32_t start, const uint32_t end)
                        {
                            for (uint32_t i = start; i < end; ++i)
                            {
                                Float norm = N.col (i).norm();
                                if (norm < RCPOVERFLOW)
                                {
                                    N.col (i) = Vector3f::UnitX();
                                }
                                else
                                {
                                    N.col (i) /= norm;
                                }
                            }
                        });

    pool.wait();
}
#endif

void MeshOps::generate_normals (CgModelPtr& cgModel, bool flatShaded)
{
    if (flatShaded)
    {
        // First unweld vertices so each face has unique vertices
        prepareForFlatShading (cgModel);
    }

    MatrixXu allIndices;
    cgModel->getAllSurfaceIndices (allIndices);
    MeshOps::generate_normals (allIndices, cgModel->V, cgModel->N, cgModel->FN, false, flatShaded);
}

void MeshOps::processCgModel (RenderableNode& node, MeshOptions meshOptions, LoadStrategyPtr loadStrategy)
{
    CgModelPtr model = node->getModel();
    if (!model)
    {
        LOG (CRITICAL) << "Node does not have a cgModel";
        return;
    }

    SpaceTime& spacetime = node->getSpaceTime();

    AlignedBox3f modelBound;
    modelBound.min() = model->V.rowwise().minCoeff();
    modelBound.max() = model->V.rowwise().maxCoeff();
    float scale = 1.0f;

    if (modelBound.isEmpty())
        throw std::runtime_error ("Empty bounding box detected for " + node->getName());

    // this might change scale!
    if ((meshOptions & MeshOptions::NormalizeSize) == MeshOptions::NormalizeSize)
        MeshOps::normalizeSize (model, modelBound, scale);

    if ((meshOptions & MeshOptions::CenterVertices) == MeshOptions::CenterVertices)
        MeshOps::centerVertices (model, modelBound, scale);

    // recalc new modelBound
    modelBound.min() = model->V.rowwise().minCoeff();
    modelBound.max() = model->V.rowwise().maxCoeff();
    spacetime.modelBound = modelBound;

    if ((meshOptions & MeshOptions::LoadStrategy) == MeshOptions::LoadStrategy)
        loadStrategy->addNextItem (spacetime);

    spacetime.updateWorldBounds (true);

    if ((meshOptions & MeshOptions::RestOnGround) == MeshOptions::RestOnGround)
        spacetime.worldTransform.translation().y() = -spacetime.worldBound.min().y();

    spacetime.updateWorldBounds (true);
    spacetime.startTransform = spacetime.worldTransform;

    // create vertex normals and face normals  if they aren't there
    if (!model->N.cols() || !model->FN.cols())
    {
        MatrixXu allIndices;
        model->getAllSurfaceIndices (allIndices);
        MeshOps::generate_normals (allIndices, model->V, model->N, model->FN, false);
    }

    if (!model->isValid())
        throw std::runtime_error ("Invalid model");
}

void MeshOps::unweldMesh (CgModelPtr& model)
{
    // model->triangleCount might need to be computed
    MatrixXu allTris;
    if (!model->triangleCount())
    {
        model->getAllSurfaceIndices (allTris);
    }

    MatrixXf newVertices;

    // unwelded vertex count is 3 * total number of triangles
    newVertices.resize (3, model->triangleCount() * 3);

    // add all vertices in each triangle to unwlded vertics array VU
    uint32_t nextVertexIndex = 0;
    for (auto& s : model->S)
    {
        uint32_t triCount = s.triangleCount();
        MatrixXu& tris = s.indices();

        MatrixXu newTris;
        newTris.resize (3, triCount);

        for (int i = 0; i < triCount; i++)
        {
            Vector3u tri = tris.col (i);

            // get the 3 vertex positions for this tri
            const Vector3f& p0 = model->V.col (tri.x());
            const Vector3f& p1 = model->V.col (tri.y());
            const Vector3f& p2 = model->V.col (tri.z());

            // add this tris 3 vertices to
            // the new vertex array and make
            // a new triangle
            Vector3u newTri;

            newTri.x() = nextVertexIndex;
            newVertices.col (nextVertexIndex++) = p0;

            newTri.y() = nextVertexIndex;
            newVertices.col (nextVertexIndex++) = p1;

            newTri.z() = nextVertexIndex;
            newVertices.col (nextVertexIndex++) = p2;

            newTris.col (i) = newTri;
        }

        tris = newTris;

        // set this or the renderer will crash FIXME
        s.vertexCount = newVertices.cols();
    }

    model->V = newVertices;
}

void MeshOps::centerVertices (CgModelPtr model, const AlignedBox3f& modelBound, float scale)
{
    int pointCount = model->V.cols();
    Vector3f center = modelBound.center();
    for (int i = 0; i < pointCount; i++)
    {
        Vector3f pnt = model->V.col (i);
        pnt -= center;
        pnt *= scale;
        model->V.col (i) = pnt;
    }
}

void MeshOps::normalizeSize (CgModelPtr model, const AlignedBox3f& modelBound, float& scale)
{
    Eigen::Vector3f edges = modelBound.max() - modelBound.min();
    float maxEdge = std::max (edges.x(), std::max (edges.y(), edges.z()));
    scale = 1.0f / maxEdge; // max
}

void MeshOps::resizeModel (CgModelPtr model, const Eigen::Vector3f& targetSize)
{
    // Calculate the current bounding box of the model
    Eigen::AlignedBox3f modelBound;
    modelBound.min() = model->V.rowwise().minCoeff();
    modelBound.max() = model->V.rowwise().maxCoeff();

    // Calculate the current size of the model
    Eigen::Vector3f currentSize = modelBound.max() - modelBound.min();

    // Identify degenerate dimensions (within an epsilon)

    bool isXDegenerate = currentSize.x() < epsilon;
    bool isYDegenerate = currentSize.y() < epsilon;
    bool isZDegenerate = currentSize.z() < epsilon;

    // Calculate scale factors for each non-degenerate dimension
    Eigen::Vector3f scaleFactor (1.0, 1.0, 1.0); // Initialize to 1.0 for no scaling effect by default
    if (!isXDegenerate) scaleFactor.x() = targetSize.x() / currentSize.x();
    if (!isYDegenerate) scaleFactor.y() = targetSize.y() / currentSize.y();
    if (!isZDegenerate) scaleFactor.z() = targetSize.z() / currentSize.z();

    // Apply scaling to each vertex
    for (int i = 0; i < model->V.cols(); ++i)
    {
        Eigen::Vector3f p = model->V.col (i);
        p.x() *= scaleFactor.x();
        p.y() *= scaleFactor.y();
        p.z() *= scaleFactor.z();
        model->V.col (i) = p;
    }
}

CgModelPtr MeshOps::createTexturedTriangle (const fs::path& pngImagePath)
{
    CgModelPtr triangle = CgModel::create();

    // Define the vertices of the triangle to match redTri.lwo
    triangle->V.resize (3, 3);
    triangle->V.col (0) = Eigen::Vector3f (0, 1, 0);   // (0.0, 1.0, 0.0)
    triangle->V.col (1) = Eigen::Vector3f (1, -1, 0);  // (1.0, -1.0, 0.0)
    triangle->V.col (2) = Eigen::Vector3f (-1, -1, 0); // (-1.0, -1.0, 0.0)

    // Create a single surface for the triangle
    triangle->S.resize (1);
    auto& surface = triangle->S[0];
    surface.name = "FRED";

    // Set up indices for this face
    surface.F.resize (3, 1);
    surface.F (0, 0) = 0;
    surface.F (1, 0) = 1;
    surface.F (2, 0) = 2;

    // Set up the material properties using CgMaterial
    auto& material = surface.cgMaterial;
    material.name = "Textured_Material";
    material.core.baseColor = Vector3f (1.0f, 1.0f, 1.0f); // White color (will be multiplied with texture)
    material.metallic.metallic = 0.0f;
    material.core.roughness = 0.5f;

    // Create and set up the sampler
    CgSampler sampler;
    sampler.magFilter = CgFilter::Linear;             // 9729
    sampler.minFilter = CgFilter::LinearMipMapLinear; // 9987
    sampler.wrapS = CgWrap::Repeat;                   // 10497
    sampler.wrapT = CgWrap::Repeat;                   // 10497
    triangle->cgSamplers.push_back (sampler);

    // Create and set up the texture
    CgTexture texture;
    texture.imageIndex = triangle->cgImages.size(); // Index of the image we're about to add
    triangle->cgTextures.push_back (texture);

    // Create and set up the image
    CgImage image;
    image.uri = pngImagePath.generic_string(); // Replace with actual texture path
    image.mimeType = "image/png";              // Adjust based on your image type
    triangle->cgImages.push_back (image);

    // Set the base color texture
    CgTextureInfo textureInfo;
    textureInfo.textureIndex = triangle->cgTextures.size() - 1; // Index of the texture we just added
    textureInfo.texCoordIndex = 0;                              // Use the first set of texture coordinates (UV0)
    material.core.baseColorTexture = textureInfo;

    surface.vertexCount = 3;

    // Update the total triangle count
    triangle->triCount = 1;

    // Create vertex normals (flat normal for simplicity)
    triangle->N.resize (3, 3);
    Eigen::Vector3f edge1 = triangle->V.col (1) - triangle->V.col (0);
    Eigen::Vector3f edge2 = triangle->V.col (2) - triangle->V.col (0);
    Eigen::Vector3f normal = edge1.cross (edge2).normalized();
    triangle->N.col (0) = normal;
    triangle->N.col (1) = normal;
    triangle->N.col (2) = normal;

    // Add UV coordinates matching LightWave's exact UV values
    triangle->UV0.resize (2, 3);
    triangle->UV0.col (0) = Eigen::Vector2f (0.5f, 1.0f); // Top vertex
    triangle->UV0.col (1) = Eigen::Vector2f (1.0f, 0.0f); // Right vertex
    triangle->UV0.col (2) = Eigen::Vector2f (0.0f, 0.0f); // Left vertex

    LOG (DBUG) << "Created a single triangle with a textured surface";
    return triangle;
}

#if 0
CgModelPtr MeshOps::createTexturedTriangle (const fs::path& pngImagePath)
{
    CgModelPtr triangle = CgModel::create();
    // Define the vertices of the triangle to match redTri.lwo
    triangle->V.resize (3, 3);
    triangle->V.col (0) = Eigen::Vector3f (0, 1, 0);   // (0.0, 1.0, 0.0)
    triangle->V.col (1) = Eigen::Vector3f (1, -1, 0);  // (1.0, -1.0, 0.0)
    triangle->V.col (2) = Eigen::Vector3f (-1, -1, 0); // (-1.0, -1.0, 0.0)

    // Create a single surface for the triangle
    triangle->S.resize (1);
    auto& surface = triangle->S[0];
    surface.name = "FRED";

    // Set up indices for this face
    surface.F.resize (3, 1);
    surface.F (0, 0) = 0;
    surface.F (1, 0) = 1;
    surface.F (2, 0) = 2;

    // Set up the material properties
    surface.material.name = "Textured_Material";
    surface.material.pbrMetallicRoughness.baseColorFactor = {1.0f, 1.0f, 1.0f, 1.0f}; // White color (will be multiplied with texture)
    surface.material.pbrMetallicRoughness.metallicFactor = 0.0f;
    surface.material.pbrMetallicRoughness.roughnessFactor = 0.5f;

    // Create and set up the sampler
    Sampler sampler;
    sampler.magFilter = 9729; // GL_LINEAR
    sampler.minFilter = 9987; // GL_LINEAR_MIPMAP_LINEAR
    sampler.wrapS = 10497;    // GL_REPEAT
    sampler.wrapT = 10497;    // GL_REPEAT
    triangle->samplers.push_back (sampler);

    // Create and set up the texture
    Texture texture;
    texture.source = triangle->images.size(); // Index of the image we're about to add
    triangle->textures.push_back (texture);

    // Create and set up the image
    Image image;
    image.uri = pngImagePath.generic_string(); // Replace with actual texture path
    image.mimeType = "image/png";              // Adjust based on your image type
    triangle->images.push_back (image);

    // Set the base color texture
    TextureInfo textureInfo;
    textureInfo.textureIndex = triangle->textures.size() - 1; // Index of the texture we just added
    textureInfo.texCoord = 0;                                 // Use the first set of texture coordinates (UV0)
    surface.material.pbrMetallicRoughness.baseColorTexture = textureInfo;

    surface.vertexCount = 3;
    // Update the total triangle count
    triangle->triCount = 1;

    // Create vertex normals (flat normal for simplicity)
    triangle->N.resize (3, 3);
    Eigen::Vector3f edge1 = triangle->V.col (1) - triangle->V.col (0);
    Eigen::Vector3f edge2 = triangle->V.col (2) - triangle->V.col (0);
    Eigen::Vector3f normal = edge1.cross (edge2).normalized();
    triangle->N.col (0) = normal;
    triangle->N.col (1) = normal;
    triangle->N.col (2) = normal;

    // Add UV coordinates matching LightWave's exact UV values
    triangle->UV0.resize (2, 3);
    triangle->UV0.col (0) = Eigen::Vector2f (0.5f, 1.0f); // Top vertex
    triangle->UV0.col (1) = Eigen::Vector2f (1.0f, 0.0f); // Right vertex
    triangle->UV0.col (2) = Eigen::Vector2f (0.0f, 0.0f); // Left vertex

    LOG (DBUG) << "Created a single triangle with a textured surface";
    return triangle;
}
#endif
CgModelPtr MeshOps::createTriangle()
{
    CgModelPtr triangle = CgModel::create();

    // Define the vertices of the triangle to match redTri.lwo
    triangle->V.resize (3, 3);
    triangle->V.col (0) = Eigen::Vector3f (-1, -1, 0); // (-1.0, -1.0, 0.0)
    triangle->V.col (1) = Eigen::Vector3f (0, 1, 0);   // (0.0, 1.0, 0.0)
    triangle->V.col (2) = Eigen::Vector3f (1, -1, 0);  // (1.0, -1.0, 0.0)

    // Create a single surface for the triangle
    triangle->S.resize (1);

    auto& surface = triangle->S[0];
    surface.name = "Triangle_Face";

    // Set up indices for this face
    surface.F.resize (3, 1);
    surface.F (0, 0) = 1;
    surface.F (1, 0) = 2;
    surface.F (2, 0) = 0;

    // Set up the material properties
    surface.material.name = "Blue_Material";
    surface.material.pbrMetallicRoughness.baseColorFactor = {0.0f, 0.0f, 1.0f, 1.0f}; // blue color
    surface.material.pbrMetallicRoughness.metallicFactor = 0.0f;
    surface.material.pbrMetallicRoughness.roughnessFactor = 0.0f;

    surface.vertexCount = 3;

    // Update the total triangle count
    triangle->triCount = 1;

    // Create vertex normals (flat normal for simplicity)
    triangle->N.resize (3, 3);
    Eigen::Vector3f edge1 = triangle->V.col (1) - triangle->V.col (0);
    Eigen::Vector3f edge2 = triangle->V.col (2) - triangle->V.col (0);
    Eigen::Vector3f normal = edge1.cross (edge2).normalized();
    triangle->N.col (0) = normal;
    triangle->N.col (1) = normal;
    triangle->N.col (2) = normal;

    // Add UV coordinates (simple planar mapping)
    triangle->UV0.resize (2, 3);
    triangle->UV0.col (0) = Eigen::Vector2f (0, 0);
    triangle->UV0.col (1) = Eigen::Vector2f (1, 0);
    triangle->UV0.col (2) = Eigen::Vector2f (0.5f, 1);

    // LOG (DBUG) << "Created a single triangle with a red surface";

    return triangle;
}

// Creates a cube with vertices and normals matching LightWave's internal format
// Creates a cube with vertices and normals matching LightWave's internal format
// Creates a cube with vertices and normals matching LightWave's format
CgModelPtr MeshOps::createCube (float size)
{
    auto model = CgModel::create();
    const float s = size * 0.5f;

    // Define vertices in exact LightWave point order (0-based indices)
    model->V.resize (3, 8);
    model->V.col (0) = Vector3f (-s, -s, -s); // Back bottom left
    model->V.col (1) = Vector3f (-s, -s, s);  // Front bottom left
    model->V.col (2) = Vector3f (-s, s, -s);  // Back top left
    model->V.col (3) = Vector3f (-s, s, s);   // Front top left
    model->V.col (4) = Vector3f (s, -s, -s);  // Back bottom right
    model->V.col (5) = Vector3f (s, -s, s);   // Front bottom right
    model->V.col (6) = Vector3f (s, s, -s);   // Back top right
    model->V.col (7) = Vector3f (s, s, s);    // Front top right

    // Set normals
    model->N.resize (3, 8);
    for (int i = 0; i < 8; i++)
    {
        model->N.col (i) = -model->V.col (i).normalized();
    }

    // Create surface with triangles
    CgModelSurface surface;
    surface.F.resize (3, 12);

    // Define faces using the corrected vertex order
    int faces[12][3] = {
        {0, 1, 3}, {0, 3, 2}, // First two triangles from hex dump
        {1, 5, 7},
        {1, 7, 3}, // Next two triangles
        {5, 4, 6},
        {5, 6, 7}, // And so on...
        {4, 0, 2},
        {4, 2, 6},
        {2, 3, 7},
        {2, 7, 6},
        {1, 0, 4},
        {1, 4, 5}};

    for (int i = 0; i < 12; i++)
    {
        surface.F.col (i) = Vector3u (faces[i][0], faces[i][1], faces[i][2]);
    }

    model->S.push_back (surface);
    return model;
}

#if 0
CgModelPtr MeshOps::createCube()
{
    CgModelPtr cube = CgModel::create();

    // Define the vertices of the cube (shared vertices for adjacent faces)
    cube->V.resize (3, 8);
    cube->V << -.5, -.5, -.5, -.5, .5, .5, .5, .5,
        -.5, -.5, .5, .5, -.5, -.5, .5, .5,
        -.5, .5, -.5, .5, -.5, .5, -.5, .5;

    // Create 6 surfaces, one for each face of the cube
    cube->S.resize (6);

    // Define the indices for each face (now using triangles)
#if 0
    std::vector<std::vector<unsigned int>> faceIndices = {
        {0, 1, 2, 2, 1, 3}, // Front face
        {4, 6, 5, 5, 6, 7}, // Back face
        {0, 4, 1, 1, 4, 5}, // Left face
        {2, 3, 6, 6, 3, 7}, // Right face
        {0, 2, 4, 4, 2, 6}, // Bottom face
        {1, 5, 3, 3, 5, 7}  // Top face
    };
#endif
    std::vector<std::vector<unsigned int>> faceIndices = {
        {0, 1, 3, 1, 2, 3}, // Directly copied from LW's hex dump
        {4, 5, 6, 5, 7, 6}, // Directly copied from LW's hex dump
        {0, 1, 4, 1, 5, 4}, // Directly copied from LW's hex dump
        {2, 3, 6, 3, 7, 6}, // Directly copied from LW's hex dump
        {4, 0, 3, 3, 7, 4}, // Directly copied from LW's hex dump
        {5, 4, 7, 4, 6, 7}  // Directly copied from LW's hex dump
    };
    // Define colors for each face
    std::vector<std::array<float, 4>> colors = {
        {1.0f, 0.0f, 0.0f, 1.0f}, // Red
        {0.0f, 1.0f, 0.0f, 1.0f}, // Green
        {0.0f, 0.0f, 1.0f, 1.0f}, // Blue
        {1.0f, 1.0f, 0.0f, 1.0f}, // Yellow
        {1.0f, 0.0f, 1.0f, 1.0f}, // Magenta
        {0.0f, 1.0f, 1.0f, 1.0f}  // Cyan
    };

    for (int i = 0; i < 6; ++i)
    {
        auto& surface = cube->S[i];
        surface.name = "Face_" + std::to_string (i+1);

        // Set up indices for this face
        surface.F.resize (3, 2);
        for (int j = 0; j < 2; ++j)
        {
            surface.F.col (j) << faceIndices[i][j * 3], faceIndices[i][j * 3 + 1], faceIndices[i][j * 3 + 2];
        }

        surface.material.name = "Material_" + std::to_string (i);
        surface.material.pbrMetallicRoughness.baseColorFactor = colors[i];
        surface.material.pbrMetallicRoughness.metallicFactor = 0.0f;
        surface.material.pbrMetallicRoughness.roughnessFactor = 0.5f;

        surface.vertexCount = 4;
    }

    // Update the total triangle count
    cube->triCount = 12; // 2 triangles per face, 6 faces

    // Create vertex normals (not averaged, for simplicity)
    cube->N = cube->V.colwise().normalized();

    // Add UV coordinates (simple planar mapping for each face)
    //cube->UV0.resize (2, 24); // 4 vertices per face, 6 faces
    //for (int i = 0; i < 6; ++i)
    //{
    //    cube->UV0.col (i * 4 + 0) << 0, 0;
    //    cube->UV0.col (i * 4 + 1) << 1, 0;
    //    cube->UV0.col (i * 4 + 2) << 0, 1;
    //    cube->UV0.col (i * 4 + 3) << 1, 1;
    //}

    LOG (DBUG) << "Created a cube with 6 surfaces using shared vertices and triangles";

    return cube;
}
#endif
CgModelPtr MeshOps::createTexturedQuad (const fs::path& pngImagePath)
{
    CgModelPtr quad = CgModel::create();

    // Define the vertices of the quad (2 triangles)
    quad->V.resize (3, 4);
    quad->V.col (0) = Eigen::Vector3f (-1, -1, 0); // Bottom-left
    quad->V.col (1) = Eigen::Vector3f (1, -1, 0);  // Bottom-right
    quad->V.col (2) = Eigen::Vector3f (1, 1, 0);   // Top-right
    quad->V.col (3) = Eigen::Vector3f (-1, 1, 0);  // Top-left

    // Create a single surface for the quad
    quad->S.resize (1);
    auto& surface = quad->S[0];
    surface.name = "Quad_Face";

    // Set up indices for the two triangles
    surface.F.resize (3, 2);
    surface.F.col (0) << 0, 1, 2; // First triangle
    surface.F.col (1) << 0, 2, 3; // Second triangle

    // Set up the material properties
    surface.material.name = "Textured_Material";
    surface.material.pbrMetallicRoughness.baseColorFactor = {1.0f, 1.0f, 1.0f, 1.0f}; // White color (will be multiplied with texture)
    surface.material.pbrMetallicRoughness.metallicFactor = 0.0f;
    surface.material.pbrMetallicRoughness.roughnessFactor = 0.5f;

    // Create and set up the sampler
    Sampler sampler;
    sampler.magFilter = 9729; // GL_LINEAR
    sampler.minFilter = 9987; // GL_LINEAR_MIPMAP_LINEAR
    sampler.wrapS = 10497;    // GL_REPEAT
    sampler.wrapT = 10497;    // GL_REPEAT
    quad->samplers.push_back (sampler);

    // Create and set up the texture
    Texture texture;
    texture.source = quad->images.size();        // Index of the image we're about to add
    texture.sampler = quad->samplers.size() - 1; // Index of the sampler we just added
    quad->textures.push_back (texture);

    // Create and set up the image
    Image image;
    image.uri = pngImagePath.string();
    image.mimeType = "image/png";
    quad->images.push_back (image);

    // Set the base color texture
    TextureInfo textureInfo;
    textureInfo.textureIndex = quad->textures.size() - 1; // Index of the texture we just added
    textureInfo.texCoord = 0;                             // Use the first set of texture coordinates (UV0)
    surface.material.pbrMetallicRoughness.baseColorTexture = textureInfo;

    surface.vertexCount = 4;

    // Update the total triangle count
    quad->triCount = 2;

    // Create vertex normals (flat normal for simplicity)
    quad->N.resize (3, 4);
    Eigen::Vector3f normal (0, 0, 1); // Facing positive Z direction
    quad->N.col (0) = normal;
    quad->N.col (1) = normal;
    quad->N.col (2) = normal;
    quad->N.col (3) = normal;

    quad->UV0.resize (2, 4);
    quad->UV0.col (0) = Eigen::Vector2f (0, 1); // Bottom-left
    quad->UV0.col (1) = Eigen::Vector2f (1, 1); // Bottom-right
    quad->UV0.col (2) = Eigen::Vector2f (1, 0); // Top-right
    quad->UV0.col (3) = Eigen::Vector2f (0, 0); // Top-left

    LOG (DBUG) << "Created a quad with a textured surface using image: " << pngImagePath.string();
    return quad;
}

void MeshOps::debugCgModel (const CgModelPtr& model, DebugFlags flags)
{
    if (!model)
    {
        LOG (WARNING) << "CgModel is null!";
        return;
    }

    LOG (INFO) << "Debugging CgModel:";

    // Vertices
    if ((flags & DebugFlags::Vertices) == DebugFlags::Vertices)
    {
        LOG (INFO) << "Vertices: " << model->V.cols();
        for (int i = 0; i < std::min (24, static_cast<int> (model->V.cols())); ++i)
        {
            LOG (INFO) << "  V" << i << ": (" << model->V (0, i) << ", " << model->V (1, i) << ", " << model->V (2, i) << ")";
        }
        if (model->V.cols() > 24) LOG (INFO) << "  ... (truncated)";
    }

    // Normals
    if ((flags & DebugFlags::Normals) == DebugFlags::Normals)
    {
        LOG (INFO) << "Normals: " << model->N.cols();
        for (int i = 0; i < std::min (24, static_cast<int> (model->N.cols())); ++i)
        {
            LOG (INFO) << "  N" << i << ": (" << model->N (0, i) << ", " << model->N (1, i) << ", " << model->N (2, i) << ")";
        }
        if (model->N.cols() > 24) LOG (INFO) << "  ... (truncated)";
    }

    // UVs
    if ((flags & DebugFlags::UVs) == DebugFlags::UVs)
    {
        LOG (INFO) << "UVs: " << model->UV0.cols();
        for (int i = 0; i < std::min (36, static_cast<int> (model->UV0.cols())); ++i)
        {
            LOG (INFO) << "  UV" << i << ": (" << model->UV0 (0, i) << ", " << model->UV0 (1, i) << ")";
        }
        if (model->UV0.cols() > 36) LOG (INFO) << "  ... (truncated)";
    }

    // Triangle Indices
    if ((flags & DebugFlags::Indices) == DebugFlags::Indices)
    {
        LOG (INFO) << "Triangle Indices:";
        for (size_t s = 0; s < model->S.size(); ++s)
        {
            const auto& surface = model->S[s];
            LOG (INFO) << "  Surface " << s << " indices:";
            for (int i = 0; i < std::min (24, static_cast<int> (surface.F.cols())); ++i)
            {
                const auto& tri = surface.F.col (i);
                LOG (INFO) << "    Triangle " << i << ": ("
                           << tri[0] << ", " << tri[1] << ", " << tri[2] << ")";
            }
            if (surface.F.cols() > 24) LOG (INFO) << "    ... (truncated)";
        }
    }

    // Surfaces and Materials
    if ((flags & DebugFlags::Surfaces) == DebugFlags::Surfaces)
    {
        LOG (INFO) << "Surfaces: " << model->S.size();
        for (size_t i = 0; i < model->S.size(); ++i)
        {
            const auto& surface = model->S[i];
            LOG (INFO) << "Surface " << i << "::" << surface.name << ":";
            LOG (INFO) << "  Triangles: " << surface.triangleCount();

            if ((flags & DebugFlags::Materials) == DebugFlags::Materials)
            {
                const auto& mat = surface.cgMaterial;
                LOG (INFO) << "  Material:";
                LOG (INFO) << "    Name: " << mat.name;
                LOG (INFO) << "    Base Color: "
                           << mat.core.baseColor.x() << ", "
                           << mat.core.baseColor.y() << ", "
                           << mat.core.baseColor.z();
                LOG (INFO) << "    Metallic: " << mat.metallic.metallic;
                LOG (INFO) << "    Roughness: " << mat.core.roughness;
                LOG (INFO) << "    Specular: " << mat.core.specular;
                LOG (INFO) << "    Thin Walled: " << (mat.transparency.thin ? "Yes" : "No");
                LOG (INFO) << "    Transparency: " << mat.transparency.transparency;
                LOG (INFO) << "    IOR: " << mat.transparency.refractionIndex;

                if (mat.core.baseColorTexture)
                {
                    LOG (INFO) << "    Base Color Texture Index: " << mat.core.baseColorTexture->textureIndex;
                }
            }
        }
    }

    // Textures
    if ((flags & DebugFlags::Textures) == DebugFlags::Textures)
    {
        LOG (INFO) << "Textures: " << model->cgTextures.size();
        for (size_t i = 0; i < model->cgTextures.size(); ++i)
        {
            const auto& texture = model->cgTextures[i];
            LOG (INFO) << "Texture " << i << ":";
            LOG (INFO) << "  Name: " << texture.name;
            if (texture.imageIndex)
                LOG (INFO) << "  Image Index: " << *texture.imageIndex;
            if (texture.samplerIndex)
                LOG (INFO) << "  Sampler Index: " << *texture.samplerIndex;
        }
    }

    // Images
    if ((flags & DebugFlags::Images) == DebugFlags::Images)
    {
        LOG (INFO) << "Images: " << model->cgImages.size();
        for (size_t i = 0; i < model->cgImages.size(); ++i)
        {
            const auto& image = model->cgImages[i];
            LOG (INFO) << "Image " << i << ":";
            LOG (INFO) << "  Name: " << image.name;
            LOG (INFO) << "  URI: " << image.uri;
            LOG (INFO) << "  MIME Type: " << image.mimeType;
            LOG (INFO) << "  Index: " << image.index;
        }
    }

    // Samplers
    if ((flags & DebugFlags::Samplers) == DebugFlags::Samplers)
    {
        LOG (INFO) << "Samplers: " << model->cgSamplers.size();
        for (size_t i = 0; i < model->cgSamplers.size(); ++i)
        {
            const auto& sampler = model->cgSamplers[i];
            LOG (INFO) << "Sampler " << i << ":";
            if (sampler.magFilter)
                LOG (INFO) << "  Mag Filter: " << static_cast<int> (*sampler.magFilter);
            if (sampler.minFilter)
                LOG (INFO) << "  Min Filter: " << static_cast<int> (*sampler.minFilter);
            LOG (INFO) << "  Wrap S: " << static_cast<int> (sampler.wrapS);
            LOG (INFO) << "  Wrap T: " << static_cast<int> (sampler.wrapT);
            LOG (INFO) << "  Name: " << sampler.name;
        }
    }
}

// Writes UV coordinates from a CgModel to a text file
// Returns true if successful, false if file couldn't be opened or model is invalid
bool MeshOps::dumpUVCoordinates (const CgModelPtr& model, const fs::path& outputPath)
{
    if (!model || model->UV0.cols() == 0)
    {
        LOG (WARNING) << "Invalid model or no UV coordinates present";
        return false;
    }

    std::ofstream outFile (outputPath);
    if (!outFile)
    {
        LOG (WARNING) << "Failed to open output file: " << outputPath;
        return false;
    }

    outFile << "Vertex Count: " << model->UV0.cols() << "\n\n";
    outFile << "Format: VertexIndex U V\n\n";

    for (int i = 0; i < model->UV0.cols(); ++i)
    {
        outFile << std::setw (6) << i << " "
                << std::setprecision (6) << std::fixed
                << std::setw (9) << model->UV0 (0, i) << " "
                << std::setw (9) << model->UV0 (1, i) << "\n";
    }

    // Write UV1 coordinates if they exist
    if (model->UV1.cols() > 0)
    {
        outFile << "\nSecondary UV Set (UV1):\n\n";
        for (int i = 0; i < model->UV1.cols(); ++i)
        {
            outFile << std::setw (6) << i << " "
                    << std::setprecision (6) << std::fixed
                    << std::setw (9) << model->UV1 (0, i) << " "
                    << std::setw (9) << model->UV1 (1, i) << "\n";
        }
    }

    return true;
}
</file>

<file path="tools/MeshOps.h">
#pragma once

#include "../../sabi_core.h"

using Eigen::AlignedBox3f;
using sabi::CgModelPtr;
using sabi::RenderableNode;
using sabi::LoadStrategyPtr;
using sabi::MeshOptions;
using sabi::RenderableNode;

// Define debug flags as an enum class for type safety
enum class DebugFlags
{
    None = 0,
    Vertices = 1 << 0,
    Indices = 1 << 1, 
    Normals = 1 << 2,
    UVs = 1 << 3,
    Surfaces = 1 << 4,
    Materials = 1 << 5,
    Textures = 1 << 6,
    Images = 1 << 7,
    Samplers = 1 << 8,
    All = Vertices | Indices | Normals | UVs | Surfaces | Materials | Textures | Images | Samplers
};

// Enable bitwise operations for DebugFlags
inline DebugFlags operator| (DebugFlags a, DebugFlags b)
{
    return static_cast<DebugFlags> (static_cast<uint32_t> (a) | static_cast<uint32_t> (b));
}

inline DebugFlags operator& (DebugFlags a, DebugFlags b)
{
    return static_cast<DebugFlags> (static_cast<uint32_t> (a) & static_cast<uint32_t> (b));
}

struct MeshOps
{
    static void unweldMesh(CgModelPtr& model);
    static void centerVertices (CgModelPtr model, const AlignedBox3f& modelBound, float scale);
    static void normalizeSize (CgModelPtr model, const AlignedBox3f& modelBound, float& scale);
    static void resizeModel (CgModelPtr model, const Eigen::Vector3f& targetSize);
    static void generate_normals (const MatrixXu& F, const MatrixXf& V, MatrixXf& N, MatrixXf& FN,
                                  bool deterministic, bool flatShaded = false);
    static void generate_normals (CgModelPtr& cgModel, bool flatShaded = false);
    static void prepareForFlatShading (CgModelPtr& model);
    static void processCgModel(RenderableNode& node, MeshOptions meshOptions, LoadStrategyPtr loadStrategy = nullptr);
    static CgModelPtr createTriangle();
    static CgModelPtr createTexturedTriangle (const fs::path& pngImagePath);
    static CgModelPtr createCube(float size = 1.0f);
    static CgModelPtr createTexturedQuad (const fs::path& pngImagePath);
    static void debugCgModel (const CgModelPtr& model, DebugFlags flags = DebugFlags::All);
    static bool dumpUVCoordinates (const CgModelPtr& model, const fs::path& outputPath);
};
</file>

<file path="tools/NormalizedClump.cpp">
// This source file was auto-generated by ClassMate++
// Created: 23 Jan 2018 7:09:22 pm
// Copyright (c) 2018, HurleyWorks

// ctor
NormalizedClump::NormalizedClump() :
    LoadStrategy()
{
}

// dtor
NormalizedClump::~NormalizedClump()
{
}

// addNextItem
void NormalizedClump::addNextItem (SpaceTime& spacetime)
{
    // place the next obj without intersecting any others
    // as long as their size has been normalized
    Vector3f v;
    float d = 1.618f;
    computeNextSpot (objIndex++, d, v);

    // mace::vecStr3f (v, DBUG, "SPOT");

    spacetime.worldTransform.translation() = v;
    spacetime.previousWorldTransform = spacetime.worldTransform;
}

// computeNextSpot
void NormalizedClump::computeNextSpot (int index, float density, Vector3f& spot)
{
    // from the Worley man
    double r = std::sqrt (index) / density;

    // The magic phi angle of about 137.5 degrees, in radians
    // http://cosmometry.net/phi-rotation-angles
    double theta = index * 3.8832220774509331547;
    double x = r * std::sin (theta);
    double z = r * std::cos (theta);

    spot[0] = (float)x;
    spot[1] = 0.0f;
    spot[2] = (float)z;
}
</file>

<file path="tools/NormalizedClump.h">
// This header file was auto-generated by ClassMate++
// Created: 23 Jan 2018 7:09:22 pm
// Copyright (c) 2018, HurleyWorks

#pragma once

using Eigen::Vector3f;

class NormalizedClump : public LoadStrategy
{

 public:
	NormalizedClump ();
	~NormalizedClump();
		
	void addNextItem(SpaceTime & spacetime) override;
	void reset() override
	{
		objIndex = 1;
	}
    void incrementCount() override
    {
        ++objIndex;
	}
 private:
	int objIndex = 1;

	void computeNextSpot(int index, float density, Vector3f & spot);

}; // end class NormalizedClump
</file>

<file path="tools/RadialFlower.h">
class RadialFlower : public LoadStrategy
{
 public:
    RadialFlower (int numPetals, float radius) :
        numPetals (numPetals), radius (radius), currentIndex (0)
    {
        setupPattern();
    }

    void addNextItem (SpaceTime& spacetime) override
    {
        if (currentIndex < positions.size())
        {
            spacetime.worldTransform.translation() = positions[currentIndex];
            currentIndex++;
        }
    }

    void reset() override
    {
        currentIndex = 0;
    }

    void incrementCount() override
    {
        // This method is not used in this strategy
    }

 private:
    int numPetals;
    float radius;
    int currentIndex;
    std::vector<Eigen::Vector3f> positions;

    void setupPattern()
    {
        // Center position
        positions.push_back (Eigen::Vector3f::Zero());

        // Outer petals
        for (int i = 0; i < numPetals; ++i)
        {
            float angle = 2 * M_PI * i / numPetals;
            float x = radius * std::cos (angle);
            float y = radius * std::sin (angle);
            positions.push_back (Eigen::Vector3f (x, y, 0));
        }

        // Inner petals
        float innerRadius = radius * 0.6f;
        for (int i = 0; i < numPetals; ++i)
        {
            float angle = 2 * M_PI * (i + 0.5f) / numPetals;
            float x = innerRadius * std::cos (angle);
            float y = innerRadius * std::sin (angle);
            positions.push_back (Eigen::Vector3f (x, y, 0));
        }

        // Smaller elements
        float smallRadius = radius * 0.3f;
        for (int i = 0; i < numPetals * 2; ++i)
        {
            float angle = 2 * M_PI * i / (numPetals * 2);
            float x = smallRadius * std::cos (angle);
            float y = smallRadius * std::sin (angle);
            positions.push_back (Eigen::Vector3f (x, y, 0));
        }
    }
};
</file>

</files>
