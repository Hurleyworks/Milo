// This header file was auto-generated by ClassMate++
// Created: 16 Sep 2017 5:37:16 pm
// Copyright (c) 2017, HurleyWorks

#pragma once

using Eigen::Matrix4f;
using Eigen::Vector3d;

// Updated to work with modern enum classes
struct RenderableDesc
{
    // Full path to file containing cgModel, materials etc
    std::filesystem::path modelPath = std::filesystem::path();
  
    BodyType bodyType = DEFAULT_BODY_TYPE;
    CollisionShape shape = DEFAULT_COLLISION_SHAPE;
    double mass = DEFAULT_DYNAMIC_MASS;
    //double adhesion = DEFAULT_ADHESION;
    double bounciness = DEFAULT_BOUNCINESS;
    double staticFriction = DEFAULT_STATIC_FRICTION;
    double dynamicFriction = DEFAULT_DYNAMIC_FRICTION;
    uint32_t sleepState = DEFAULT_SLEEP_STATE;
    Eigen::Vector3d force = DEFAULT_FORCE;
    double impulseSpeed = DEFAULT_IMPULSE_SPEED;
    Eigen::Vector3d impulseDirection = DEFAULT_IMPULSE_DIRECTION;

    void resetToDefault()
    {
        modelPath = std::filesystem::path();
        bodyType = DEFAULT_BODY_TYPE;
        shape = DEFAULT_COLLISION_SHAPE;
        mass = DEFAULT_DYNAMIC_MASS;
        sleepState = DEFAULT_SLEEP_STATE;
        //adhesion = DEFAULT_ADHESION;
        staticFriction = DEFAULT_STATIC_FRICTION;
        dynamicFriction = DEFAULT_DYNAMIC_FRICTION;
        bounciness = DEFAULT_BOUNCINESS;
        force = DEFAULT_FORCE;
        impulseSpeed = DEFAULT_IMPULSE_SPEED;
        impulseDirection = DEFAULT_IMPULSE_DIRECTION;
    }

    // Updated to use the new ToString functions
    void debug()
    {
        LOG(DBUG) << "FullFilePath: " << modelPath.generic_string();
        LOG(DBUG) << "Body type: " << ToString(bodyType);
        LOG(DBUG) << "CollisionShape: " << ToString(shape);
        //LOG(DBUG) << "Adhesion" << adhesion;
        LOG(DBUG) << "Mass: " << mass;
        LOG(DBUG) << "Static friction: " << staticFriction;
        LOG(DBUG) << "Dynamic friction: " << dynamicFriction;
        LOG(DBUG) << "Bounciness: " << bounciness;
        LOG(DBUG) << "Force: " << force.x() << ", " << force.y() << ", " << force.z();
        LOG(DBUG) << "Impulse Speed: " << impulseSpeed;
        LOG(DBUG) << "Impulse Direction: " << impulseDirection.x() << ", " << impulseDirection.y() << ", " << impulseDirection.z();
    }
};

using RenderableDataHandle = std::shared_ptr<struct RenderableData>;

struct RenderableData
{
    RenderableData() = default;

    sabi::CgModelPtr cgModel = nullptr;
    std::string name = "unnamed";
    ItemID sceneID = INVALID_ID;
    BodyID clientID = INVALID_ID;
    ItemID sourceID = INVALID_ID; // for instances

    sabi::SpaceTime spacetime;
    sabi::RenderableDesc desc;
    sabi::RenderableState state;
    sabi::MeshOptions meshOptions;
    std::array<float, 16> pose;

    void debug()
    {
        LOG(DBUG) << "name: " << name;
        LOG(DBUG) << "sceneID: " << sceneID;
        LOG(DBUG) << "clientID: " << clientID;
        LOG(DBUG) << "instanaced from ID: " << sourceID;
        LOG(DBUG) << "state: " << state.toString();
        LOG(DBUG) << "cgModel options: " << meshOptions.toString();

        desc.debug();

        mace::matStr4f(spacetime.worldTransform, DBUG, "World transform");
        mace::vecStr3f(spacetime.scale, DBUG, "Scale");

        if (cgModel)
        {
            LOG(DBUG) << "Mesh has " << cgModel->vertexCount() << " vertices";
            LOG(DBUG) << "Mesh has " << cgModel->triangleCount() << " triangles";
            // LOG(DBUG) << "Mesh has " << cgModel->P.size() << " particles";
        }
    }
};

using LoadData = std::vector<RenderableData>;