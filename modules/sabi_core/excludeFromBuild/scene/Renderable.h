// This header file was auto-generated by ClassMate++
// Created: 29 Dec 2018 1:52:03 pm
// Copyright (c) 2018, HurleyWorks

#pragma once

// From Design Patterns book:

// The choice of internal representation for the scene affects nearly
// every aspect of the framework's design. All editing, formatting, displaying
// and analysis will require traversing this representation. The way we organize
// this information will impact the design of the rest of the application

// Composite Pattern
//   Compose objects into tree structures to represent part - whole hierarchies.
//   Composite lets clients treat individual objecta and compositions of objects uniformily

using RenderableNode = std::shared_ptr<class Renderable>;
using RenderableWeakRef = std::weak_ptr<class Renderable>;
using RenderableMap = std::unordered_map<ItemID, RenderableNode>;
using WeakRenderableMap = std::unordered_map<ItemID, RenderableWeakRef>;
using RenderableList = std::vector<RenderableNode>;
using WeakRenderableList = std::vector<RenderableWeakRef>;
using RenderableSet = std::unordered_set<RenderableNode>;
using RenderableQueue = std::deque<RenderableNode>;
using RenderableStack = moodycamel::ConcurrentQueue<sabi::RenderableNode>;
using RenderableWeakStack = moodycamel::ConcurrentQueue<sabi::RenderableWeakRef>;
using sabi::BodyType;
using sabi::CollisionShape;

// inspired by Paul Houx's cinder version
// https://github.com/paulhoux/Cinder-Samples/tree/master/SimpleSceneGraph

class Renderable : public std::enable_shared_from_this<Renderable>,
                   protected Noncopyable,
                   public HasId
{
 public:
    RenderableNode getPtr() { return shared_from_this(); }

 public:
    virtual ~Renderable()
    {
        LOG (DBUG) << getName() << "::" << getID();
    }

    const ItemID getID() const { return id(); }
    const BodyID getClientID() const { return clientID; }
    void setClientID (BodyID bodyID) { clientID = bodyID; }

    const std::string& getName() const { return name; }
    void setName (const std::string& name) { this->name = name; }

    const RenderableDesc& description() const { return desc; }
    RenderableDesc& description() { return desc; }
    void setDescription (const RenderableDesc& description) { desc = description; }

    // basic physics accessors/mutators
    BodyType getBodyType() { return desc.bodyType; }
    CollisionShape getCollisionShape() const { return desc.shape; }
    void setBodyType (BodyType type) { desc.bodyType = type; }
    void setCollisionShape (CollisionShape shape) { desc.shape = shape; }

    const RenderableState& getState() const { return state; }
    RenderableState& getState() { return state; }
    void setState (RenderableState state) { this->state = state; }

    CgModelPtr getModel() const { return cgModel; }
    void setModel (CgModelPtr cgModel) { this->cgModel = cgModel; }
    size_t getTriangleCount() const { return cgModel ? cgModel->triangleCount() : 0; }

    SpaceTime& getSpaceTime() { return spacetime; }
    const SpaceTime& getSpaceTime() const { return spacetime; }
    void setSpacetime (const SpaceTime& spacetime) { this->spacetime = spacetime; }

    void debug (const std::string& msg)
    {
        LOG (DBUG) << msg << "::" << getName() << "::" << getID() << "::" << getPtr().use_count();
    }

    virtual const RenderableData getData() const
    {
        RenderableData d;
        d.clientID = clientID;
        d.desc = desc;
        d.cgModel = cgModel;
        d.name = name;
        d.sceneID = id();
        d.spacetime = spacetime;
        d.state = state;
        // d.pose = const_cast<float*>(spacetime.worldTransform.data());
        const float* m = spacetime.worldTransform.matrix().data();
        for (int i = 0; i < 16; i++)
        {
            d.pose[i] = m[i];
        }
        return d;
    }

    virtual void addChild (RenderableNode node) {}
    virtual bool hasChild (RenderableNode node) const { return false; }
    virtual RenderableNode findChild (ItemID key) { return nullptr; }
    virtual RenderableNode createClone (RenderableNode source) { return nullptr; }

    virtual RenderableNode createInstance() { return nullptr; }
    virtual void setInstancedFrom (RenderableNode node) {}
    virtual RenderableNode getInstancedFrom() { return nullptr; }
    virtual bool isInstance() const { return false; }
    virtual size_t getNumberOfInstances() const { return 0; }

    virtual RenderableNode createPhysicsPhantom() { return nullptr; }
    virtual void setPhantomFrom (RenderableNode node) {}
    virtual RenderableNode getPhantomFrom() { return nullptr; }
    virtual bool isPhantom() const { return false; }

    virtual RenderableNode getRestingOn() { return nullptr; }
    virtual void setRestingOn (RenderableNode node) {}

    virtual void removeChild (RenderableNode node) {}
    virtual void removeChildren() {}

    void setParent (RenderableNode node) { parent = RenderableWeakRef (node); }
    RenderableNode getParent() const { return parent.lock(); }

    const RenderableMap& getChildren() const { return children; }
    RenderableMap& getChildren() { return children; }

    template <class T>
    std::shared_ptr<T> getParent() const
    {
        return std::dynamic_pointer_cast<T> (parent.lock());
    }

    void* getUserdata() { return userdata; }
    void setUserData (void* data) { userdata = data; }
    void* getUserdata2() { return userdata2; }
    void setUserData2 (void* data) { userdata2 = data; }

 protected:
    Renderable() {}

    RenderableWeakRef parent;

    RenderableMap children;

    // a renderable item has a location in spacetime
    SpaceTime spacetime;

    // a renderable might have a cgModel(geometry and materials)
    CgModelPtr cgModel = nullptr;

    // a renderable has a description
    RenderableDesc desc;

    // a renderable has a state
    RenderableState state;

    // might have a client side id
    BodyID clientID = INVALID_ID;

    // a renderable has a name
    std::string name = "unnamed";

    // can I do this with templates somewhow?
    void* userdata = nullptr;
    void* userdata2 = nullptr;
};
