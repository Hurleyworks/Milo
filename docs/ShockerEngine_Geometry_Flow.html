<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShockerEngine Geometry Flow Analysis</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #764ba2;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            font-size: 2.5em;
        }
        h2 {
            color: #667eea;
            margin-top: 40px;
            border-left: 5px solid #764ba2;
            padding-left: 15px;
        }
        h3 {
            color: #555;
            margin-top: 30px;
        }
        .flow-step {
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .code-ref {
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow-x: auto;
        }
        .code-ref .file {
            color: #667eea;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .code-ref .function {
            color: #764ba2;
            font-weight: bold;
        }
        .highlight {
            background: #fffacd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .diagram {
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin: 30px 0;
            text-align: center;
        }
        .arrow {
            color: #667eea;
            font-size: 1.5em;
            margin: 10px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
        }
        td {
            border: 1px solid #ddd;
            padding: 12px;
        }
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        .warning {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .info {
            background: #d1ecf1;
            border-left: 5px solid #0c5460;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .success {
            background: #d4edda;
            border-left: 5px solid #155724;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        ul {
            margin: 15px 0;
            padding-left: 30px;
        }
        li {
            margin: 8px 0;
        }
        .component-box {
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ ShockerEngine Geometry Addition Flow</h1>
        
        <div class="info">
            <strong>üìã Executive Summary:</strong> This document provides a comprehensive analysis of how geometry is added to the ShockerEngine, 
            from the initial API call through to the final GPU-accelerated ray tracing structures.
        </div>

        <h2>üìä Architecture Overview</h2>
        
        <div class="diagram">
            <h3>Component Hierarchy</h3>
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                <div class="component-box" style="flex: 1; margin: 10px;">
                    <strong>ShockerEngine</strong><br>
                    Main engine orchestrator<br>
                    <em>ShockerEngine.cpp</em>
                </div>
                <div class="component-box" style="flex: 1; margin: 10px;">
                    <strong>ShockerSceneHandler</strong><br>
                    Scene graph management<br>
                    <em>ShockerSceneHandler.cpp</em>
                </div>
                <div class="component-box" style="flex: 1; margin: 10px;">
                    <strong>ShockerModelHandler</strong><br>
                    Model/geometry creation<br>
                    <em>ShockerModelHandler.cpp</em>
                </div>
                <div class="component-box" style="flex: 1; margin: 10px;">
                    <strong>ShockerModel</strong><br>
                    Geometry representation<br>
                    <em>ShockerModel.cpp</em>
                </div>
            </div>
        </div>

        <h2>üîÑ Complete Geometry Addition Flow</h2>

        <div class="flow-step">
            <h3>Step 1: Initial API Call</h3>
            <p>The process begins when client code calls <code>addGeometry()</code> on the ShockerEngine.</p>
            
            <div class="code-ref">
                <div class="file">üìÅ ShockerEngine.cpp:326-369</div>
                <pre><span class="function">void ShockerEngine::addGeometry</span>(sabi::RenderableNode node)
{
    // 1. Validate engine initialization
    // 2. Process through scene handler
    sceneHandler_->processRenderableNode(node);
    
    // 3. Update geometry instance data buffer
    modelHandler_->updateGeometryInstanceDataBuffer();
    
    // 4. Build acceleration structures
    sceneHandler_->buildAccelerationStructures();
    
    // 5. Update shader binding table
    updateSBT();
    
    // 6. Update traversable handle
    perFramePlp_.travHandle = sceneHandler_->getTraversableHandle();
}</pre>
            </div>
            
            <ul>
                <li><strong>Input:</strong> <code>sabi::RenderableNode</code> - Contains model data, transforms, and metadata</li>
                <li><strong>Validation:</strong> Checks if engine is initialized</li>
                <li><strong>Delegation:</strong> Passes to SceneHandler for processing</li>
            </ul>
        </div>

        <div class="flow-step">
            <h3>Step 2: Scene Handler Processing</h3>
            <p>The SceneHandler creates the scene graph node and coordinates model creation.</p>
            
            <div class="code-ref">
                <div class="file">üìÅ ShockerSceneHandler.cpp:134-145</div>
                <pre><span class="function">void ShockerSceneHandler::processRenderableNode</span>(RenderableNode& node)
{
    // Create weak reference for memory management
    RenderableWeakRef weakNode = node;
    
    // Create ShockerNode through createShockerNode
    createShockerNode(weakNode);
}</pre>
            </div>

            <div class="code-ref">
                <div class="file">üìÅ ShockerSceneHandler.cpp:75-108</div>
                <pre><span class="function">shocker::ShockerNode* ShockerSceneHandler::createShockerNode</span>(RenderableWeakRef& weakNode)
{
    // 1. Process through model handler
    ShockerModelPtr model = modelHandler_->processRenderableNode(node);
    
    // 2. Create ShockerNode from model
    shocker::ShockerNode* shockerNode = modelHandler_->createShockerNode(
        model.get(), 
        node->getSpaceTime()
    );
    
    // 3. Store in scene graph
    nodes_.push_back(shockerNode);
    nodeMap_[shockerNode->instSlot] = weakNode;
    
    return shockerNode;
}</pre>
            </div>
        </div>

        <div class="flow-step">
            <h3>Step 3: Model Handler Processing</h3>
            <p>The ModelHandler creates the appropriate model type and processes materials.</p>
            
            <div class="code-ref">
                <div class="file">üìÅ ShockerModelHandler.cpp:32-77</div>
                <pre><span class="function">ShockerModelPtr ShockerModelHandler::processRenderableNode</span>(const sabi::RenderableNode& node)
{
    // 1. Get CgModel from node
    sabi::CgModelPtr cgModel = node->getModel();
    
    // 2. Create appropriate model type
    ShockerModelPtr model = createModelByType(cgModel);
    
    // 3. Create geometry from renderable node
    model->createFromRenderableNode(node, geomInstSlotFinder_, renderContext_.get());
    
    // 4. Process materials
    if (materialHandler_) {
        materialHandler_->processMaterialsForModel(model.get(), cgModel, materialFolder);
    }
    
    // 5. Store model
    models_[node->getName()] = model;
    
    return model;
}</pre>
            </div>
        </div>

        <div class="flow-step">
            <h3>Step 4: Model Geometry Creation</h3>
            <p>The ShockerModel creates the actual geometry data and GPU resources.</p>
            
            <div class="code-ref">
                <div class="file">üìÅ ShockerModel.cpp:89-176</div>
                <pre><span class="function">void ShockerTriangleModel::createFromRenderableNode</span>(
    const RenderableNode& node, 
    SlotFinder& slotFinder, 
    RenderContext* renderContext)
{
    // 1. Get CgModel from node
    sabi::CgModelPtr model = node->getModel();
    
    // 2. Process each surface
    for (size_t surfIdx = 0; surfIdx < numSurfaces; ++surfIdx) {
        // a. Allocate geometry instance slot
        uint32_t slot = slotFinder.getFirstAvailableSlot();
        
        // b. Create ShockerSurface
        auto surface = std::make_unique<shocker::ShockerSurface>();
        surface->geomInstSlot = slot;
        
        // c. Create geometry for surface
        createGeometryForSurface(model, surfIdx, surface.get(), renderContext);
        
        // d. Store surface
        surfaces_.push_back(std::move(surface));
    }
    
    // 3. Create ShockerSurfaceGroup
    surfaceGroup_ = std::make_unique<shocker::ShockerSurfaceGroup>();
    for (const auto& surface : surfaces_) {
        surfaceGroup_->geomInsts.insert(surface.get());
    }
    
    // 4. Calculate combined AABB
    calculateCombinedAABB();
}</pre>
            </div>
        </div>

        <div class="flow-step">
            <h3>Step 5: GPU Resource Creation</h3>
            <p>Triangle geometry is uploaded to GPU buffers for OptiX processing.</p>
            
            <div class="code-ref">
                <div class="file">üìÅ ShockerModel.cpp:178-250</div>
                <pre><span class="function">void ShockerTriangleModel::createGeometryForSurface</span>(
    const CgModelPtr& model,
    size_t surfaceIndex,
    shocker::ShockerSurface* surface,
    RenderContext* renderContext)
{
    // 1. Extract geometry data
    std::vector<shared::Vertex> vertices;
    std::vector<shared::Triangle> triangles;
    extractTriangleGeometry(model, surfaceIndex, vertices, triangles, materialIndices);
    
    // 2. Create GPU buffers
    TriangleGeometry triGeom;
    CUcontext cudaContext = renderContext->getCudaContext();
    
    triGeom.vertexBuffer.initialize(cudaContext, cudau::BufferType::Device, vertices.size());
    triGeom.triangleBuffer.initialize(cudaContext, cudau::BufferType::Device, triangles.size());
    
    // 3. Upload to GPU
    triGeom.vertexBuffer.write(vertices.data(), vertices.size());
    triGeom.triangleBuffer.write(triangles.data(), triangles.size());
    
    // 4. Store in surface
    surface->geometry = std::move(triGeom);
    surface->aabb = calculateAABBForVertices(vertices);
}</pre>
            </div>
        </div>

        <div class="flow-step">
            <h3>Step 6: Acceleration Structure Building</h3>
            <p>OptiX acceleration structures are built for ray tracing.</p>
            
            <div class="code-ref">
                <div class="file">üìÅ ShockerSceneHandler.cpp:202-480</div>
                <pre><span class="function">void ShockerSceneHandler::buildAccelerationStructures</span>()
{
    // 1. Build GAS (Geometry Acceleration Structure) for each model
    for (const auto& [name, model] : modelHandler_->getAllModels()) {
        shocker::ShockerSurfaceGroup* surfaceGroup = model->getSurfaceGroup();
        
        // a. Create GAS if needed
        if (!surfaceGroup->optixGas) {
            surfaceGroup->optixGas = scene_->createGeometryAccelerationStructure();
        }
        
        // b. Create geometry instances
        for (shocker::ShockerSurface* surface : surfaceGroup->geomInsts) {
            if (!surface->optixGeomInst) {
                surface->optixGeomInst = scene_->createGeometryInstance();
                surface->optixGeomInst.setVertexBuffer(triGeom->vertexBuffer);
                surface->optixGeomInst.setTriangleBuffer(triGeom->triangleBuffer);
                surface->optixGeomInst.setMaterial(0, 0, defaultMaterial_);
                surface->optixGeomInst.setUserData(surface->geomInstSlot);
            }
            surfaceGroup->optixGas.addChild(surface->optixGeomInst);
        }
        
        // c. Build the GAS
        surfaceGroup->optixGas.rebuild(cudaStream, surfaceGroup->optixGasMem, scratchMem);
    }
    
    // 2. Build IAS (Instance Acceleration Structure)
    if (!ias_) {
        ias_ = scene_->createInstanceAccelerationStructure();
    }
    
    // 3. Create instances for each node
    for (size_t i = 0; i < nodes_.size(); ++i) {
        optixu::Instance inst = scene_->createInstance();
        inst.setChild(node->geomGroupInst.geomGroup->optixGas);
        inst.setID(i);
        inst.setTransform(node->matM2W);
        ias_.addChild(inst);
    }
    
    // 4. Generate SBT layout
    scene_->generateShaderBindingTableLayout(&hitGroupSbtSize);
    
    // 5. Build the IAS
    travHandle_ = ias_.rebuild(cudaStream, instanceBuffer_, iasMem_, scratchMem);
}</pre>
            </div>
        </div>

        <h2>üîë Key Data Structures</h2>

        <table>
            <tr>
                <th>Structure</th>
                <th>Purpose</th>
                <th>Key Fields</th>
            </tr>
            <tr>
                <td><strong>ShockerNode</strong></td>
                <td>Scene graph node representing an instance</td>
                <td>
                    ‚Ä¢ <code>instSlot</code>: Instance index<br>
                    ‚Ä¢ <code>matM2W</code>: Model-to-world transform<br>
                    ‚Ä¢ <code>geomGroupInst</code>: Reference to geometry
                </td>
            </tr>
            <tr>
                <td><strong>ShockerSurface</strong></td>
                <td>Single surface with one material</td>
                <td>
                    ‚Ä¢ <code>geomInstSlot</code>: Geometry instance index<br>
                    ‚Ä¢ <code>geometry</code>: Triangle/curve data<br>
                    ‚Ä¢ <code>mat</code>: Disney material pointer<br>
                    ‚Ä¢ <code>optixGeomInst</code>: OptiX geometry instance
                </td>
            </tr>
            <tr>
                <td><strong>ShockerSurfaceGroup</strong></td>
                <td>Collection of surfaces forming a model</td>
                <td>
                    ‚Ä¢ <code>geomInsts</code>: Set of surfaces<br>
                    ‚Ä¢ <code>optixGas</code>: Geometry acceleration structure<br>
                    ‚Ä¢ <code>aabb</code>: Combined bounding box
                </td>
            </tr>
            <tr>
                <td><strong>TriangleGeometry</strong></td>
                <td>GPU triangle mesh data</td>
                <td>
                    ‚Ä¢ <code>vertexBuffer</code>: GPU vertex buffer<br>
                    ‚Ä¢ <code>triangleBuffer</code>: GPU index buffer
                </td>
            </tr>
        </table>

        <h2>‚ö° OptiX Integration Points</h2>

        <div class="info">
            <h3>Acceleration Structure Hierarchy</h3>
            <ul>
                <li><strong>GAS (Geometry Acceleration Structure):</strong> One per ShockerSurfaceGroup</li>
                <li><strong>IAS (Instance Acceleration Structure):</strong> One for entire scene</li>
                <li><strong>Traversable Handle:</strong> Root handle for ray tracing (stored in <code>perFramePlp_.travHandle</code>)</li>
            </ul>
        </div>

        <div class="warning">
            <h3>‚ö†Ô∏è Critical Considerations</h3>
            <ul>
                <li><strong>Material Assignment:</strong> Materials must be set on geometry instances BEFORE building acceleration structures</li>
                <li><strong>SBT Generation:</strong> Must call <code>generateShaderBindingTableLayout()</code> after adding instances but before IAS build</li>
                <li><strong>Slot Management:</strong> Geometry instance slots must be unique and properly tracked</li>
                <li><strong>Empty Scenes:</strong> Traversable handle of 0 is valid for empty scenes</li>
            </ul>
        </div>

        <h2>üéØ Rendering Pipeline Integration</h2>

        <div class="flow-step">
            <h3>Launch Parameter Updates</h3>
            <p>After geometry is added, several launch parameters are updated:</p>
            
            <div class="code-ref">
                <div class="file">üìÅ ShockerEngine.cpp:355-359</div>
                <pre>// Update traversable handle for ray tracing
perFramePlp_.travHandle = sceneHandler_->getTraversableHandle();

// Reset accumulation for progressive rendering
restartRender_ = true;
perFramePlp_.numAccumFrames = 0;</pre>
            </div>
        </div>

        <h2>üìà Performance Optimizations</h2>

        <div class="success">
            <h3>‚úÖ Implemented Optimizations</h3>
            <ul>
                <li><strong>Lazy GAS Building:</strong> Only rebuild when <code>needsRebuild</code> flag is set</li>
                <li><strong>Buffer Reuse:</strong> Scratch memory and IAS memory buffers are reused when possible</li>
                <li><strong>Slot Recycling:</strong> <code>SlotFinder</code> efficiently manages geometry instance slots</li>
                <li><strong>Batch Processing:</strong> Multiple surfaces processed together in surface groups</li>
            </ul>
        </div>

        <h2>üîç Debugging Tips</h2>

        <div class="info">
            <h3>Common Issues and Solutions</h3>
            <table>
                <tr>
                    <th>Issue</th>
                    <th>Symptom</th>
                    <th>Solution</th>
                </tr>
                <tr>
                    <td>No geometry visible</td>
                    <td>Black screen after adding geometry</td>
                    <td>Check traversable handle is non-zero and materials have hit groups set</td>
                </tr>
                <tr>
                    <td>Crash on ray trace</td>
                    <td>CUDA illegal memory access</td>
                    <td>Verify all launch parameters are initialized, especially buffer pointers</td>
                </tr>
                <tr>
                    <td>Wrong geometry position</td>
                    <td>Geometry appears at origin or wrong location</td>
                    <td>Check transform matrix format (row-major vs column-major)</td>
                </tr>
                <tr>
                    <td>Missing surfaces</td>
                    <td>Some surfaces not rendered</td>
                    <td>Verify slot allocation succeeded for all surfaces</td>
                </tr>
            </table>
        </div>

        <h2>üìö Summary</h2>

        <div class="success">
            <p>The ShockerEngine geometry addition flow is a sophisticated multi-stage process that:</p>
            <ol>
                <li>Accepts high-level scene graph nodes (<code>RenderableNode</code>)</li>
                <li>Creates appropriate model representations (<code>ShockerModel</code>)</li>
                <li>Extracts and uploads geometry data to GPU</li>
                <li>Builds OptiX acceleration structures (GAS and IAS)</li>
                <li>Updates launch parameters for ray tracing</li>
                <li>Manages the shader binding table</li>
            </ol>
            <p>The architecture provides clear separation of concerns with dedicated handlers for scenes, models, materials, and rendering, 
               while maintaining efficient GPU resource management and OptiX integration.</p>
        </div>

        <div style="text-align: center; margin-top: 40px; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 10px;">
            <h3>üìÑ Document Information</h3>
            <p>Generated: <script>document.write(new Date().toLocaleString());</script></p>
            <p>ShockerEngine Version: Milo Framework</p>
            <p>Analysis based on current codebase implementation</p>
        </div>
    </div>
</body>
</html>