<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robust PipelineHandler Requirements - OptiX Utility</title>
    <style>
        :root {
            --primary-color: #76b900;
            --secondary-color: #1a1a1a;
            --bg-color: #f5f5f5;
            --code-bg: #2d2d2d;
            --border-color: #ddd;
            --text-color: #333;
            --link-color: #4a90e2;
            --warning-bg: #fff3cd;
            --warning-border: #ffc107;
            --info-bg: #d1ecf1;
            --info-border: #0c5460;
            --success-bg: #d4edda;
            --success-border: #155724;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary-color), #5a8d00);
            color: white;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        header p {
            font-size: 1.2em;
            opacity: 0.95;
        }
        
        nav {
            background: white;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        nav h2 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        nav ul {
            list-style: none;
            padding-left: 0;
        }
        
        nav li {
            margin-bottom: 8px;
        }
        
        nav a {
            color: var(--text-color);
            text-decoration: none;
            padding: 5px 10px;
            display: block;
            border-radius: 4px;
            transition: background 0.3s;
        }
        
        nav a:hover {
            background: var(--bg-color);
            color: var(--primary-color);
        }
        
        section {
            background: white;
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }
        
        h3 {
            color: var(--secondary-color);
            margin: 20px 0 15px;
            font-size: 1.4em;
        }
        
        h4 {
            color: var(--secondary-color);
            margin: 15px 0 10px;
            font-size: 1.2em;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #d63384;
        }
        
        pre {
            background: var(--code-bg);
            color: #f8f8f2;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 15px 0;
            line-height: 1.4;
        }
        
        pre code {
            background: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.95em;
        }
        
        .alert {
            padding: 15px;
            margin: 20px 0;
            border-radius: 6px;
            border-left: 4px solid;
        }
        
        .alert-warning {
            background-color: var(--warning-bg);
            border-color: var(--warning-border);
        }
        
        .alert-info {
            background-color: var(--info-bg);
            border-color: var(--info-border);
        }
        
        .alert-success {
            background-color: var(--success-bg);
            border-color: var(--success-border);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        th {
            background: var(--bg-color);
            font-weight: 600;
            color: var(--secondary-color);
        }
        
        .requirement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .requirement-card {
            background: var(--bg-color);
            padding: 20px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .requirement-card h4 {
            color: var(--primary-color);
            margin-top: 0;
        }
        
        .code-example {
            position: relative;
            margin: 20px 0;
        }
        
        .code-example::before {
            content: attr(data-lang);
            position: absolute;
            top: 0;
            right: 0;
            background: var(--primary-color);
            color: white;
            padding: 4px 10px;
            border-radius: 0 6px 0 6px;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        .feature-matrix {
            overflow-x: auto;
        }
        
        .feature-matrix table {
            min-width: 600px;
        }
        
        .check {
            color: green;
            font-weight: bold;
        }
        
        .cross {
            color: red;
            font-weight: bold;
        }
        
        .lifecycle-diagram {
            background: var(--bg-color);
            padding: 20px;
            border-radius: 6px;
            margin: 20px 0;
            text-align: center;
        }
        
        .lifecycle-step {
            display: inline-block;
            background: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 20px;
            border: 2px solid var(--primary-color);
            position: relative;
        }
        
        .lifecycle-step::after {
            content: '→';
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--primary-color);
            font-size: 1.2em;
        }
        
        .lifecycle-step:last-child::after {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Robust PipelineHandler Requirements</h1>
            <p>Comprehensive Guide for OptiX Pipeline Management in C++20</p>
        </header>
        
        <nav>
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#core-responsibilities">Core Responsibilities</a></li>
                <li><a href="#essential-features">Essential Features</a></li>
                <li><a href="#implementation-requirements">Implementation Requirements</a></li>
                <li><a href="#lifecycle-management">Lifecycle Management</a></li>
                <li><a href="#error-handling">Error Handling & Validation</a></li>
                <li><a href="#performance-considerations">Performance Considerations</a></li>
                <li><a href="#design-patterns">Design Patterns & Best Practices</a></li>
                <li><a href="#api-design">API Design Guidelines</a></li>
                <li><a href="#code-examples">Code Examples</a></li>
            </ul>
        </nav>
        
        <section id="overview">
            <h2>Overview</h2>
            <p>A robust PipelineHandler for OptiX must manage the complete lifecycle of ray tracing pipelines while providing a clean, type-safe interface that follows KISS principles. Based on analysis of OptiX_Utility samples and production code, this document outlines the essential requirements for a professional-grade pipeline handler.</p>
            
            <div class="alert alert-info">
                <strong>Key Principle:</strong> The PipelineHandler should abstract complexity without hiding functionality. It must be simple to use for basic cases while allowing full control when needed.
            </div>
        </section>
        
        <section id="core-responsibilities">
            <h2>Core Responsibilities</h2>
            
            <div class="requirement-grid">
                <div class="requirement-card">
                    <h4>1. Pipeline Configuration</h4>
                    <ul>
                        <li>Set pipeline options (payload size, attributes, etc.)</li>
                        <li>Configure traversable graph flags</li>
                        <li>Manage exception handling flags</li>
                        <li>Define supported primitive types</li>
                    </ul>
                </div>
                
                <div class="requirement-card">
                    <h4>2. Module Management</h4>
                    <ul>
                        <li>Load modules from PTX/OptiX IR</li>
                        <li>Support multiple modules per pipeline</li>
                        <li>Handle compilation options</li>
                        <li>Manage module lifecycle</li>
                    </ul>
                </div>
                
                <div class="requirement-card">
                    <h4>3. Program Organization</h4>
                    <ul>
                        <li>Create and manage ray generation programs</li>
                        <li>Handle miss programs per ray type</li>
                        <li>Manage hit program groups</li>
                        <li>Support callable programs</li>
                    </ul>
                </div>
                
                <div class="requirement-card">
                    <h4>4. SBT Management</h4>
                    <ul>
                        <li>Generate shader binding table layout</li>
                        <li>Allocate and manage SBT memory</li>
                        <li>Handle hit group SBT separately</li>
                        <li>Support dynamic SBT updates</li>
                    </ul>
                </div>
                
                <div class="requirement-card">
                    <h4>5. Scene Integration</h4>
                    <ul>
                        <li>Associate pipeline with scene</li>
                        <li>Coordinate with material system</li>
                        <li>Support scene changes</li>
                        <li>Handle multiple scenes</li>
                    </ul>
                </div>
                
                <div class="requirement-card">
                    <h4>6. Launch Operations</h4>
                    <ul>
                        <li>Prepare launch parameters</li>
                        <li>Execute pipeline launch</li>
                        <li>Support different entry points</li>
                        <li>Handle multi-GPU if needed</li>
                    </ul>
                </div>
            </div>
        </section>
        
        <section id="essential-features">
            <h2>Essential Features</h2>
            
            <h3>Must-Have Features</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Description</th>
                        <th>Priority</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>RAII Resource Management</td>
                        <td>Automatic cleanup of OptiX resources in correct order</td>
                        <td><span class="check">Critical</span></td>
                    </tr>
                    <tr>
                        <td>Type-Safe Entry Points</td>
                        <td>Template-based entry point management with compile-time safety</td>
                        <td><span class="check">Critical</span></td>
                    </tr>
                    <tr>
                        <td>Module Loading</td>
                        <td>Support for PTX and OptiX IR loading with error handling</td>
                        <td><span class="check">Critical</span></td>
                    </tr>
                    <tr>
                        <td>SBT Generation</td>
                        <td>Automatic shader binding table layout and memory management</td>
                        <td><span class="check">Critical</span></td>
                    </tr>
                    <tr>
                        <td>Stack Size Management</td>
                        <td>Automatic or manual stack size configuration</td>
                        <td><span class="check">Critical</span></td>
                    </tr>
                    <tr>
                        <td>Pipeline Linking</td>
                        <td>Link with configurable trace depth</td>
                        <td><span class="check">Critical</span></td>
                    </tr>
                    <tr>
                        <td>Error Validation</td>
                        <td>Comprehensive error checking at each stage</td>
                        <td><span class="check">Critical</span></td>
                    </tr>
                </tbody>
            </table>
            
            <h3>Optional but Recommended Features</h3>
            <ul>
                <li><strong>Callable Program Support:</strong> Dynamic shader selection at runtime</li>
                <li><strong>Multiple Entry Points:</strong> Switch between different ray generation programs</li>
                <li><strong>Configuration Struct:</strong> Centralized pipeline options</li>
                <li><strong>Debug/Release Modes:</strong> Different optimization levels</li>
                <li><strong>State Tracking:</strong> Monitor pipeline state (uninitialized, compiled, ready)</li>
            </ul>
        </section>
        
        <section id="implementation-requirements">
            <h2>Implementation Requirements</h2>
            
            <h3>Class Structure</h3>
            <div class="code-example" data-lang="C++">
                <pre><code>template &lt;typename EntryPointType&gt;
class PipelineHandler {
public:
    // Configuration structure
    struct Config {
        uint32_t maxTraceDepth = 2;
        uint32_t numPayloadDwords;
        uint32_t numAttributeDwords;
        std::string launchParamsName = "plp";
        size_t launchParamsSize;
        uint32_t traversableGraphFlags;
        uint32_t exceptionFlags;
        uint32_t primitiveTypeFlags;
    };

private:
    // Core OptiX objects
    optixu::Pipeline pipeline_;
    std::vector&lt;optixu::Module&gt; modules_;
    
    // Program collections
    std::unordered_map&lt;EntryPointType, optixu::Program&gt; rayGenPrograms_;
    std::vector&lt;optixu::Program&gt; missPrograms_;
    std::unordered_map&lt;std::string, optixu::HitProgramGroup&gt; hitGroups_;
    std::vector&lt;optixu::CallableProgramGroup&gt; callablePrograms_;
    
    // Shader binding tables
    cudau::Buffer sbt_;
    cudau::Buffer hitGroupSbt_;
    
    // State tracking
    Config config_;
    EntryPointType currentEntryPoint_;
    bool isLinked_ = false;
    bool sbtDirty_ = true;
};</code></pre>
            </div>
            
            <h3>Memory Management Requirements</h3>
            <div class="alert alert-warning">
                <strong>Critical:</strong> Resources must be destroyed in reverse order of creation:
                <ol>
                    <li>Buffers (SBT, hit group SBT)</li>
                    <li>Programs (callable, miss, hit groups, ray gen)</li>
                    <li>Modules</li>
                    <li>Pipeline</li>
                </ol>
            </div>
            
            <h3>Thread Safety</h3>
            <ul>
                <li>Pipeline configuration must be thread-safe during initialization</li>
                <li>Launch operations can be called from multiple threads with different parameters</li>
                <li>State changes (entry point switching) require synchronization</li>
            </ul>
        </section>
        
        <section id="lifecycle-management">
            <h2>Lifecycle Management</h2>
            
            <div class="lifecycle-diagram">
                <span class="lifecycle-step">Create</span>
                <span class="lifecycle-step">Configure</span>
                <span class="lifecycle-step">Load Modules</span>
                <span class="lifecycle-step">Create Programs</span>
                <span class="lifecycle-step">Link</span>
                <span class="lifecycle-step">Setup SBT</span>
                <span class="lifecycle-step">Launch</span>
                <span class="lifecycle-step">Destroy</span>
            </div>
            
            <h3>Initialization Sequence</h3>
            <ol>
                <li><strong>Context Association:</strong> Connect to OptiX context</li>
                <li><strong>Pipeline Creation:</strong> Create pipeline object</li>
                <li><strong>Configuration:</strong> Set pipeline options</li>
                <li><strong>Module Loading:</strong> Load PTX/OptiX IR modules</li>
                <li><strong>Program Creation:</strong> Create all required programs</li>
                <li><strong>Pipeline Linking:</strong> Link with specified trace depth</li>
                <li><strong>Stack Size Setup:</strong> Calculate and set stack sizes</li>
                <li><strong>SBT Generation:</strong> Generate and allocate SBT</li>
                <li><strong>Scene Association:</strong> Connect to scene if needed</li>
            </ol>
            
            <h3>Runtime Operations</h3>
            <ul>
                <li><strong>Entry Point Switching:</strong> Change active ray generation program</li>
                <li><strong>SBT Updates:</strong> Refresh SBT when scene changes</li>
                <li><strong>Launch:</strong> Execute pipeline with parameters</li>
            </ul>
            
            <h3>Cleanup Sequence</h3>
            <div class="code-example" data-lang="C++">
                <pre><code>void destroy() {
    // 1. Clean up buffers
    if (hitGroupSbt_.isInitialized())
        hitGroupSbt_.finalize();
    if (sbt_.isInitialized())
        sbt_.finalize();
    
    // 2. Destroy programs in reverse order
    for (auto& program : callablePrograms_)
        program.destroy();
    for (auto& [name, program] : hitGroups_)
        program.destroy();
    for (auto& program : missPrograms_)
        program.destroy();
    for (auto& [type, program] : rayGenPrograms_)
        program.destroy();
    
    // 3. Destroy modules
    for (auto& module : modules_)
        module.destroy();
    
    // 4. Destroy pipeline
    if (pipeline_)
        pipeline_.destroy();
}</code></pre>
            </div>
        </section>
        
        <section id="error-handling">
            <h2>Error Handling & Validation</h2>
            
            <h3>Validation Points</h3>
            <table>
                <thead>
                    <tr>
                        <th>Stage</th>
                        <th>Validation</th>
                        <th>Action on Failure</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Module Loading</td>
                        <td>Verify PTX/OptiX IR validity</td>
                        <td>Throw exception with details</td>
                    </tr>
                    <tr>
                        <td>Program Creation</td>
                        <td>Check entry point exists</td>
                        <td>Return error or throw</td>
                    </tr>
                    <tr>
                        <td>Pipeline Linking</td>
                        <td>Validate all programs set</td>
                        <td>Report missing programs</td>
                    </tr>
                    <tr>
                        <td>SBT Generation</td>
                        <td>Check memory allocation</td>
                        <td>Handle out-of-memory</td>
                    </tr>
                    <tr>
                        <td>Launch</td>
                        <td>Verify pipeline is ready</td>
                        <td>Skip launch or assert</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>Error Reporting Strategy</h3>
            <div class="code-example" data-lang="C++">
                <pre><code>enum class PipelineError {
    None,
    InvalidContext,
    ModuleLoadFailed,
    ProgramCreationFailed,
    LinkingFailed,
    SBTGenerationFailed,
    NotLinked,
    InvalidEntryPoint
};

// Return Result&lt;T, PipelineError&gt; or use exceptions
// Provide detailed error messages with context</code></pre>
            </div>
        </section>
        
        <section id="performance-considerations">
            <h2>Performance Considerations</h2>
            
            <h3>Optimization Strategies</h3>
            <ul>
                <li><strong>Module Caching:</strong> Avoid recompiling unchanged modules</li>
                <li><strong>SBT Persistence:</strong> Keep SBT mapped memory persistent</li>
                <li><strong>Stack Size Optimization:</strong> Calculate minimal required stack sizes</li>
                <li><strong>Compilation Flags:</strong> Use appropriate optimization levels</li>
            </ul>
            
            <h3>Memory Efficiency</h3>
            <table>
                <thead>
                    <tr>
                        <th>Technique</th>
                        <th>Benefit</th>
                        <th>Trade-off</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Shared modules</td>
                        <td>Reduced memory usage</td>
                        <td>Complex dependency tracking</td>
                    </tr>
                    <tr>
                        <td>Lazy SBT allocation</td>
                        <td>Memory saved until needed</td>
                        <td>First launch overhead</td>
                    </tr>
                    <tr>
                        <td>Program reuse</td>
                        <td>Less compilation</td>
                        <td>Careful state management</td>
                    </tr>
                </tbody>
            </table>
        </section>
        
        <section id="design-patterns">
            <h2>Design Patterns & Best Practices</h2>
            
            <h3>Recommended Patterns</h3>
            <div class="requirement-grid">
                <div class="requirement-card">
                    <h4>RAII Pattern</h4>
                    <p>Ensure automatic resource cleanup through destructors. Never rely on manual cleanup calls.</p>
                </div>
                
                <div class="requirement-card">
                    <h4>Builder Pattern (Optional)</h4>
                    <p>For complex configurations, consider a fluent builder interface for pipeline setup.</p>
                </div>
                
                <div class="requirement-card">
                    <h4>Template Specialization</h4>
                    <p>Use templates for type-safe entry points while avoiding code bloat.</p>
                </div>
                
                <div class="requirement-card">
                    <h4>Configuration Object</h4>
                    <p>Group related settings in a Config struct for cleaner interfaces.</p>
                </div>
            </div>
            
            <h3>Anti-Patterns to Avoid</h3>
            <ul>
                <li>❌ <strong>Over-abstraction:</strong> Don't hide OptiX functionality unnecessarily</li>
                <li>❌ <strong>Global state:</strong> Avoid static/global pipeline instances</li>
                <li>❌ <strong>Implicit behavior:</strong> Make all operations explicit and predictable</li>
                <li>❌ <strong>Premature optimization:</strong> Start simple, optimize based on profiling</li>
                <li>❌ <strong>Complex inheritance:</strong> Prefer composition over inheritance</li>
            </ul>
        </section>
        
        <section id="api-design">
            <h2>API Design Guidelines</h2>
            
            <h3>Method Naming Convention</h3>
            <ul>
                <li><code>initialize()</code> - One-time setup</li>
                <li><code>configure()</code> - Set pipeline options</li>
                <li><code>loadModule()</code> - Load shader modules</li>
                <li><code>createProgram()</code> - Create specific programs</li>
                <li><code>link()</code> - Link the pipeline</li>
                <li><code>launch()</code> - Execute the pipeline</li>
                <li><code>destroy()</code> - Explicit cleanup</li>
                <li><code>isReady()</code> - Check if ready to launch</li>
                <li><code>setEntryPoint()</code> - Switch ray gen program</li>
            </ul>
            
            <h3>Return Types</h3>
            <div class="code-example" data-lang="C++">
                <pre><code>// Simple operations return bool
bool loadModule(const std::string& path);

// Complex operations can use Result&lt;T&gt; or exceptions
std::expected&lt;void, PipelineError&gt; link(uint32_t maxTraceDepth);

// Queries return values directly
bool isReady() const;
EntryPointType getCurrentEntryPoint() const;</code></pre>
            </div>
        </section>
        
        <section id="code-examples">
            <h2>Code Examples</h2>
            
            <h3>Basic Usage Pattern</h3>
            <div class="code-example" data-lang="C++">
                <pre><code>// Define entry points
enum class RenderMode {
    Primary,
    Progressive,
    Debug
};

// Create and configure pipeline
PipelineHandler&lt;RenderMode&gt; pipeline;
PipelineHandler&lt;RenderMode&gt;::Config config;
config.numPayloadDwords = 8;
config.maxTraceDepth = 2;
config.launchParamsSize = sizeof(LaunchParams);

// Initialize
pipeline.initialize(optixContext, config);

// Load module and create programs
pipeline.loadModule("path/to/optix_kernels.optixir");
pipeline.createRayGenProgram(RenderMode::Primary, "raygen_primary");
pipeline.createRayGenProgram(RenderMode::Progressive, "raygen_progressive");
pipeline.createMissProgram(0, "miss_radiance");
pipeline.createHitGroup("main", "closesthit_main", nullptr, nullptr);

// Link and setup
pipeline.link(config.maxTraceDepth);
pipeline.generateSBT();

// Launch
pipeline.setEntryPoint(RenderMode::Primary);
pipeline.launch(stream, launchParams, width, height);</code></pre>
            </div>
            
            <h3>Advanced Features</h3>
            <div class="code-example" data-lang="C++">
                <pre><code>// Callable program support
pipeline.createCallableProgram(0, "sample_bsdf");
pipeline.createCallableProgram(1, "evaluate_bsdf");

// Multiple modules
pipeline.loadModule("common.optixir", "common");
pipeline.loadModule("materials.optixir", "materials");

// Hit group variants
pipeline.createHitGroup("opaque", "ch_opaque", nullptr, nullptr);
pipeline.createHitGroup("alpha", "ch_alpha", "ah_alpha", nullptr);

// Dynamic SBT updates
pipeline.markSBTDirty();
pipeline.updateSBT();</code></pre>
            </div>
        </section>
        
        <section>
            <h2>Summary</h2>
            <p>A robust PipelineHandler must balance simplicity with functionality. It should:</p>
            <ul>
                <li>✅ Provide RAII-based resource management</li>
                <li>✅ Offer type-safe interfaces where beneficial</li>
                <li>✅ Follow established OptiX patterns</li>
                <li>✅ Handle errors gracefully</li>
                <li>✅ Support common use cases simply</li>
                <li>✅ Allow advanced usage when needed</li>
                <li>✅ Maintain clear ownership and lifecycle</li>
                <li>✅ Integrate well with existing OptiX Utility classes</li>
            </ul>
            
            <div class="alert alert-success">
                <strong>Remember:</strong> Keep It Simple, Stupid (KISS). Start with the minimum viable functionality and add features only when proven necessary through actual usage.
            </div>
        </section>
    </div>
</body>
</html>