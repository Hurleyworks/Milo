// This source file was auto-generated by ClassMate++
// Created: 31 Jul 2019 4:12:49 pm
// Copyright (c) 2019, HurleyWorks

#include "Dreamer.h"

using namespace OIIO;

void Dreamer::init (MessageService messengers, const PropertyService& properties)
{
    this->messengers = messengers;
    this->properties = properties;
}

void Dreamer::loadImagesAsync (const PathList& imagePaths)
{
    #if 0
    ScopedStopWatch sw ("LOAD THUMBNAILS");
    uint32_t count = imagePaths.size();
    if (!count) return;

    // check the first path for icons
    std::filesystem::path p = imagePaths[0];
    if (pathContainsIgnoreCase (p, "hdri_thumbs"))
    {
        properties.ioProps->setValue (IOKey::EnviroIconCount, count);
    }

    if (pathContainsIgnoreCase (p, "model_thumbs"))
    {
        properties.ioProps->setValue (IOKey::ModelIconCount, count);
    }

    BS::thread_pool pool;

    pool.detach_blocks (0u, (uint32_t)imagePaths.size(),
                    [&] (const uint32_t start, const uint32_t end)
                    {
                        for (uint32_t i = start; i < end; ++i)
                        {
                            const std::filesystem::path& path = imagePaths[i];

                            // create ImagBuf from file path
                            OIIO::ImageBuf image (path.generic_string());
                            if (image.has_error())
                            {
                                LOG (CRITICAL) << image.geterror();
                            }
                            else
                            {
                                int nChan = image.spec().nchannels;
                                if (nChan == 3)
                                {
                                    // add an alpha channel
                                    int channelorder[] = {0, 1, 2, 3};
                                    float channelvalues[] = {0 /*ignore*/, 0 /*ignore*/, 0 /*ignore*/, 1.0f};
                                    std::string channelnames[] = {"", "", "", "A"};
                                    OIIO::ImageBuf rgba = OIIO::ImageBufAlgo::channels (image, 4, channelorder, channelvalues, channelnames);

                                    // save the full path as an attribute
                                    OIIO::ImageSpec& rgbaSpec = rgba.specmod();
                                    rgbaSpec.attribute ("fullpath", path.generic_string());

                                    imageQueue.enqueue (std::move (rgba));
                                }
                                else if (nChan == 4)
                                {
                                    // save the full path as an attribute
                                    OIIO::ImageSpec& spc = image.specmod();
                                    spc.attribute ("fullpath", path.generic_string());

                                    imageQueue.enqueue (std::move (image));
                                }
                            }
                        }
                    });

    pool.wait();

    LOG (DBUG) << "Processed " << imagePaths.size() << " images";

    #endif
}
