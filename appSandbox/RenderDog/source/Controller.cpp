// This source file was auto-generated by ClassMate++
// Created: 26 Mar 2022 9:08:29 am
// Copyright (c) 2022, HurleyWorks

#include "Controller.h"

const float panFactor = 0.035f;

void Controller::onInputEvent (const InputEvent& input, CameraHandle camera)
{
    mouseCoords = Eigen::Vector2f (input.getX(), input.getY());
    MouseMode mouseMode = input.getMouseMode();


    LOG (DBUG) << mouseCoords.x() << ", " << mouseCoords.y();
    // record mouse movement
    float deltaX = input.getScreenMovementX();
    float deltaY = input.getScreenMovementY();

    // LOG (DBUG) << deltaX << ", " << deltaY;

    float zoomFactor = DEFAULT_ZOOM_FACTOR;

    uint32_t keyModifers = input.getKeyboardModifiers();

    // shift key to increase Zoom factor
    if (input.getKeyboardModifiers() & static_cast<int> (InputEvent::Modifier::Shift))
    {
        zoomFactor *= DEFAULT_ZOOM_MULTIPLIER;
    }

    switch (input.getType())
    {
        case InputEvent::Type::Press:
        {
            if (input.getButton() == InputEvent::MouseButton::Left && mouseMode == MouseMode::Rotate)
            {
                camera->startTracking();
                camera->setDirty (true);

                // have to store the button pressed because
                // getButton doesn't give the right answer in Drag events
                buttonPressed = InputEvent::MouseButton::Left;
            }
            else if (input.getButton() == InputEvent::MouseButton::Left && mouseMode == MouseMode::Translate)
            {
                startMouseCoords = mouseCoords;
                startScreenX = deltaX;
                startScreenY = deltaY;
                // have to store the button pressed because
                // getButton doesn't give the right answer in Drag events
                buttonPressed = InputEvent::MouseButton::Left;
            }
            else if (input.getButton() == InputEvent::MouseButton::Left && mouseMode == MouseMode::Paint)
            {
                //LOG (DBUG) << "PAINT PRESS";
                camera->setDirty (true);
            }
            else if (input.getButton() == InputEvent::MouseButton::Right && input.getKey() == 70)
            {
                camera->setDirty (true);
                buttonPressed = InputEvent::MouseButton::Right;
            }
            else if (input.getButton() == InputEvent::MouseButton::Right)
            {
                camera->setDirty (true);
                buttonPressed = InputEvent::MouseButton::Right;
            }

            break;
        }

        case InputEvent::Type::Release:
        {
            camera->setDirty (false);
            break;
        }

        case InputEvent::Type::Move:
            break;

        case InputEvent::Type::ScrollUp:
            camera->zoom (zoomFactor);
            camera->setDirty (true);
            break;

        case InputEvent::Type::ScrollDown:
            camera->zoom (zoomFactor * -1);
            camera->setDirty (true);
            break;

        case InputEvent::Type::Drag:

            // LMB for camera trackball, RMB for picking
            if (buttonPressed == InputEvent::MouseButton::Left && mouseMode == MouseMode::Rotate)
            {
                camera->track (Eigen::Vector2f (input.getX(), input.getY()));
            }
            else if (buttonPressed == InputEvent::MouseButton::Left && mouseMode == MouseMode::Translate)
            {
                float panX = deltaX - startScreenX;
                float panY = deltaY - startScreenY;

                if (fabs (panX) > fabs (panY))
                {
                    panX > 0.0f ? camera->panHorizontal (-panFactor) : camera->panHorizontal (panFactor);
                }
                else
                {
                    panY > 0.0f ? camera->panVertical (panFactor) : camera->panVertical (-panFactor);
                }

                startScreenX = deltaX;
                startScreenY = deltaY;
            }
            else if (input.getButton() == InputEvent::MouseButton::Left && mouseMode == MouseMode::Paint)
            {
                //LOG (DBUG) << "PAINTING WITH LMB";
            }

            camera->setDirty (true);
            break;

        case InputEvent::Type::KeyRepeat:
        {
            if (input.getKey() == 262)
            {
                float value = properties.renderProps->getVal<float> (RenderKey::EnviroRotation);
                properties.renderProps->setValue (RenderKey::EnviroRotation, value + 0.0075f);
            }

            if (input.getKey() == 263)
            {
                float value = properties.renderProps->getVal<float> (RenderKey::EnviroRotation);
                properties.renderProps->setValue (RenderKey::EnviroRotation, value + -0.0075f);
            }

            if (input.getKey() == 265)
            {
                float value = properties.renderProps->getVal<float> (RenderKey::EnviroIntensity);
                properties.renderProps->setValue (RenderKey::EnviroIntensity, value + 0.0075f);
            }

            if (input.getKey() == 264)
            {
                float value = properties.renderProps->getVal<float> (RenderKey::EnviroIntensity);
                properties.renderProps->setValue (RenderKey::EnviroIntensity, value + -0.0075f);
            }

            camera->setDirty (true);
            break;
        }
        case InputEvent::Type::KeyPress:
        {
            camera->setDirty (true);

            LOG (DBUG) << input.getKey();

            if (input.getKey() == 262)
            {
                float value = properties.renderProps->getVal<float> (RenderKey::EnviroRotation);
                properties.renderProps->setValue (RenderKey::EnviroRotation, value + 0.01f);
            }

            if (input.getKey() == 263)
            {
                float value = properties.renderProps->getVal<float> (RenderKey::EnviroRotation);
                properties.renderProps->setValue (RenderKey::EnviroRotation, value + -0.01f);
            }

            if (input.getKey() == 265)
            {
                float value = properties.renderProps->getVal<float> (RenderKey::EnviroIntensity);
                properties.renderProps->setValue (RenderKey::EnviroIntensity, value + 0.0075f);
            }

            if (input.getKey() == 264)
            {
                float value = properties.renderProps->getVal<float> (RenderKey::EnviroIntensity);
                properties.renderProps->setValue (RenderKey::EnviroIntensity, value + -0.0075f);
            }
            // space bar for toggle between mouse modes
            if (input.getKey() == 32)
            {
            }

            if (input.getKey() == 70)
            {
                framegrabEmitter.fire();
            }

            // h for instance stack
            if (input.getKey() == 72)
            {
                stackEmitter.fire (100);
            }

            // v for cgModel visibility
            if (input.getKey() == 86)
            {
                // control v makes invisible
                if (input.getKeyboardModifiers() == static_cast<uint32_t> (InputEvent::Modifier::Ctrl))
                {
                    modelVisibilityEmitter.fire (0);
                }
                else // make visible
                {
                    modelVisibilityEmitter.fire (255);
                }
            }

            // a for cgModel selection/deselection
            if (input.getKey() == 65)
            {
                // control 'a' selects all
                if (input.getKeyboardModifiers() == static_cast<uint32_t> (InputEvent::Modifier::Ctrl))
                {
                    selectAllEmitter.fire();
                }
                else // 'a' deselects all
                {
                    deselectAllEmitter.fire();
                }
            }

            break;
        }
    }
}

void Controller::onEnvironmentIntensityChange(float intensity)
{
    // intensity is already a coefficient (0-2 range)
    properties.renderProps->setValue(RenderKey::EnviroIntensity, intensity);
    
    // Reset accumulation by making camera dirty
    if (camera)
        camera->setDirty(true);
}

void Controller::onEnvironmentRotationChange(float rotation)
{
    // rotation is in degrees (-180 to 180)
    properties.renderProps->setValue(RenderKey::EnviroRotation, rotation);
    
    // Reset accumulation by making camera dirty
    if (camera)
        camera->setDirty(true);
}

void Controller::onAreaLightIntensityChange(float intensity)
{
    // Store area light power coefficient
    properties.renderProps->setValue(RenderKey::AreaLightPower, intensity);
    
    // Reset accumulation by making camera dirty
    if (camera)
        camera->setDirty(true);
}

void Controller::onAreaLightEnable(bool enable)
{
    // Store area light enable state
    properties.renderProps->setValue(RenderKey::EnableAreaLights, enable);
    
    // Reset accumulation by making camera dirty
    if (camera)
        camera->setDirty(true);
}
