// This header file was auto-generated by ClassMate++
// Created: 16 Sep 2017 5:37:16 pm
// Copyright (c) 2017, HurleyWorks

#pragma once

static const char* PRenderableStateTable[] =
    {
        "Pickable",
        "Selected",
        "SelectionChanged",
        "Deletable",
        "Visible",
        "Emitter",
        "Target",
        "UserAnimated",
        "FluidMesh",
        "SplashMesh",
        "SplashInstanceMesh",
        "MeshIsDirty",
        "Breakable",
        "UnseenByPickRay",
        "BeingPainted",
        "ImpulseApplied",
        "LoadedFromScene",
        "ProcessedByRenderer",
        "Deformed",
        "DeformedStateChanged",
        "HasSubdivision",
        "Invalid"};

struct PRenderableState
{
    enum EPRenderableState
    {
        Pickable = 1 << 0,
        Selected = 1 << 1,
        SelectionChanged = 1 << 2,
        Deletable = 1 << 3,
        Visible = 1 << 4,
        Emitter = 1 << 5,
        Target = 1 << 6,
        UserAnimated = 1 << 7,
        FluidMesh = 1 << 8,
        SplashMesh = 1 << 9,
        SplashInstanceMesh = 1 << 10,
        MeshIsDirty = 1 << 11,
        Breakable = 1 << 12,
        UnseenByPickRay = 1 << 13,
        BeingPainted = 1 << 14,
        ImpulseApplied = 1 << 15,
        LoadedFromScene = 1 << 16,
        ProcessedByRenderer = 1 << 17,
        StoredInSceneHandler = 1 << 18,
        Deformed = 1 << 19,
        DeformedStateChanged = 1 << 20,
        HasSubdivision = 1 << 21,
        Invalid = 1 << 22
    };

    union
    {
        EPRenderableState name;
        unsigned long value;
    };

    PRenderableState (EPRenderableState name) :
        name (name) {}
    PRenderableState (unsigned long value) :
        value (value) {}
    PRenderableState() :
        value (0) {}
    void clear() { value = 0; }
    operator EPRenderableState() const { return name; }
    unsigned long operator|= (PRenderableState m) { return value |= m; }
    unsigned long operator&= (PRenderableState m) { return value &= m; }
    unsigned long operator^= (PRenderableState m) { return value ^= m; }

    std::string toString()
    {
        std::ostringstream ostr;
        ostr << "  PRenderableState::";

        if (value & Pickable)
            ostr << "Pickable:";

        if (value & Selected)
            ostr << "Selected:";

        if (value & SelectionChanged)
            ostr << "SelectionChanged:";

        if (value & Deletable)
            ostr << "Deletable:";

        if (value & Visible)
            ostr << "Visible:";

        if (value & Emitter)
            ostr << "Emitter:";

        if (value & Target)
            ostr << "Target:";

        if (value & UserAnimated)
            ostr << "UserAnimated:";

        if (value & FluidMesh)
            ostr << "FluidMesh:";

        if (value & SplashMesh)
            ostr << "SplashMesh:";

        if (value & SplashInstanceMesh)
            ostr << "SplashInstanceMesh:";

        if (value & MeshIsDirty)
            ostr << "MeshIsDirty:";

        if (value & Breakable)
            ostr << "Breakable:";

        if (value & UnseenByPickRay)
            ostr << "UnseenByPickRay:";

        if (value & BeingPainted)
            ostr << "BeingPainted:";

        if (value & ImpulseApplied)
            ostr << "ImpulseApplied:";

        if (value & LoadedFromScene)
            ostr << "LoadedFromScene:";

        if (value & ProcessedByRenderer)
            ostr << "ProcessedByRenderer:";

        if (value & StoredInSceneHandler)
            ostr << "StoredInSceneHandler:";

        if (value & Deformed)
            ostr << "Deformed:";

        if (value & DeformedStateChanged)
            ostr << "DeformedStateChanged:";

        if (value & HasSubdivision)
            ostr << "HasSubdivision:";

        if (value & Invalid)
            ostr << "Invalid:";

        return ostr.str();
    }
};

// the state of a RenderableNode
struct RenderableState
{
    bool isBreakable() const { return (state & PRenderableState::Breakable) == PRenderableState::Breakable; }
    bool isDeformed() const { return (state & PRenderableState::Deformed) == PRenderableState::Deformed; }
    bool hasSubdivision() const { return (state & PRenderableState::HasSubdivision) == PRenderableState::HasSubdivision; }
    bool isDeformedStateChanged() const { return (state & PRenderableState::DeformedStateChanged) == PRenderableState::DeformedStateChanged; }
    bool isSelected() const { return (state & PRenderableState::Selected) == PRenderableState::Selected; }
    bool hasSelectionChanged() const { return (state & PRenderableState::SelectionChanged) == PRenderableState::SelectionChanged; }
    bool isPickable() const { return (state & PRenderableState::Pickable) == PRenderableState::Pickable; }
    bool isDeletable() const { return (state & PRenderableState::Deletable) == PRenderableState::Deletable; }
    bool isVisible() const { return (state & PRenderableState::Visible) == PRenderableState::Visible; }
    bool isEmitter() const { return (state & PRenderableState::Emitter) == PRenderableState::Emitter; }
    bool isTarget() const { return (state & PRenderableState::Target) == PRenderableState::Target; }
    bool isFluidMesh() const { return (state & PRenderableState::FluidMesh) == PRenderableState::FluidMesh; }
    bool isSplashMesh() const { return (state & PRenderableState::SplashMesh) == PRenderableState::SplashMesh; }
    bool isSplashInstanceMesh() const { return (state & PRenderableState::SplashInstanceMesh) == PRenderableState::SplashInstanceMesh; }
    bool isMeshIsDirty() const { return (state & PRenderableState::MeshIsDirty) == PRenderableState::MeshIsDirty; }
    bool IsUserAnimated() const { return (state & PRenderableState::UserAnimated) == PRenderableState::UserAnimated; }
    bool IsUnseenByPickRay() const { return (state & PRenderableState::UnseenByPickRay) == PRenderableState::UnseenByPickRay; }
    bool IsBeingPainted() const { return (state & PRenderableState::BeingPainted) == PRenderableState::BeingPainted; }
    bool hasImpulseApplied() const { return (state & PRenderableState::ImpulseApplied) == PRenderableState::ImpulseApplied; }
    bool isLoadedFromScene() const { return (state & PRenderableState::LoadedFromScene) == PRenderableState::LoadedFromScene; }
    bool isProcessedByRenderer() const { return (state & PRenderableState::ProcessedByRenderer) == PRenderableState::ProcessedByRenderer; }
    bool isStoredInSceneHandler() const { return (state & PRenderableState::StoredInSceneHandler) == PRenderableState::StoredInSceneHandler; }
    std::string toString() { return state.toString(); }

    PRenderableState state = 0;
};